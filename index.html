<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Build a Circuit</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: white;
            margin-bottom: 30px;
            text-align: center;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-weight: 300;
        }
        
        .game-subtitle {
            color: rgba(255,255,255,0.9);
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 300;
        }
        
        .stage-title-display {
            color: rgba(255,255,255,0.95);
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.3em;
            font-weight: 600;
            background: rgba(255,255,255,0.1);
            padding: 8px 20px;
            border-radius: 20px;
            display: inline-block;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .instruction-message {
            color: #fff;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1em;
            font-weight: 500;
            background: linear-gradient(135deg, #FF6B35 0%, #F7931E 100%);
            padding: 12px 25px;
            border-radius: 25px;
            display: inline-block;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
            border: 2px solid rgba(255,255,255,0.2);
            animation: gentle-pulse 3s ease-in-out infinite;
            max-width: 600px;
        }
        
        @keyframes gentle-pulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
            }
            50% { 
                transform: scale(1.02);
                box-shadow: 0 6px 20px rgba(255, 107, 53, 0.4);
            }
        }
        
        #game-container {
            display: flex;
            gap: 25px;
            align-items: flex-start;
            background: rgba(255,255,255,0.1);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
        }
        
        #canvas-container {
            position: relative;
        }
        
        #stage-menu-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        
        #stage-menu-btn:hover {
            background-color: #1976D2;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        #stage-selector {
            position: absolute;
            top: 45px;
            right: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            border: 1px solid rgba(0,0,0,0.1);
            z-index: 99;
            min-width: 180px;
            display: none;
        }
        
        .stage-option {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stage-option:last-child {
            border-bottom: none;
            border-radius: 0 0 8px 8px;
        }
        
        .stage-option:first-child {
            border-radius: 8px 8px 0 0;
        }
        
        .stage-option:hover {
            background-color: #f5f5f5;
        }
        
        .stage-option.active {
            background-color: #E3F2FD;
            color: #1976D2;
            font-weight: bold;
        }
        
        .stage-icon {
            font-size: 16px;
        }
        
        .stage-info {
            flex: 1;
        }
        
        .stage-title {
            font-weight: 600;
            margin-bottom: 2px;
        }
        
        .stage-description {
            font-size: 12px;
            color: #666;
        }
        
        #right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #game-canvas {
            border: 3px solid rgba(255,255,255,0.3);
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        
        #item-bank {
            width: 220px;
            padding: 20px;
            background: rgba(255,255,255,0.95);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            backdrop-filter: blur(5px);
        }
        
        #item-bank h3 {
            margin-top: 0;
            margin-bottom: 18px;
            color: #333;
            text-align: center;
            font-size: 1.2em;
            font-weight: 600;
        }
        
        .item-bank-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: start;
            justify-content: center;
        }
        
        .item-tooltip {
            position: absolute;
            background-color: rgba(186, 85, 211, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            min-height: 20px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .item-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(186, 85, 211, 0.95);
        }
        
        .bank-item {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 8px !important;
            position: relative;
            overflow: hidden;
        }
        
        .bank-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }
        
        .bank-item:hover::before {
            left: 100%;
        }
        
        #controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: stretch;
        }
        
        .controls-row {
            display: flex;
            gap: 15px;
        }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        button:hover {
            background-color: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        #test-circuit-btn {
            background-color: #FF9800;
            font-weight: bold;
        }
        
        #test-circuit-btn:hover {
            background-color: #F57C00;
        }
        
        #feedback-area {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            min-height: 40px;
            max-width: 220px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .feedback-success {
            background-color: #E8F5E8;
            color: #2E7D32;
            border: 2px solid #4CAF50;
        }
        
        .feedback-error {
            background-color: #FFEBEE;
            color: #C62828;
            border: 2px solid #F44336;
        }
        
        .feedback-info {
            background-color: #E3F2FD;
            color: #1565C0;
            border: 2px solid #2196F3;
        }
        
        #success-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        #success-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            padding: 40px;
            border-radius: 15px;
            text-align: left;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            opacity: 0;
            animation: slideIn 0.4s ease-out forwards;
        }
        
        #success-content h2 {
            color: #4CAF50;
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
        }
        
        #success-details p {
            margin-bottom: 15px;
            color: #333;
            line-height: 1.5;
        }
        
        #success-explanation {
            background-color: #E8F5E8;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
            margin: 15px 0;
        }
        
        #success-explanation li {
            margin-bottom: 8px;
            color: #2E7D32;
            font-weight: 500;
            list-style: none;
        }
        
        .conductor-text {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .insulator-text {
            color: #F44336;
            font-weight: bold;
        }
        
        #materials-used {
            background-color: #F3E5F5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #9C27B0;
        }
        
        #materials-used h4 {
            color: #7B1FA2;
            margin-bottom: 10px;
        }
        
        #success-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }
        
        #success-actions button {
            flex: 1;
            max-width: 150px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { 
                opacity: 0;
                transform: translate(-50%, -60%) scale(0.8);
            }
            to { 
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        @keyframes slideOut {
            from { 
                opacity: 1;
                transform: translate(-50%, -50%);
            }
            to { 
                opacity: 0;
                transform: translate(-50%, -60%);
            }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Responsive design for larger 15x15 grid */
        @media (max-width: 1200px) {
            #game-container {
                flex-direction: column;
                align-items: center;
            }
            
            #right-panel {
                width: 100%;
                max-width: 500px;
                align-items: center;
            }
            
            #item-bank {
                width: 100%;
            }
            
            .item-bank-grid {
                gap: 6px;
            }
        }
        
        @media (max-width: 1024px) {
            #game-canvas {
                max-width: 90vw;
                max-height: 90vw;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .instruction-message {
                font-size: 1em;
                padding: 10px 20px;
                margin-bottom: 15px;
                max-width: 90%;
            }
            
            #game-container {
                padding: 15px;
            }
            
            #game-canvas {
                max-width: 95vw;
                max-height: 95vw;
            }
            
            .controls-row {
                flex-direction: column;
                width: 100%;
            }
            
            .controls-row button {
                width: 100%;
            }
            
            #stage-menu-btn {
                top: 5px;
                right: 5px;
                padding: 6px 10px;
                font-size: 12px;
            }
            
            #stage-selector {
                top: 35px;
                right: 5px;
                min-width: 160px;
            }
            
            .stage-option {
                padding: 10px 12px;
            }
            
            .stage-description {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <h1>⚡ Build a Circuit</h1>
    <p class="game-subtitle">Learn about electricity by building circuits with different materials!</p>
    <div id="stage-title" class="stage-title-display">Stage 1: Basic Circuit</div>
    
    <div class="instruction-message">
        💡 <strong>Goal:</strong> Switch on all the light bulbs by completing the circuit with the right materials!
    </div>
    
    <div id="game-container">
        <div id="canvas-container">
            <button id="stage-menu-btn">📋 Stages</button>
            <div id="stage-selector">
                <div class="stage-option active" data-stage="first">
                    <span class="stage-icon">⚡</span>
                    <div class="stage-info">
                        <div class="stage-title">Stage 1</div>
                        <div class="stage-description">Basic Circuit</div>
                    </div>
                </div>
                <div class="stage-option" data-stage="second">
                    <span class="stage-icon">⚠️</span>
                    <div class="stage-info">
                        <div class="stage-title">Stage 2</div>
                        <div class="stage-description">Short Circuit</div>
                    </div>
                </div>
                <div class="stage-option" data-stage="third">
                    <span class="stage-icon">🔗</span>
                    <div class="stage-info">
                        <div class="stage-title">Stage 3</div>
                        <div class="stage-description">Series Circuit</div>
                    </div>
                </div>
                <div class="stage-option" data-stage="fourth">
                    <span class="stage-icon">⚡</span>
                    <div class="stage-info">
                        <div class="stage-title">Stage 4</div>
                        <div class="stage-description">Parallel Circuit</div>
                    </div>
                </div>
                <div class="stage-option" data-stage="fifth">
                    <span class="stage-icon">🔀</span>
                    <div class="stage-info">
                        <div class="stage-title">Stage 5</div>
                        <div class="stage-description">Series-Parallel Circuit</div>
                    </div>
                </div>
            </div>
            <div id="game-canvas"></div>
        </div>
        <div id="right-panel">
            <div id="item-bank">
                <h3>Item Bank</h3>
                <div class="item-bank-grid" id="item-bank-grid">
                    <!-- Items will be added here by JavaScript -->
                </div>
            </div>
            
            <div id="controls">
                <div class="controls-row">
                    <button id="test-circuit-btn">⚡ Test Circuit</button>
                    <button id="reset-btn">🔄 Reset Stage</button>
                </div>
                <div id="feedback-area">
                    Try different materials in the gaps to see which ones allow electricity to flow! Drag placed items away to remove them.
                </div>
            </div>
        </div>
    </div>
    
    <!-- Success Modal -->
    <div id="success-modal">
        <div id="success-content">
            <h2>🎉 Excellent Work!</h2>
            <div id="success-details">
                <p><strong>You completed the electrical circuit!</strong></p>
                <p>The light bulb is glowing because:</p>
                <ul id="success-explanation">
                    <li>✅ Electricity flows from the battery's positive (+) terminal</li>
                    <li>✅ Through the <span class="conductor-text">conductors</span> you placed</li>
                    <li>✅ Through the light bulb (making it glow)</li>
                    <li>✅ Back to the battery's negative (-) terminal</li>
                </ul>
                <div id="materials-used">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>
            <div id="success-actions">
                <button id="play-again-btn">🔄 Try Again</button>
            </div>
        </div>
    </div>

    <!-- Phaser.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    
    <script>
        // Responsive canvas sizing
        function getOptimalCanvasSize() {
            const maxWidth = Math.min(window.innerWidth * 0.6, 900);
            const maxHeight = Math.min(window.innerHeight * 0.7, 900);
            const size = Math.min(maxWidth, maxHeight);
            return Math.max(size, 600); // Minimum size of 600px
        }

        // Game configuration
        const canvasSize = getOptimalCanvasSize();
        const config = {
            type: Phaser.AUTO,
            width: canvasSize, // Responsive size, max 900px (15 cells * 60px)
            height: canvasSize, // Responsive size, max 900px (15 cells * 60px)
            parent: 'game-canvas',
            backgroundColor: '#ffffff',
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false
                }
            }
        };

        // Game variables
        let game;
        let scene;
        let gameState = {
            grid: [],
            gridWidth: 15,
            gridHeight: 15,
            cellSize: canvasSize / 15, // Dynamic cell size based on canvas
            itemBank: [],
            placedItems: [],
            currentLayout: 'first', // Track which circuit layout is active
            circuitLayouts: {}, // Store all circuit configurations
            battery: { x: 2, y: 6, width: 1, height: 3, sprite: null },
            bulb: { x: 11, y: 6, width: 3, height: 3, sprite: null, isLit: false },
            // Two-wire circuit: top wire (positive) and bottom wire (negative)
            gaps: [
                // Top wire gaps (row 4) - Adjacent M labels count as single missing parts
                { x: 5, y: 4, filled: false, size: { width: 1, height: 1 } }, // Single M at (5,4)
                { x: 8, y: 4, filled: false, size: { width: 2, height: 1 } }, // M M at (8,4) and (9,4) = 1x2 gap
                // Bottom wire gaps (row 10) - Adjacent M labels count as single missing parts  
                { x: 6, y: 10, filled: false, size: { width: 3, height: 1 } }  // M M M at (6,10), (7,10), (8,10) = 1x3 gap
            ],
            preplacedWires: [
                // Top horizontal wire (positive path) - row 4
                { x: 3, y: 4 }, // H - Horizontal wire after L-shaped connection
                { x: 4, y: 4 }, // H - Horizontal wire before first gap
                // Gap at x:5 (M)
                { x: 6, y: 4 }, // H - Horizontal wire after first gap
                { x: 7, y: 4 }, // H - Horizontal wire before second gap
                // Gaps at x:8,9 (M M)
                { x: 10, y: 4 }, // H - Horizontal wire after gaps
                { x: 11, y: 4 }, // H - Horizontal wire before L-shaped connection
                
                // Battery connections
                { x: 2, y: 4 }, // L - L-shaped wire at top
                { x: 2, y: 5 }, // V - Vertical wire connecting to battery
                { x: 2, y: 9 }, // V - Vertical wire connecting from battery
                { x: 2, y: 10 }, // L - L-shaped wire at bottom
                
                // Bulb connections
                { x: 12, y: 4 }, // L - L-shaped wire at top
                { x: 12, y: 5 }, // V - Vertical wire connecting to bulb
                { x: 12, y: 9 }, // V - Vertical wire connecting from bulb
                { x: 12, y: 10 }, // L - L-shaped wire at bottom
                
                // Bottom horizontal wire (negative path) - row 10
                { x: 3, y: 10 }, // H - Horizontal wire after L-shaped connection
                { x: 4, y: 10 }, // H - Horizontal wire
                { x: 5, y: 10 }, // H - Horizontal wire before gaps
                // Gaps at x:6,7,8 (M M M)
                { x: 9, y: 10 }, // H - Horizontal wire after gaps
                { x: 10, y: 10 }, // H - Horizontal wire
                { x: 11, y: 10 }  // H - Horizontal wire before L-shaped connection
            ],
            draggedItem: null,
            isDragging: false,
            connectionGraphics: [], // Store connection graphics for cleanup
            confettiParticles: [], // Store confetti particles for cleanup
            circuitState: 'incomplete' // Track circuit state: 'incomplete', 'complete', 'short_circuit'
        };

        // Define all circuit layouts
        gameState.circuitLayouts = {
            first: {
                battery: { x: 2, y: 6, width: 1, height: 3 },
                bulb: { x: 11, y: 6, width: 3, height: 3 },
                gaps: [
                    { x: 5, y: 4, filled: false, size: { width: 1, height: 1 } },
                    { x: 8, y: 4, filled: false, size: { width: 2, height: 1 } },
                    { x: 6, y: 10, filled: false, size: { width: 3, height: 1 } }
                ],
                preplacedWires: [
                    // Top horizontal wire (positive path) - row 4
                    { x: 3, y: 4 }, { x: 4, y: 4 }, { x: 6, y: 4 }, { x: 7, y: 4 },
                    { x: 10, y: 4 }, { x: 11, y: 4 },
                    // Battery connections
                    { x: 2, y: 4 }, { x: 2, y: 5 }, { x: 2, y: 9 }, { x: 2, y: 10 },
                    // Bulb connections
                    { x: 12, y: 4 }, { x: 12, y: 5 }, { x: 12, y: 9 }, { x: 12, y: 10 },
                    // Bottom horizontal wire (negative path) - row 10
                    { x: 3, y: 10 }, { x: 4, y: 10 }, { x: 5, y: 10 },
                    { x: 9, y: 10 }, { x: 10, y: 10 }, { x: 11, y: 10 }
                ]
            },
            second: {
                battery: { x: 1, y: 6, width: 1, height: 3 },  // B at (1,6), (1,7), (1,8)
                bulb: { x: 11, y: 6, width: 3, height: 3 },    // O O O at (11,6)-(13,8)
                gaps: [
                    // Row 4: M M at positions (3,4) and (4,4) = 1x2 gap
                    { x: 3, y: 4, filled: false, size: { width: 2, height: 1 } },
                    // Vertical gap: M at positions (6,6), (6,7), (6,8) = 1x3 vertical gap
                    { x: 6, y: 6, filled: false, size: { width: 1, height: 3 } },
                    // Row 10: M at position (9,10) = 1x1 gap
                    { x: 9, y: 10, filled: false, size: { width: 1, height: 1 } }
                ],
                preplacedWires: [
                    // Row 4: . L H M M H T H H H H H L . .
                    { x: 1, y: 4 },   // L - L-shaped wire
                    { x: 2, y: 4 },   // H - Horizontal wire
                    // Gaps at (3,4) and (4,4) - M M
                    { x: 5, y: 4 },   // H - Horizontal wire
                    { x: 6, y: 4 },   // T - T-shaped wire
                    { x: 7, y: 4 },   // H - Horizontal wire
                    { x: 8, y: 4 },   // H - Horizontal wire
                    { x: 9, y: 4 },   // H - Horizontal wire
                    { x: 10, y: 4 },  // H - Horizontal wire
                    { x: 11, y: 4 },  // H - Horizontal wire
                    { x: 12, y: 4 },  // L - L-shaped wire (bulb connection)
                    
                    // Row 5: . V . . . . V . . . . . V . .
                    { x: 1, y: 5 },   // V - Vertical wire
                    { x: 6, y: 5 },   // V - Vertical wire (T-junction connection)
                    { x: 12, y: 5 },  // V - Vertical wire (bulb connection)
                    
                    // Row 9: . V . . . . V . . . . . V . .
                    { x: 1, y: 9 },   // V - Vertical wire
                    { x: 6, y: 9 },   // V - Vertical wire (T-junction connection)
                    { x: 12, y: 9 },  // V - Vertical wire (bulb connection)
                    
                    // Row 10: . L H H H H T H H M H H L . .
                    { x: 1, y: 10 },  // L - L-shaped wire
                    { x: 2, y: 10 },  // H - Horizontal wire
                    { x: 3, y: 10 },  // H - Horizontal wire
                    { x: 4, y: 10 },  // H - Horizontal wire
                    { x: 5, y: 10 },  // H - Horizontal wire
                    { x: 6, y: 10 },  // T - T-shaped wire
                    { x: 7, y: 10 },  // H - Horizontal wire
                    { x: 8, y: 10 },  // H - Horizontal wire
                    // Gap at (9,10) - M
                    { x: 10, y: 10 }, // H - Horizontal wire
                    { x: 11, y: 10 }, // H - Horizontal wire
                    { x: 12, y: 10 }  // L - L-shaped wire (bulb connection)
                ]
            },
            third: {
                battery: { x: 2, y: 6, width: 1, height: 3 },  // B at (2,6), (2,7), (2,8)
                bulbs: [
                    { x: 7, y: 3, width: 3, height: 3, id: 'bulb1', isLit: false },  // First bulb at (7,3) to (9,5)
                    { x: 7, y: 9, width: 3, height: 3, id: 'bulb2', isLit: false }   // Second bulb at (7,9) to (9,11)
                ],
                gaps: [
                    // Top horizontal gap: (4,4) to (5,4) = 2x1 gap
                    { x: 4, y: 4, filled: false, size: { width: 2, height: 1 } },
                    // Bottom horizontal gap: (4,10) = 1x1 gap  
                    { x: 4, y: 10, filled: false, size: { width: 1, height: 1 } },
                    // Right vertical gap: (12,6) to (12,8) = 1x3 gap
                    { x: 12, y: 6, filled: false, size: { width: 1, height: 3 } }
                ],
                preplacedWires: [
                    // L-shaped wires at corners
                    { x: 2, y: 4 },   // L - Top left L-shaped wire
                    { x: 2, y: 10 },  // L - Bottom left L-shaped wire  
                    { x: 12, y: 4 },  // L - Top right L-shaped wire
                    { x: 12, y: 10 }, // L - Bottom right L-shaped wire
                    
                    // Top horizontal wire connections (row 4)
                    { x: 3, y: 4 },   // W - Horizontal wire
                    // Gap at (4,4) to (5,4) - M M
                    { x: 6, y: 4 },   // W - Horizontal wire after gap (connects to bulb)
                    { x: 7, y: 4 },   // W - Horizontal wire (under bulb)
                    { x: 8, y: 4 },   // W - Horizontal wire (under bulb)
                    { x: 9, y: 4 },   // W - Horizontal wire (under bulb)
                    { x: 10, y: 4 },  // W - Horizontal wire
                    { x: 11, y: 4 },  // W - Horizontal wire
                    
                    // Bottom horizontal wire connections (row 10)
                    { x: 3, y: 10 },  // W - Horizontal wire
                    // Gap at (4,10) - M
                    { x: 5, y: 10 },  // W - Horizontal wire after gap
                    { x: 6, y: 10 },  // W - Horizontal wire (connects to bulb)
                    { x: 7, y: 10 },  // W - Horizontal wire (under bulb)
                    { x: 8, y: 10 },  // W - Horizontal wire (under bulb)
                    { x: 9, y: 10 },  // W - Horizontal wire (under bulb)
                    { x: 10, y: 10 }, // W - Horizontal wire
                    { x: 11, y: 10 }, // W - Horizontal wire
                    
                    // Vertical wire connections on left side (adjacent to battery)
                    { x: 2, y: 5 },   // W - Vertical wire (battery connection)
                    { x: 2, y: 9 },   // W - Vertical wire (battery connection)
                    
                    // Vertical wire connections on right side (adjacent to 3-cell missing part)
                    { x: 12, y: 5 },  // W - Vertical wire
                    { x: 12, y: 9 }   // W - Vertical wire
                    // Gap at (12,6) to (12,8) - M M M for right vertical connection
                ]
            },
            fourth: {
                battery: { x: 1, y: 6, width: 1, height: 3 },  // B at (1,6), (1,7), (1,8) - shifted right
                bulbs: [
                    { x: 5, y: 6, width: 3, height: 3, id: 'bulb1', isLit: false },  // First bulb at (5,6) to (7,8) - stays same
                    { x: 11, y: 6, width: 3, height: 3, id: 'bulb2', isLit: false }   // Second bulb at (11,6) to (13,8) - shifted right
                ],
                gaps: [
                    // Top horizontal gaps: M M at (3,4)-(4,4), M M M at (8,4)-(10,4)
                    { x: 3, y: 4, filled: false, size: { width: 2, height: 1 } },
                    { x: 8, y: 4, filled: false, size: { width: 3, height: 1 } },
                    // Bottom horizontal gap: M at (9,10) - shifted 1 cell to the left
                    { x: 9, y: 10, filled: false, size: { width: 1, height: 1 } }
                ],
                preplacedWires: [
                    // Top horizontal wire (row 4): L H M M H T H M M M H L
                    { x: 1, y: 4 },   // L - L-shaped wire (battery connection)
                    { x: 2, y: 4 },   // H - Horizontal wire
                    // Gap at (3,4)-(4,4) - M M
                    { x: 5, y: 4 },   // H - Horizontal wire
                    { x: 6, y: 4 },   // T - T-shaped wire (first bulb connection)
                    { x: 7, y: 4 },   // H - Horizontal wire
                    // Gap at (8,4)-(10,4) - M M M
                    { x: 11, y: 4 },  // H - Horizontal wire
                    { x: 12, y: 4 },  // L - L-shaped wire (second bulb connection)
                    
                    // Vertical connections for battery
                    { x: 1, y: 5 },   // V - Vertical wire (battery connection)
                    { x: 1, y: 9 },   // V - Vertical wire (battery connection)
                    
                    // Vertical connections for first bulb (T-junction at x=6)
                    { x: 6, y: 5 },   // V - Vertical wire
                    { x: 6, y: 9 },   // V - Vertical wire
                    
                    // Vertical connections for second bulb
                    { x: 12, y: 5 },  // V - Vertical wire
                    { x: 12, y: 9 },  // V - Vertical wire
                    
                    // Bottom horizontal wire (row 10): L H H H H T H H M H H L
                    { x: 1, y: 10 },  // L - L-shaped wire (battery connection)
                    { x: 2, y: 10 },  // H - Horizontal wire
                    { x: 3, y: 10 },  // H - Horizontal wire
                    { x: 4, y: 10 },  // H - Horizontal wire
                    { x: 5, y: 10 },  // H - Horizontal wire
                    { x: 6, y: 10 },  // T - T-shaped wire (first bulb connection)
                    { x: 7, y: 10 },  // H - Horizontal wire
                    { x: 8, y: 10 },  // H - Horizontal wire
                    // Gap at (9,10) - M (shifted 1 cell to the left)
                    { x: 10, y: 10 }, // H - Horizontal wire
                    { x: 11, y: 10 }, // H - Horizontal wire
                    { x: 12, y: 10 }  // L - L-shaped wire (second bulb connection)
                ]
            },
            fifth: {
                battery: { x: 1, y: 6, width: 1, height: 3 },  // B at (1,6), (1,7), (1,8) - shifted right by 1
                bulbs: [
                    { x: 5, y: 6, width: 3, height: 3, id: 'bulb1', isLit: false },  // Bulb 1 at (5,6) to (7,8) - left side
                    { x: 8, y: 3, width: 3, height: 3, id: 'bulb2', isLit: false },   // Bulb 2 at (8,3) to (10,5) - top right (shifted up 1 cell)
                    { x: 8, y: 9, width: 3, height: 3, id: 'bulb3', isLit: false }    // Bulb 3 at (8,9) to (10,11) - bottom right
                ],
                gaps: [
                    // Top horizontal gaps: M M at (3,4)-(4,4) - shifted right by 1
                    { x: 3, y: 4, filled: false, size: { width: 2, height: 1 } },
                    // Bottom horizontal gap: M at (3,10) - 1-cell gap - shifted right by 1
                    { x: 3, y: 10, filled: false, size: { width: 1, height: 1 } },
                    // Vertical 3-slot gap: M M M at (12,6)-(12,8) - right side vertical - shifted right by 1
                    { x: 12, y: 6, filled: false, size: { width: 1, height: 3 } }
                ],
                preplacedWires: [
                    // Top horizontal wire (row 4): L H M M H T H O O O H L
                    { x: 1, y: 4 },   // L - L-shaped wire (battery connection)
                    { x: 2, y: 4 },   // H - Horizontal wire
                    // Gap at (3,4)-(4,4) - M M
                    { x: 5, y: 4 },   // H - Horizontal wire
                    { x: 6, y: 4 },   // T - T-shaped wire (connects to bulb 1 and continues right)
                    { x: 7, y: 4 },   // H - Horizontal wire
                    { x: 8, y: 4 },   // H - Horizontal wire (under bulb 2)
                    { x: 9, y: 4 },   // H - Horizontal wire (under bulb 2)
                    { x: 10, y: 4 },  // H - Horizontal wire (under bulb 2)
                    { x: 11, y: 4 },  // H - Horizontal wire
                    { x: 12, y: 4 },  // L - L-shaped wire (connects to vertical gap)
                    
                    // Vertical connections for battery
                    { x: 1, y: 5 },   // V - Vertical wire (battery connection)
                    { x: 1, y: 9 },   // V - Vertical wire (battery connection)
                    
                    // Vertical connections for T-junction at (6,4) - connects to bulb 1
                    { x: 6, y: 5 },   // V - Vertical wire (connects to bulb 1)
                    { x: 6, y: 6 },   // V - Vertical wire (connects to bulb 1)
                    { x: 6, y: 7 },   // V - Vertical wire (connects to bulb 1)
                    { x: 6, y: 8 },   // V - Vertical wire (connects to bulb 1)
                    { x: 6, y: 9 },   // V - Vertical wire (connects to bulb 1)
                    { x: 6, y: 10 },  // T - T-shaped wire at bottom
                    
                    // Vertical connections for bulb 2 area (shifted up)
                    { x: 9, y: 3 },   // V - Vertical wire (connects to bulb 2 - shifted up)
                    
                    // Vertical connections for bulb 3 area
                    { x: 9, y: 9 },   // V - Vertical wire (connects from bulb 3)
                    { x: 9, y: 11 },  // V - Vertical wire (connects to bulb 3)
                    
                    // Vertical connections for vertical gap area
                    { x: 12, y: 5 },  // V - Vertical wire (before vertical gap)
                    // Gap at (12,6)-(12,8) - M M M vertical
                    { x: 12, y: 9 },  // V - Vertical wire (after vertical gap)
                    
                    // Bottom horizontal wire (row 10): L H M H H T H O O O H L
                    { x: 1, y: 10 },  // L - L-shaped wire (battery connection)
                    { x: 2, y: 10 },  // H - Horizontal wire
                    // Gap at (3,10) - M
                    { x: 4, y: 10 },  // H - Horizontal wire
                    { x: 5, y: 10 },  // H - Horizontal wire
                    // T-junction at (6,10) handled above
                    { x: 7, y: 10 },  // H - Horizontal wire
                    { x: 8, y: 10 },  // H - Horizontal wire (under bulb 3)
                    { x: 9, y: 10 },  // H - Horizontal wire (under bulb 3)
                    { x: 10, y: 10 }, // H - Horizontal wire (under bulb 3)
                    { x: 11, y: 10 }, // H - Horizontal wire
                    { x: 12, y: 10 }  // L - L-shaped wire (connects to vertical gap)
                ]
            }
        };

        function preload() {
            scene = this;
            
            // Add loading progress feedback
            scene.load.on('progress', function (value) {
                console.log('Loading progress:', value);
            });
            
            scene.load.on('complete', function () {
                console.log('All assets loaded successfully');
            });
            
            scene.load.on('loaderror', function (file) {
                console.error('Failed to load:', file.src);
            });
            
            // Load image assets
            scene.load.image('battery', 'assets/items/battery.png');
            scene.load.spritesheet('lightbulb', 'assets/items/light-bulb.png', { frameWidth: 300, frameHeight: 300 });
            
            // Load item bank images
            scene.load.image('coin', 'assets/items/coin.png');
            scene.load.image('bottlecap', 'assets/items/bottlecap.png');
            scene.load.image('key', 'assets/items/key.png');
            scene.load.image('paperclip', 'assets/items/paperclip.png');
            scene.load.image('spoon', 'assets/items/spoon.png');
            scene.load.image('ruler', 'assets/items/ruler.png');
            scene.load.image('lego', 'assets/items/lego.png');
            scene.load.image('pebble', 'assets/items/pebble.png');
            scene.load.image('button', 'assets/items/button.png');
            scene.load.image('eraser', 'assets/items/eraser.png');
            scene.load.image('rubberband', 'assets/items/rubberband.png');
            scene.load.image('popsiclestick', 'assets/items/popsiclestick.png');
            scene.load.image('straw', 'assets/items/straw.png');
        }

        function create() {
            console.log('Game scene created');
            
            // Check if all textures loaded correctly
            console.log('Available textures:', Object.keys(scene.textures.list));
            
            // Verify specific textures we need
            const requiredTextures = ['coin', 'bottlecap', 'key', 'paperclip', 'spoon', 'ruler', 'lego', 'pebble', 'button', 'eraser', 'rubberband', 'popsiclestick', 'straw'];
            requiredTextures.forEach(textureKey => {
                if (scene.textures.exists(textureKey)) {
                    console.log('✓ Texture loaded:', textureKey);
                } else {
                    console.error('✗ Texture missing:', textureKey);
                }
            });
            
            // Initialize the grid
            initializeGrid();
            
            // Draw grid lines
            drawGrid();
            
            // Load the first circuit layout
            loadCircuitLayout('first');
            
            // Create item bank
            createItemBank();
            
            // Set up input handling
            setupInputHandling();
            
            // Start position updater for HTML elements
            startPositionUpdater();
        }

        function update() {
            // Game loop - will be used for animations and updates
        }

        function initializeGrid() {
            // Initialize 2D grid array
            gameState.grid = [];
            for (let y = 0; y < gameState.gridHeight; y++) {
                gameState.grid[y] = [];
                for (let x = 0; x < gameState.gridWidth; x++) {
                    gameState.grid[y][x] = null;
                }
            }
        }

        function drawGrid() {
            const graphics = scene.add.graphics();
            graphics.lineStyle(1, 0xcccccc, 0.3);
            graphics.setDepth(0); // Set grid to lowest depth so it appears behind everything
            
            // Draw vertical lines - offset by 0.5 pixels to avoid edge clipping
            for (let x = 0; x <= gameState.gridWidth; x++) {
                const worldX = x * gameState.cellSize + 0.5;
                graphics.moveTo(worldX, 0.5);
                graphics.lineTo(worldX, gameState.gridHeight * gameState.cellSize - 0.5);
            }
            
            // Draw horizontal lines - offset by 0.5 pixels to avoid edge clipping
            for (let y = 0; y <= gameState.gridHeight; y++) {
                const worldY = y * gameState.cellSize + 0.5;
                graphics.moveTo(0.5, worldY);
                graphics.lineTo(gameState.gridWidth * gameState.cellSize - 0.5, worldY);
            }
            
            graphics.strokePath();
            
            // Highlight the circuit rows (top and bottom wires)
            graphics.lineStyle(2, 0x4CAF50, 0.3);
            graphics.fillStyle(0x4CAF50, 0.1);
            
            // Top wire (row 4)
            graphics.fillRect(0, 4 * gameState.cellSize, gameState.gridWidth * gameState.cellSize, gameState.cellSize);
            graphics.strokeRect(0, 4 * gameState.cellSize, gameState.gridWidth * gameState.cellSize, gameState.cellSize);
            
            // Bottom wire (row 10)  
            graphics.fillRect(0, 10 * gameState.cellSize, gameState.gridWidth * gameState.cellSize, gameState.cellSize);
            graphics.strokeRect(0, 10 * gameState.cellSize, gameState.gridWidth * gameState.cellSize, gameState.cellSize);
        }

        function createCircuitComponents() {
            // Create battery
            createBattery();
            
            // Create light bulb
            createLightBulb();
            
            // Create pre-placed wires
            createPreplacedWires();
            
            // Mark gaps in the grid
            markGaps();
        }

        function createBattery() {
            // Battery now spans 1x3 cells (width=1, height=3) at position (2, 4-6)
            const centerX = gameState.battery.x;
            const centerY = gameState.battery.y + 1; // Center of the three cells
            const pos = gridToWorld(centerX, centerY);
            
            // Create battery using image asset - sized to fill 1x3 cells completely
            let batteryImage;
            if (scene.textures.exists('battery')) {
                batteryImage = scene.add.image(pos.x, pos.y, 'battery');
                batteryImage.setDisplaySize(gameState.cellSize, gameState.cellSize * 3); // Full 1x3 cells
                console.log('Battery image created successfully');
            } else {
                console.error('Battery texture not found, creating fallback');
                // Create fallback colored rectangle for full 1x3 cells
                batteryImage = scene.add.rectangle(pos.x, pos.y, gameState.cellSize, gameState.cellSize * 3, 0x333333);
                batteryImage.setStrokeStyle(2, 0x000000);
            }
            
            // Set depth to appear above wires
            batteryImage.setDepth(10);
            
            // Group all battery components
            gameState.battery.sprite = scene.add.group([
                batteryImage
            ]);
            
            // Mark battery positions in grid (all three cells: y=4,5,6)
            for (let dy = 0; dy < gameState.battery.height; dy++) {
                setGridPosition(gameState.battery.x, gameState.battery.y + dy, 'battery');
            }
        }

        function createLightBulb() {
            // Handle single bulb (Stage 1 & 2) or dual bulbs (Stage 3)
            if (gameState.bulbs) {
                // Stage 3: Create multiple bulbs
                gameState.bulbs.forEach((bulb, index) => {
                    createSingleBulb(bulb, `bulb${index + 1}`);
                });
            } else if (gameState.bulb) {
                // Stage 1 & 2: Create single bulb
                createSingleBulb(gameState.bulb, 'bulb');
            }
        }
        
        function createSingleBulb(bulbConfig, bulbId) {
            // Calculate center position based on bulb dimensions
            const centerX = bulbConfig.x + (bulbConfig.width - 1) / 2;
            const centerY = bulbConfig.y + (bulbConfig.height - 1) / 2;
            const pos = gridToWorld(centerX, centerY);
            
            // Create light bulb using spritesheet (frame 0 = off, frame 1 = on)
            let bulbSprite;
            if (scene.textures.exists('lightbulb')) {
                bulbSprite = scene.add.sprite(pos.x, pos.y, 'lightbulb', 0);
                bulbSprite.setDisplaySize(gameState.cellSize * bulbConfig.width, gameState.cellSize * bulbConfig.height);
                console.log(`Light bulb sprite ${bulbId} created successfully`);
            } else {
                console.error(`Light bulb texture not found for ${bulbId}, creating fallback`);
                // Create fallback colored circle
                const radius = Math.min(bulbConfig.width, bulbConfig.height) * gameState.cellSize / 2 * 0.8;
                bulbSprite = scene.add.circle(pos.x, pos.y, radius, 0xFFFFFF);
                bulbSprite.setStrokeStyle(2, 0x000000);
                bulbSprite.setAlpha(0.8);
            }
            
            // Set depth to appear above wires
            bulbSprite.setDepth(10);
            
            // Store references for later use
            bulbConfig.sprite = scene.add.group([bulbSprite]);
            bulbConfig.bulbSprite = bulbSprite;
            
            // Mark bulb positions in grid
            for (let dx = 0; dx < bulbConfig.width; dx++) {
                for (let dy = 0; dy < bulbConfig.height; dy++) {
                    setGridPosition(bulbConfig.x + dx, bulbConfig.y + dy, bulbId);
                }
            }
        }

        function createPreplacedWires() {
            gameState.preplacedWires.forEach(wire => {
                const pos = gridToWorld(wire.x, wire.y);
                
                // Determine wire type based on position and connections
                const wireType = determineWireType(wire.x, wire.y);
                
                // Create wire segment based on type
                if (wireType === 'L-shaped') {
                    wire.sprite = createLShapedWire(pos, wire.x, wire.y);
                } else if (wireType === 'T-shaped') {
                    wire.sprite = createTShapedWire(pos, wire.x, wire.y);
                } else {
                    // Create straight wire - determine orientation based on position
                    wire.sprite = createStraightWire(pos, wire.x, wire.y);
                }
                
                // Mark wire position in grid
                setGridPosition(wire.x, wire.y, 'wire');
            });
        }

        function determineWireType(x, y) {
            // Apply T-junction logic for specific circuit layouts
            if (gameState.currentLayout === 'second') {
                // Specific T-junction positions in the second layout
                if ((x === 6 && y === 4) || (x === 6 && y === 10)) {
                    return 'T-shaped';
                }
            } else if (gameState.currentLayout === 'fourth') {
                // Specific T-junction positions in the fourth layout
                if ((x === 6 && y === 4) || (x === 6 && y === 10)) {
                    return 'T-shaped';
                }
            } else if (gameState.currentLayout === 'fifth') {
                // Specific T-junction positions in the fifth layout
                if ((x === 6 && y === 4) || (x === 6 && y === 10)) {
                    return 'T-shaped';
                }
            }
            
            // Check for L-shaped junctions (corner connections)
            const adjacentWires = getAdjacentWireCount(x, y);
            if (adjacentWires === 2) {
                // Check if it's a corner (not straight line)
                const directions = getAdjacentWireDirections(x, y);
                if (directions.length === 2) {
                    const [dir1, dir2] = directions;
                    // If directions are perpendicular, it's an L-shape
                    if ((dir1.dx === 0) !== (dir2.dx === 0)) {
                        return 'L-shaped';
                    }
                }
            }
            
            // Check for T-shaped junctions (where three or more wires meet)
            if (adjacentWires >= 3) {
                return 'T-shaped';
            }
            
            return 'straight';
        }

        function getAdjacentWireCount(x, y) {
            let count = 0;
            const directions = [
                { dx: -1, dy: 0 }, // left
                { dx: 1, dy: 0 },  // right
                { dx: 0, dy: -1 }, // up
                { dx: 0, dy: 1 }   // down
            ];
            
            directions.forEach(dir => {
                const checkX = x + dir.dx;
                const checkY = y + dir.dy;
                if (isWirePosition(checkX, checkY)) {
                    count++;
                }
            });
            
            return count;
        }

        function getAdjacentWireDirections(x, y) {
            const directions = [];
            const checkDirections = [
                { dx: -1, dy: 0 }, // left
                { dx: 1, dy: 0 },  // right
                { dx: 0, dy: -1 }, // up
                { dx: 0, dy: 1 }   // down
            ];
            
            checkDirections.forEach(dir => {
                const checkX = x + dir.dx;
                const checkY = y + dir.dy;
                if (isWirePosition(checkX, checkY)) {
                    directions.push(dir);
                }
            });
            
            return directions;
        }

        function isWirePosition(x, y) {
            return gameState.preplacedWires.some(wire => wire.x === x && wire.y === y) ||
                   getGridPosition(x, y) === 'wire';
        }

        function createStraightWire(pos, x, y) {
            const group = scene.add.group();
            const wireThickness = 12; // Thicker wires for better connection
            const wireLength = gameState.cellSize; // Full cell size for proper connection
            
            // Determine if this should be a vertical or horizontal wire
            const isVerticalWire = isVerticalWirePosition(x, y);
            
            let wireSprite;
            if (isVerticalWire) {
                // Create vertical wire - full height
                wireSprite = scene.add.rectangle(pos.x, pos.y, wireThickness, wireLength, 0xCD7F32);
            } else {
                // Create horizontal wire - full width
                wireSprite = scene.add.rectangle(pos.x, pos.y, wireLength, wireThickness, 0xCD7F32);
            }
            
            wireSprite.setStrokeStyle(1, 0x8B4513);
            wireSprite.setDepth(5);
            group.add(wireSprite);
            
            return group;
        }

        function isVerticalWirePosition(x, y) {
            if (gameState.currentLayout === 'first') {
                // First circuit: Vertical wires at (2,5), (2,9), (12,5), (12,9)
                return (x === 2 && (y === 5 || y === 9)) || (x === 12 && (y === 5 || y === 9));
            } else if (gameState.currentLayout === 'second') {
                // Second circuit: Vertical wires at (1,5), (1,9), (6,5), (6,9), (12,5), (12,9)
                return (x === 1 && (y === 5 || y === 9)) || 
                       (x === 6 && (y === 5 || y === 9)) || 
                       (x === 12 && (y === 5 || y === 9));
            } else if (gameState.currentLayout === 'third') {
                // Third circuit: Vertical wires at (2,5), (2,9), (12,5), (12,9)
                return (x === 2 && (y === 5 || y === 9)) || 
                       (x === 12 && (y === 5 || y === 9));
            } else if (gameState.currentLayout === 'fourth') {
                // Fourth circuit: Vertical wires at (1,5), (1,9), (6,5), (6,9), (12,5), (12,9)
                return (x === 1 && (y === 5 || y === 9)) || 
                       (x === 6 && (y === 5 || y === 9)) || 
                       (x === 12 && (y === 5 || y === 9));
            } else if (gameState.currentLayout === 'fifth') {
                // Fifth circuit: Vertical wires for new bulb positions
                return (x === 1 && (y === 5 || y === 9)) || 
                       (x === 6 && (y >= 5 && y <= 10)) || 
                       (x === 9 && (y === 3 || y === 9 || y === 11)) ||
                       (x === 12 && (y === 5 || y === 9));
            }
            return false;
        }

        function createLShapedWire(pos, x, y) {
            const group = scene.add.group();
            const wireThickness = 12; // Match straight wire thickness
            const halfCell = gameState.cellSize / 2;
            
            // Create L-shaped wires based on current layout
            if (gameState.currentLayout === 'first') {
                // First circuit L-wire positions
                if (x === 2 && y === 4) {
                    // Battery top L-wire: connects right and down
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 2 && y === 10) {
                    // Battery bottom L-wire: connects right and up
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 4) {
                    // Bulb top L-wire: connects left and down
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 10) {
                    // Bulb bottom L-wire: connects left and up
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                }
            } else if (gameState.currentLayout === 'second') {
                // Second circuit L-wire positions
                if (x === 1 && y === 4) {
                    // Battery top L-wire: connects right and down
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 1 && y === 10) {
                    // Battery bottom L-wire: connects right and up
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 4) {
                    // Bulb top L-wire: connects left and down
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 10) {
                    // Bulb bottom L-wire: connects left and up
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                }
            } else if (gameState.currentLayout === 'third') {
                // Third circuit L-wire positions
                if (x === 2 && y === 4) {
                    // Battery top L-wire: connects right and down
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 2 && y === 10) {
                    // Battery bottom L-wire: connects right and up
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 4) {
                    // Right top L-wire: connects left and down
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 10) {
                    // Right bottom L-wire: connects left and up
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                }
            } else if (gameState.currentLayout === 'fourth') {
                // Fourth circuit L-wire positions
                if (x === 1 && y === 4) {
                    // Battery top L-wire: connects right and down
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 1 && y === 10) {
                    // Battery bottom L-wire: connects right and up
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 4) {
                    // Second bulb top L-wire: connects left and down
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 10) {
                    // Second bulb bottom L-wire: connects left and up
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                }
            } else if (gameState.currentLayout === 'fifth') {
                // Fifth circuit L-wire positions - shifted right by 1
                if (x === 1 && y === 4) {
                    // Battery top L-wire: connects right and down
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 1 && y === 10) {
                    // Battery bottom L-wire: connects right and up
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 4) {
                    // Right side top L-wire: connects left and down
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 10) {
                    // Right side bottom L-wire: connects left and up
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                }
            }
            
            // Add center junction piece for proper connection
            const centerPiece = scene.add.rectangle(pos.x, pos.y, wireThickness, wireThickness, 0xCD7F32);
            centerPiece.setStrokeStyle(1, 0x8B4513);
            centerPiece.setDepth(5);
            group.add(centerPiece);
            
            return group;
        }

        function createTShapedWire(pos, x, y) {
            const group = scene.add.group();
            const wireThickness = 12; // Match L-shaped wire thickness
            const halfCell = gameState.cellSize / 2;
            
            // Create T-shaped wires with segments extending to cell edges, similar to L-shaped wires
            if (x === 6 && y === 4) {
                // T-junction at (6,4) - connects left, right, and down
                // Left horizontal segment
                const leftWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                leftWire.setStrokeStyle(1, 0x8B4513);
                leftWire.setDepth(5);
                group.add(leftWire);
                
                // Right horizontal segment
                const rightWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                rightWire.setStrokeStyle(1, 0x8B4513);
                rightWire.setDepth(5);
                group.add(rightWire);
                
                // Downward vertical segment
                const downWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                downWire.setStrokeStyle(1, 0x8B4513);
                downWire.setDepth(5);
                group.add(downWire);
                
            } else if (x === 6 && y === 10) {
                // T-junction at (6,10) - connects left, right, and up
                // Left horizontal segment
                const leftWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                leftWire.setStrokeStyle(1, 0x8B4513);
                leftWire.setDepth(5);
                group.add(leftWire);
                
                // Right horizontal segment
                const rightWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                rightWire.setStrokeStyle(1, 0x8B4513);
                rightWire.setDepth(5);
                group.add(rightWire);
                
                // Upward vertical segment
                const upWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                upWire.setStrokeStyle(1, 0x8B4513);
                upWire.setDepth(5);
                group.add(upWire);
                
            } else {
                // Generic T-junction logic for other positions
                const hasWireLeft = isWirePosition(x - 1, y);
                const hasWireRight = isWirePosition(x + 1, y);
                const hasWireAbove = isWirePosition(x, y - 1);
                const hasWireBelow = isWirePosition(x, y + 1);
                
                // Create horizontal segments
                if (hasWireLeft) {
                    const leftWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    leftWire.setStrokeStyle(1, 0x8B4513);
                    leftWire.setDepth(5);
                    group.add(leftWire);
                }
                if (hasWireRight) {
                    const rightWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    rightWire.setStrokeStyle(1, 0x8B4513);
                    rightWire.setDepth(5);
                    group.add(rightWire);
                }
                
                // Create vertical segments
                if (hasWireAbove) {
                    const upWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    upWire.setStrokeStyle(1, 0x8B4513);
                    upWire.setDepth(5);
                    group.add(upWire);
                }
                if (hasWireBelow) {
                    const downWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    downWire.setStrokeStyle(1, 0x8B4513);
                    downWire.setDepth(5);
                    group.add(downWire);
                }
            }
            
            // Add center junction piece for proper connection (like L-shaped wires)
            const centerPiece = scene.add.rectangle(pos.x, pos.y, wireThickness, wireThickness, 0xCD7F32);
            centerPiece.setStrokeStyle(1, 0x8B4513);
            centerPiece.setDepth(5);
            group.add(centerPiece);
            
            return group;
        }

        function markGaps() {
            gameState.gaps.forEach(gap => {
                // Calculate gap size based on the gap's size property
                const gapSize = gap.size || { width: 1, height: 1 };
                const cellSize = gameState.cellSize;
                
                // Create gap indicator (dashed outline using multiple small lines)
                const graphics = scene.add.graphics();
                graphics.lineStyle(2, 0xFF6B6B, 0.8);
                
                // Calculate position - use top-left corner of grid cell, not center
                const x = gap.x * cellSize;
                const y = gap.y * cellSize;
                const width = cellSize * gapSize.width;
                const height = cellSize * gapSize.height;
                const dashLength = 5;
                const gapLength = 5;
                
                // Top line
                for (let i = 0; i < width; i += dashLength + gapLength) {
                    const lineWidth = Math.min(dashLength, width - i);
                    graphics.moveTo(x + i, y);
                    graphics.lineTo(x + i + lineWidth, y);
                }
                
                // Bottom line
                for (let i = 0; i < width; i += dashLength + gapLength) {
                    const lineWidth = Math.min(dashLength, width - i);
                    graphics.moveTo(x + i, y + height);
                    graphics.lineTo(x + i + lineWidth, y + height);
                }
                
                // Left line
                for (let i = 0; i < height; i += dashLength + gapLength) {
                    const lineHeight = Math.min(dashLength, height - i);
                    graphics.moveTo(x, y + i);
                    graphics.lineTo(x, y + i + lineHeight);
                }
                
                // Right line
                for (let i = 0; i < height; i += dashLength + gapLength) {
                    const lineHeight = Math.min(dashLength, height - i);
                    graphics.moveTo(x + width, y + i);
                    graphics.lineTo(x + width, y + i + lineHeight);
                }
                
                graphics.strokePath();
                
                // Store only the graphics (no text label for cleaner appearance)
                gap.sprite = scene.add.group([graphics]);
                
                // Mark all cells occupied by this gap
                for (let dy = 0; dy < gapSize.height; dy++) {
                    for (let dx = 0; dx < gapSize.width; dx++) {
                        setGridPosition(gap.x + dx, gap.y + dy, 'gap');
                    }
                }
            });
        }

        function updateLightBulb(isLit) {
            if (gameState.bulb && gameState.bulb.bulbSprite) {
                if (isLit) {
                    // Try to use frame 1 for lit state if it's a sprite, otherwise change tint
                    if (gameState.bulb.bulbSprite.setFrame && typeof gameState.bulb.bulbSprite.setFrame === 'function') {
                        gameState.bulb.bulbSprite.setFrame(1);
                    } else {
                        // Fallback: change tint to yellow for lit state
                        gameState.bulb.bulbSprite.setTint(0xFFFF88);
                    }
                    
                    // Add glow effect
                    if (!gameState.bulb.glowEffect) {
                        gameState.bulb.glowEffect = scene.add.circle(
                            gameState.bulb.bulbSprite.x, 
                            gameState.bulb.bulbSprite.y, 
                            35, 0xFFFF00
                        );
                        gameState.bulb.glowEffect.setAlpha(0.3);
                        gameState.bulb.glowEffect.setDepth(-1);
                    }
                    gameState.bulb.glowEffect.setVisible(true);
                } else {
                    // Try to use frame 0 for off state if it's a sprite, otherwise clear tint
                    if (gameState.bulb.bulbSprite.setFrame && typeof gameState.bulb.bulbSprite.setFrame === 'function') {
                        gameState.bulb.bulbSprite.setFrame(0);
                    } else {
                        // Fallback: clear tint for off state
                        gameState.bulb.bulbSprite.clearTint();
                    }
                    
                    if (gameState.bulb.glowEffect) {
                        gameState.bulb.glowEffect.setVisible(false);
                    }
                }
                gameState.bulb.isLit = isLit;
            }
        }

        function createItemBank() {
            const itemBankContainer = document.getElementById('item-bank-grid');
            
            // Define available items - real-world materials with sizes
            const itemDefinitions = [
                // Conductors
                {
                    id: 'coin',
                    name: 'Copper Coin',
                    type: 'conductor',
                    conductive: true,
                    imageKey: 'coin',
                    size: { width: 1, height: 1 },
                    quantity: 1
                },
                {
                    id: 'bottlecap',
                    name: 'Bottle Cap',
                    type: 'conductor',
                    conductive: true,
                    imageKey: 'bottlecap',
                    size: { width: 1, height: 1 },
                    quantity: 1
                },
                {
                    id: 'key',
                    name: 'Metal Key',
                    type: 'conductor',
                    conductive: true,
                    imageKey: 'key',
                    size: { width: 2, height: 1 },
                    quantity: 1
                },
                {
                    id: 'paperclip',
                    name: 'Paper Clip',
                    type: 'conductor',
                    conductive: true,
                    imageKey: 'paperclip',
                    size: { width: 2, height: 1 },
                    quantity: 1
                },
                {
                    id: 'spoon',
                    name: 'Spoon',
                    type: 'conductor',
                    conductive: true,
                    imageKey: 'spoon',
                    size: { width: 3, height: 1 },
                    quantity: 1
                },
                {
                    id: 'ruler',
                    name: 'Metal Ruler',
                    type: 'conductor',
                    conductive: true,
                    imageKey: 'ruler',
                    size: { width: 3, height: 1 },
                    quantity: 1
                },
                // Insulators
                {
                    id: 'lego',
                    name: 'Lego Brick',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'lego',
                    size: { width: 1, height: 1 },
                    quantity: 1
                },
                {
                    id: 'pebble',
                    name: 'Pebble',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'pebble',
                    size: { width: 1, height: 1 },
                    quantity: 1
                },
                {
                    id: 'button',
                    name: 'Button',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'button',
                    size: { width: 1, height: 1 },
                    quantity: 1
                },
                {
                    id: 'eraser',
                    name: 'Eraser',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'eraser',
                    size: { width: 2, height: 1 },
                    quantity: 1
                },
                {
                    id: 'rubberband',
                    name: 'Rubber Band',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'rubberband',
                    size: { width: 2, height: 1 },
                    quantity: 1
                },
                {
                    id: 'popsiclestick',
                    name: 'Popsicle Stick',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'popsiclestick',
                    size: { width: 3, height: 1 },
                    quantity: 1
                },
                {
                    id: 'straw',
                    name: 'Straw',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'straw',
                    size: { width: 3, height: 1 },
                    quantity: 1
                }
            ];
            
            // Sort items by ascending cell size (width * height), then by name for consistent ordering
            const sortedItemDefinitions = itemDefinitions.sort((a, b) => {
                const aCellCount = a.size.width * a.size.height;
                const bCellCount = b.size.width * b.size.height;
                
                // First sort by cell count
                if (aCellCount !== bCellCount) {
                    return aCellCount - bCellCount;
                }
                
                // If same cell count, sort alphabetically by name for consistent ordering
                return a.name.localeCompare(b.name);
            });
            
            // Create item bank items
            sortedItemDefinitions.forEach(itemDef => {
                for (let i = 0; i < itemDef.quantity; i++) {
                    const item = createBankItem(itemDef, i);
                    gameState.itemBank.push(item);
                    
                    // Create HTML element for the item
                    const itemElement = createItemBankElement(item);
                    itemBankContainer.appendChild(itemElement);
                }
            });
        }

        function createBankItem(definition, index) {
            return {
                id: `${definition.id}_${index}`,
                name: definition.name,
                type: definition.type,
                conductive: definition.conductive,
                imageKey: definition.imageKey,
                size: definition.size || { width: 1, height: 1 },
                inBank: true,
                placed: false,
                sprite: null,
                htmlElement: null,
                gridX: -1,
                gridY: -1
            };
        }

        function createItemBankElement(item) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'bank-item';
            
            // Calculate size based on item dimensions - make width differences more pronounced
            const baseWidth = 60;
            const baseHeight = 40;
            const width = baseWidth + (item.size.width - 1) * 30; // More width difference
            const height = baseHeight + (item.size.height - 1) * 10; // Less height difference
            
            itemDiv.style.cssText = `
                width: ${width}px;
                height: ${height}px;
                cursor: grab;
                user-select: none;
                transition: transform 0.2s, box-shadow 0.2s;
                margin: 2px;
                position: relative;
                background-size: contain;
                background-repeat: no-repeat;
                background-position: center;
                background-image: url('assets/items/${item.imageKey}.png');
            `;
            
            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.style.cssText = `
                position: absolute;
                background-color: rgba(186, 85, 211, 0.95);
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 12px;
                font-weight: bold;
                white-space: nowrap;
                z-index: 1000;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.2s;
                min-height: 20px;
                display: flex;
                align-items: center;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            `;
            
            // Calculate size information for tooltip content
            const itemSize = item.size || { width: 1, height: 1 };
            const totalCells = itemSize.width * itemSize.height;
            const cellText = totalCells === 1 ? 'cell' : 'cells';
            tooltip.innerHTML = `${item.name} (${totalCells} ${cellText})`;
            
            // Add arrow to tooltip
            const arrow = document.createElement('div');
            arrow.style.cssText = `
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                width: 0;
                height: 0;
                border-left: 6px solid transparent;
                border-right: 6px solid transparent;
                border-top: 6px solid rgba(186, 85, 211, 0.95);
            `;
            tooltip.appendChild(arrow);
            
            // Add tooltip to body
            document.body.appendChild(tooltip);
            
            // Add hover effects with tooltip
            itemDiv.addEventListener('mouseenter', function(e) {
                if (item.inBank) {
                    this.style.transform = 'scale(1.05)';
                    this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
                    
                    // Position tooltip using element-relative coordinates with scroll offset
                    const rect = this.getBoundingClientRect();
                    const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                    const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                    
                    // Calculate tooltip position relative to the item element
                    const tooltipWidth = tooltip.offsetWidth;
                    const tooltipHeight = tooltip.offsetHeight;
                    const itemCenterX = rect.left + scrollX + (rect.width / 2);
                    const itemTopY = rect.top + scrollY;
                    
                    // Center tooltip horizontally above the item
                    let tooltipLeft = itemCenterX - (tooltipWidth / 2);
                    let tooltipTop = itemTopY - tooltipHeight - 8;
                    
                    // Ensure tooltip doesn't go off-screen horizontally
                    const minLeft = 10;
                    const maxLeft = window.innerWidth - tooltipWidth - 10;
                    tooltipLeft = Math.max(minLeft, Math.min(tooltipLeft, maxLeft));
                    
                    // Ensure tooltip doesn't go off-screen vertically
                    if (tooltipTop < 10) {
                        tooltipTop = itemTopY + rect.height + 8; // Position below item if no space above
                    }
                    
                    tooltip.style.left = tooltipLeft + 'px';
                    tooltip.style.top = tooltipTop + 'px';
                    tooltip.style.opacity = '1';
                }
            });
            
            itemDiv.addEventListener('mouseleave', function() {
                if (item.inBank) {
                    this.style.transform = 'scale(1)';
                    this.style.boxShadow = 'none';
                    tooltip.style.opacity = '0';
                }
            });
            
            // Store references
            item.htmlElement = itemDiv;
            item.tooltip = tooltip;
            itemDiv.itemData = item;
            
            return itemDiv;
        }

        function createGameSprite(item, x, y, needsRotation = false) {
            // Calculate sprite size based on the actual grid space it occupies
            const cellSize = gameState.cellSize;
            
            // For rotated items, the container should match the gap size (1x3), not the item's original size
            let spriteWidth, spriteHeight;
            if (needsRotation) {
                // Item is rotated to fit in a 1x3 vertical gap
                spriteWidth = cellSize * 1;  // 1 cell wide
                spriteHeight = cellSize * 3; // 3 cells tall
            } else {
                // Normal orientation - use item's original size
                spriteWidth = cellSize * item.size.width;
                spriteHeight = cellSize * item.size.height;
            }
            
            // Position items to align with grid cells - use top-left corner like gap indicators
            const adjustedX = x * cellSize;
            const adjustedY = y * cellSize;
            
            // Create HTML element for the circuit item positioned relative to canvas
            const canvas = document.querySelector('canvas');
            const canvasContainer = canvas.parentElement;
            
            // Ensure canvas container has relative positioning
            if (canvasContainer && canvasContainer.style.position !== 'relative') {
                canvasContainer.style.position = 'relative';
            }
            
            const itemElement = document.createElement('div');
            
            if (needsRotation) {
                // For rotated items, create a container that fills the gap (1x3)
                itemElement.style.cssText = `
                    position: absolute;
                    left: ${adjustedX}px;
                    top: ${adjustedY}px;
                    width: ${spriteWidth}px;
                    height: ${spriteHeight}px;
                    pointer-events: none;
                    z-index: 10;
                    cursor: pointer;
                `;
                
                // Create the rotated image that fills the container
                // The key insight: we want the image to fill the 1x3 container when rotated
                // So we need to size it as 3x1 initially, then rotate it
                const imageDiv = document.createElement('div');
                imageDiv.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: ${spriteHeight}px;
                    height: ${spriteWidth}px;
                    background-image: url('assets/items/${item.imageKey}.png');
                    background-size: contain;
                    background-repeat: no-repeat;
                    background-position: center;
                    transform: translate(-50%, -50%) rotate(90deg);
                    transform-origin: center;
                `;
                itemElement.appendChild(imageDiv);
            } else {
                // Normal orientation
                itemElement.style.cssText = `
                    position: absolute;
                    left: ${adjustedX}px;
                    top: ${adjustedY}px;
                    width: ${spriteWidth}px;
                    height: ${spriteHeight}px;
                    background-image: url('assets/items/${item.imageKey}.png');
                    background-size: contain;
                    background-repeat: no-repeat;
                    background-position: center;
                    pointer-events: none;
                    z-index: 10;
                    cursor: pointer;
                `;
            }
            
            // Append to canvas container instead of body
            if (canvasContainer) {
                canvasContainer.appendChild(itemElement);
            } else {
                // Fallback to canvas parent or body
                canvas.parentNode.appendChild(itemElement);
            }
            
            // Create an invisible Phaser sprite for interaction handling (centered for Phaser)
            const phaserCenterX = adjustedX + spriteWidth/2;
            const phaserCenterY = adjustedY + spriteHeight/2;
            const itemSprite = scene.add.rectangle(phaserCenterX, phaserCenterY, spriteWidth, spriteHeight, 0x000000, 0.01);
            itemSprite.htmlElement = itemElement;
            
            // Store positioning function for updates
            itemSprite.updateHtmlPosition = function() {
                if (this.htmlElement) {
                    // Convert Phaser center position to HTML top-left position relative to canvas
                    this.htmlElement.style.left = (this.x - spriteWidth/2) + 'px';
                    this.htmlElement.style.top = (this.y - spriteHeight/2) + 'px';
                }
            };
            
            // Set initial position correctly
            setTimeout(() => {
                itemSprite.updateHtmlPosition();
            }, 10);
            
            // Size indicator and text removed for cleaner visual design
            
            // Store original position and dimensions for drag distance calculation
            item.originalX = phaserCenterX;
            item.originalY = phaserCenterY;
            item.originalGridX = x;
            item.originalGridY = y;
            item.spriteHeight = spriteHeight;
            
            // Only make draggable if it's not a pre-placed component
            if (!isPreplacedComponent(x, y)) {
                itemSprite.setInteractive({ 
                    draggable: true,
                    useHandCursor: true
                });
                
                // Add removal hint on hover
                itemSprite.on('pointerover', function() {
                    if (this.htmlElement) {
                        this.htmlElement.style.filter = 'brightness(0.7) sepia(1) hue-rotate(0deg) saturate(2)';
                        this.htmlElement.style.cursor = 'grab';
                    }
                    // Show tooltip hint
                    if (!item.isDragging) {
                        showFeedback('💡 Tip: Drag this item away to remove it from the circuit!', 'info');
                    }
                });
                
                itemSprite.on('pointerout', function() {
                    if (!item.isDragging && this.htmlElement) {
                        this.htmlElement.style.filter = 'none';
                        this.htmlElement.style.cursor = 'pointer';
                    }
                });
                
                // Enhanced drag functionality for removal with distance threshold detection
                itemSprite.on('dragstart', function(pointer, dragX, dragY) {
                    console.log('Started dragging placed item for potential removal');
                    item.isDragging = true;
                    
                    // Temporarily remove from placed items list
                    const itemIndex = gameState.placedItems.indexOf(item);
                    if (itemIndex > -1) {
                        gameState.placedItems.splice(itemIndex, 1);
                    }
                    
                    // Immediately show the gap indicator and clear grid positions when dragging starts
                    const effectiveWidth = item.isRotated ? item.size.height : item.size.width;
                    const effectiveHeight = item.isRotated ? item.size.width : item.size.height;
                    
                    // Clear grid positions occupied by this item
                    for (let dy = 0; dy < effectiveHeight; dy++) {
                        for (let dx = 0; dx < effectiveWidth; dx++) {
                            setGridPosition(item.gridX + dx, item.gridY + dy, null);
                        }
                    }
                    
                    const gap = gameState.gaps.find(g => {
                        if (item.isRotated) {
                            return g.x === item.gridX && g.y === item.gridY &&
                                   g.size.width === effectiveWidth && g.size.height === effectiveHeight;
                        } else {
                            return g.x === item.gridX && g.y === item.gridY &&
                                   g.size.width === effectiveWidth && g.size.height === effectiveHeight;
                        }
                    });
                    
                    if (gap) {
                        // Temporarily mark gap as unfilled and show indicator
                        gap.filled = false;
                        gap.filledWith = null;
                        if (gap.sprite) {
                            gap.sprite.setVisible(true);
                        }
                        console.log('Gap indicator shown for dragging item');
                    }
                    
                    // Visual feedback - make semi-transparent and bring to front
                    if (this.htmlElement) {
                        this.htmlElement.style.opacity = '0.8';
                        this.htmlElement.style.zIndex = '1000';
                        this.htmlElement.style.filter = 'brightness(0.7) sepia(1) hue-rotate(0deg) saturate(2)';
                    }
                    
                    // Show initial drag feedback
                    showFeedback('Drag away from circuit to remove item, or drop back to replace', 'info');
                });
                
                itemSprite.on('drag', function(pointer, dragX, dragY) {
                    // Update positions
                    this.x = dragX;
                    this.y = dragY;
                    
                    // Update HTML element position (relative to canvas)
                    if (this.htmlElement) {
                        this.htmlElement.style.left = (dragX - spriteWidth/2) + 'px';
                        this.htmlElement.style.top = (dragY - spriteHeight/2) + 'px';
                    }
                    
                    // Enhanced distance threshold detection
                    const distance = Phaser.Math.Distance.Between(
                        item.originalX, item.originalY, dragX, dragY
                    );
                    
                    // Remove item when dragged outside its occupied cells
                    const REMOVAL_THRESHOLD = gameState.cellSize * 0.75; // 75% of a cell size
                    
                    if (distance > REMOVAL_THRESHOLD) {
                        // Visual feedback for removal zone
                        if (this.htmlElement) {
                            this.htmlElement.style.filter = 'brightness(0.5) sepia(1) hue-rotate(0deg) saturate(3)';
                            this.htmlElement.style.opacity = '0.6';
                        }
                        
                        // Show removal hint with icon
                        if (!item.removalHint) {
                            item.removalHint = scene.add.text(dragX, dragY - 40, '🗑️ Release to remove', {
                                fontSize: '12px',
                                fill: '#FF0000',
                                backgroundColor: '#ffffff',
                                padding: { x: 6, y: 3 }
                            }).setOrigin(0.5).setDepth(1001);
                        } else {
                            item.removalHint.x = dragX;
                            item.removalHint.y = dragY - 40;
                        }
                        
                        // Update feedback message
                        showFeedback('Release to remove item from circuit', 'error');
                    } else {
                        // Normal drag visual feedback
                        if (this.htmlElement) {
                            this.htmlElement.style.filter = 'brightness(0.7) sepia(1) hue-rotate(0deg) saturate(2)';
                            this.htmlElement.style.opacity = '0.8';
                        }
                        
                        // Hide removal hint
                        if (item.removalHint) {
                            item.removalHint.destroy();
                            item.removalHint = null;
                        }
                        
                        // Update feedback message
                        showFeedback('Drag outside the cell to remove item', 'info');
                    }
                });
                
                itemSprite.on('dragend', function(pointer, dragX, dragY) {
                    console.log('Ended dragging placed item');
                    item.isDragging = false;
                    
                    // Clean up removal hint
                    if (item.removalHint) {
                        item.removalHint.destroy();
                        item.removalHint = null;
                    }
                    
                    // Use the sprite's current position instead of dragX/dragY which might be unreliable
                    const currentX = this.x;
                    const currentY = this.y;
                    
                    console.log('Sprite current position:', currentX, currentY);
                    console.log('Drag event coords:', dragX, dragY);
                    
                    // Check distance from original position using sprite position
                    const distance = Phaser.Math.Distance.Between(
                        item.originalX, item.originalY, currentX, currentY
                    );
                    
                    // Remove item when dragged outside its occupied cells  
                    const REMOVAL_THRESHOLD = gameState.cellSize * 0.75; // 75% of a cell size
                    
                    // Create a temporary drag state for checking
                    gameState.draggedItem = item;
                    gameState.isDragging = true;
                    
                    // Check if the canvas coordinates are within bounds and find matching gap
                    const gridPos = worldToGrid(currentX, currentY);
                    console.log('Grid position from sprite coords:', gridPos);
                    
                    // Always check if the item is being dropped back in its original position first
                    let directGapCheck = null;
                    
                    // Check if the current sprite position is close to the original position
                    const originalPos = gridToWorld(item.originalGridX, item.originalGridY);
                    const distanceFromOriginal = Phaser.Math.Distance.Between(
                        originalPos.x, originalPos.y, currentX, currentY
                    );
                    
                    console.log('Distance from original grid position:', distanceFromOriginal);
                    
                    // If close to original position, prioritize placing back in original gap
                    if (distanceFromOriginal < gameState.cellSize * 1.5) { // Within 1.5 cells of original
                        console.log('Close to original position, checking original gap');
                        directGapCheck = gameState.gaps.find(gap => {
                            const effectiveWidth = item.isRotated ? item.size.height : item.size.width;
                            const effectiveHeight = item.isRotated ? item.size.width : item.size.height;
                            
                            return gap.x === item.originalGridX && 
                                   gap.y === item.originalGridY &&
                                   gap.size.width === effectiveWidth && 
                                   gap.size.height === effectiveHeight &&
                                   !gap.filled; // Should be unfilled since we cleared it on drag start
                        });
                    }
                    
                    // If not found at original position, try to find gap at the current drag position
                    if (!directGapCheck) {
                        console.log('Not at original position, checking current drag position');
                        directGapCheck = gameState.gaps.find(gap => {
                            if (gap.filled) return false;
                            
                            // Check if grid position is within gap bounds
                            const withinGap = gridPos.x >= gap.x && 
                                             gridPos.x < gap.x + gap.size.width &&
                                             gridPos.y >= gap.y && 
                                             gridPos.y < gap.y + gap.size.height;
                            
                            // Check size compatibility (including rotation)
                            const normalMatch = (item.size.width === gap.size.width && 
                                               item.size.height === gap.size.height);
                            const rotatedMatch = (item.size.width === 3 && item.size.height === 1 &&
                                                gap.size.width === 1 && gap.size.height === 3);
                            
                            return withinGap && (normalMatch || rotatedMatch);
                        });
                    }
                    
                    console.log('Direct gap check result:', directGapCheck);
                    
                    // Use direct gap check if available, otherwise fall back to screen coordinate method
                    let dropResult;
                    if (directGapCheck) {
                        const needsRotation = (item.size.width === 3 && item.size.height === 1 &&
                                             directGapCheck.size.width === 1 && directGapCheck.size.height === 3);
                        dropResult = {
                            valid: true,
                            gridX: directGapCheck.x,
                            gridY: directGapCheck.y,
                            gap: directGapCheck,
                            needsRotation: needsRotation
                        };
                    } else {
                        dropResult = checkDropLocationFromCanvas(currentX, currentY);
                    }
                    
                    console.log('Final drop result:', dropResult);
                    

                    
                    // Set up temporary drag state for drop checking
                    gameState.draggedItem = item;
                    gameState.isDragging = true;
                    
                    console.log('Item original position:', item.originalGridX, item.originalGridY);
                    console.log('Item current position:', item.gridX, item.gridY);
                    console.log('Distance from original:', distance);
                    
                    // Clean up temporary drag state
                    gameState.draggedItem = null;
                    gameState.isDragging = false;
                    
                    if (dropResult.valid) {
                        // Item is being dropped in a valid gap - place it there
                        console.log('Item dropped in valid gap at:', dropResult.gridX, dropResult.gridY);
                        
                        // If it's not the original position, we need to clear the original gap first
                        if (dropResult.gridX !== item.originalGridX || dropResult.gridY !== item.originalGridY) {
                            // Clear original position
                            const originalGap = gameState.gaps.find(g => {
                                const effectiveWidth = item.isRotated ? item.size.height : item.size.width;
                                const effectiveHeight = item.isRotated ? item.size.width : item.size.height;
                                
                                return g.x === item.originalGridX && g.y === item.originalGridY &&
                                       g.size.width === effectiveWidth && g.size.height === effectiveHeight;
                            });
                            
                            if (originalGap) {
                                originalGap.filled = false;
                                originalGap.filledWith = null;
                                if (originalGap.sprite) {
                                    originalGap.sprite.setVisible(true);
                                }
                            }
                        }
                        
                        // Remove current sprite
                        this.disableInteractive();
                        if (this.htmlElement) {
                            this.htmlElement.remove();
                            this.htmlElement = null;
                        }
                        
                        // Place item in new position
                        placeItemOnGrid(item, dropResult.gridX, dropResult.gridY, dropResult.needsRotation);
                        
                        showFeedback('✅ Item placed successfully!', 'success');
                        
                    } else if (distanceFromOriginal > REMOVAL_THRESHOLD) {
                        // Item dragged far away from original position - remove it
                        console.log('Item dragged beyond removal threshold - removing');
                        
                        // Disable dragging to prevent further interaction
                        this.disableInteractive();
                        
                        // Immediately clean up HTML element at current drag position
                        if (this.htmlElement) {
                            console.log('Removing HTML element at drag end position');
                            this.htmlElement.remove();
                            this.htmlElement = null;
                        }
                        
                        // Enhanced return to bank with animation (handles gap state internally)
                        returnItemToBank(item);
                        
                        // Show success feedback with animation
                        showFeedback('✅ Item returned to bank! You can place it again.', 'success');
                        
                    } else {
                        // Return to original position - restore gap state
                        const gap = gameState.gaps.find(g => {
                            const effectiveWidth = item.isRotated ? item.size.height : item.size.width;
                            const effectiveHeight = item.isRotated ? item.size.width : item.size.height;
                            
                            return g.x === item.originalGridX && g.y === item.originalGridY &&
                                   g.size.width === effectiveWidth && g.size.height === effectiveHeight;
                        });
                        
                        if (gap) {
                            gap.filled = true;
                            gap.filledWith = item;
                            if (gap.sprite) {
                                gap.sprite.setVisible(false);
                            }
                        }
                        
                        // Re-add to placed items list
                        if (!gameState.placedItems.includes(item)) {
                            gameState.placedItems.push(item);
                        }
                        
                        // Restore grid positions
                        const effectiveWidth = item.isRotated ? item.size.height : item.size.width;
                        const effectiveHeight = item.isRotated ? item.size.width : item.size.height;
                        for (let dy = 0; dy < effectiveHeight; dy++) {
                            for (let dx = 0; dx < effectiveWidth; dx++) {
                                setGridPosition(item.originalGridX + dx, item.originalGridY + dy, item);
                            }
                        }
                        
                        // Return to original position with smooth animation
                        scene.tweens.add({
                            targets: this,
                            x: item.originalX,
                            y: item.originalY,
                            duration: 300,
                            ease: 'Back.easeOut',
                            onUpdate: () => {
                                // Update HTML element position during animation (relative to canvas)
                                if (this.htmlElement) {
                                    this.htmlElement.style.left = (this.x - spriteWidth/2) + 'px';
                                    this.htmlElement.style.top = (this.y - spriteHeight/2) + 'px';
                                }
                            }
                        });
                        
                        // Reset visual state
                        if (this.htmlElement) {
                            this.htmlElement.style.filter = 'none';
                            this.htmlElement.style.opacity = '1.0';
                            this.htmlElement.style.zIndex = '10';
                        }
                        
                        // Show feedback
                        showFeedback('Item returned to original position. Drag further to remove.', 'info');
                    }
                });
            } else {
                // For pre-placed components, show feedback that they can't be removed
                itemSprite.setInteractive();
                itemSprite.on('pointerdown', function() {
                    showFeedback('❌ Pre-placed components (battery, bulb, wires) cannot be removed', 'error');
                });
                
                itemSprite.on('pointerover', function() {
                    if (this.htmlElement) {
                        this.htmlElement.style.filter = 'brightness(1.2) sepia(0.3) hue-rotate(30deg)';
                    }
                    showFeedback('This is a pre-placed component and cannot be removed', 'info');
                });
                
                itemSprite.on('pointerout', function() {
                    if (this.htmlElement) {
                        this.htmlElement.style.filter = 'none';
                    }
                });
            }
            
            // Group all components
            const spriteGroup = scene.add.group([itemSprite]);
            
            // Store references
            item.sprite = spriteGroup;
            item.mainSprite = itemSprite;
            
            return spriteGroup;
        }

        function returnItemToBank(item) {
            console.log('Returning item to bank:', item.name);
            
            // Store the original grid position before clearing item state
            const originalGridX = item.gridX >= 0 ? item.gridX : item.originalGridX;
            const originalGridY = item.gridY >= 0 ? item.gridY : item.originalGridY;
            
            // Clean up HTML element if it exists - multiple approaches for robustness
            let htmlElementRemoved = false;
            
            if (item.sprite && item.sprite.htmlElement) {
                console.log('Removing HTML element for item:', item.name);
                item.sprite.htmlElement.remove();
                item.sprite.htmlElement = null;
                htmlElementRemoved = true;
            }
            
            // Fallback: search for and remove any HTML elements at the original position
            if (!htmlElementRemoved) {
                const canvas = document.querySelector('canvas');
                const canvasContainer = canvas.parentElement;
                if (canvasContainer) {
                    const itemElements = canvasContainer.querySelectorAll('div[style*="background-image"][style*="assets/items"]');
                    itemElements.forEach(element => {
                        // Check if this element is positioned at the item's location
                        const elementLeft = parseInt(element.style.left);
                        const elementTop = parseInt(element.style.top);
                        const expectedLeft = originalGridX * gameState.cellSize;
                        const expectedTop = originalGridY * gameState.cellSize;
                        
                        if (Math.abs(elementLeft - expectedLeft) < 10 && Math.abs(elementTop - expectedTop) < 10) {
                            console.log('Removing HTML element by position match');
                            element.remove();
                            htmlElementRemoved = true;
                        }
                    });
                }
            }
            
            if (!htmlElementRemoved) {
                console.warn('No HTML element found to remove for item:', item.name);
            }
            
            // Immediately destroy the sprite to prevent visual duplication
            if (item.sprite && item.mainSprite) {
                // Create a temporary sprite for the return animation from the original position
                const originalPos = gridToWorld(originalGridX, originalGridY);
                const tempSprite = scene.add.rectangle(
                    originalPos.x, 
                    originalPos.y, 
                    40, 20, 
                    item.color
                );
                tempSprite.setStrokeStyle(2, 0x4CAF50);
                tempSprite.setDepth(2000);
                
                // Immediately hide and destroy all sprite components
                try {
                    // First, make all sprites invisible immediately
                    if (item.sprite.children && item.sprite.children.entries) {
                        item.sprite.children.entries.forEach(child => {
                            if (child) {
                                child.setVisible(false);
                                child.setActive(false);
                            }
                        });
                    }
                    
                    // Also hide the main sprite directly if accessible
                    if (item.mainSprite) {
                        item.mainSprite.setVisible(false);
                        item.mainSprite.setActive(false);
                    }
                    
                    // Clear the group
                    item.sprite.clear(true, true); // Remove and destroy all children
                    
                    // Destroy the group itself
                    item.sprite.destroy();
                    
                } catch (error) {
                    console.warn('Error destroying sprite:', error);
                    // Fallback: try to destroy the group directly
                    if (item.sprite && item.sprite.destroy) {
                        item.sprite.destroy();
                    }
                }
                
                // Clear references
                item.sprite = null;
                item.mainSprite = null;
                
                // Animate the temporary sprite moving to item bank area
                const itemBankElement = item.htmlElement;
                const itemBankRect = itemBankElement ? itemBankElement.getBoundingClientRect() : null;
                const canvas = document.querySelector('canvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                let targetX = 50; // Default fallback position
                let targetY = 50;
                
                if (itemBankRect && canvasRect) {
                    // Calculate relative position within canvas
                    targetX = itemBankRect.left - canvasRect.left + itemBankRect.width / 2;
                    targetY = itemBankRect.top - canvasRect.top + itemBankRect.height / 2;
                }
                
                // Animate return to bank
                scene.tweens.add({
                    targets: tempSprite,
                    x: targetX,
                    y: targetY,
                    scaleX: 0.5,
                    scaleY: 0.5,
                    alpha: 0.8,
                    duration: 500,
                    ease: 'Power2',
                    onComplete: () => {
                        tempSprite.destroy();
                        
                        // Flash the HTML element to show it's back
                        if (itemBankElement) {
                            itemBankElement.style.animation = 'pulse 0.5s ease-in-out';
                            setTimeout(() => {
                                itemBankElement.style.animation = '';
                            }, 500);
                        }
                    }
                });
            }
            
            // Clear grid position
            if (originalGridX >= 0 && originalGridY >= 0) {
                setGridPosition(originalGridX, originalGridY, null);
            }
            
            // Handle gap state - find gap that contains this position (for multi-cell items)
            const gap = gameState.gaps.find(g => {
                const gapSize = g.size || { width: 1, height: 1 };
                return originalGridX >= g.x && 
                       originalGridX < g.x + gapSize.width &&
                       originalGridY >= g.y && 
                       originalGridY < g.y + gapSize.height;
            });
            
            if (gap) {
                gap.filled = false;
                gap.filledWith = null;
                if (gap.sprite) {
                    gap.sprite.setVisible(true);
                }
                
                // Clear all grid positions for this gap
                const gapSize = gap.size || { width: 1, height: 1 };
                for (let dy = 0; dy < gapSize.height; dy++) {
                    for (let dx = 0; dx < gapSize.width; dx++) {
                        setGridPosition(gap.x + dx, gap.y + dy, 'gap');
                    }
                }
                
                console.log('Gap indicator restored for gap at:', gap.x, gap.y, 'size:', gapSize);
            } else {
                console.log('No gap found containing position:', originalGridX, originalGridY);
            }
            
            // Ensure all drop zone highlights are cleared (removes green highlighting)
            highlightDropZones(false);
            
            // Reset item state
            item.inBank = true;
            item.placed = false;
            item.gridX = -1;
            item.gridY = -1;
            item.isDragging = false;
            item.isRotated = false; // Reset rotation state
            
            // Clear any stored positions
            item.originalX = undefined;
            item.originalY = undefined;
            item.originalGridX = undefined;
            item.originalGridY = undefined;
            
            // Clean up any removal hints
            if (item.removalHint) {
                item.removalHint.destroy();
                item.removalHint = null;
            }
            
            // Show HTML element again with enhanced visual feedback
            if (item.htmlElement) {
                item.htmlElement.style.display = 'flex';
                item.htmlElement.style.cursor = 'grab';
                item.htmlElement.style.opacity = '1';
                item.htmlElement.style.transform = 'scale(1)';
                
                // Add a brief highlight effect
                item.htmlElement.style.boxShadow = '0 0 10px #4CAF50';
                setTimeout(() => {
                    item.htmlElement.style.boxShadow = '';
                }, 1000);
            }
            
            // Remove from placed items array
            const itemIndex = gameState.placedItems.indexOf(item);
            if (itemIndex > -1) {
                gameState.placedItems.splice(itemIndex, 1);
                console.log('Removed item from placedItems array');
            }
            
            // Reset circuit state immediately when item is removed to clear short circuit indicators
            gameState.circuitState = 'incomplete';
            
            // Turn off bulb(s) immediately to prevent yellow lines from being redrawn
            if (gameState.bulb) {
                gameState.bulb.isLit = false;
                if (gameState.bulb.sprite) {
                    gameState.bulb.sprite.setTint(0xffffff); // Remove yellow tint
                }
            }
            if (gameState.bulbs) {
                gameState.bulbs.forEach(bulb => {
                    bulb.isLit = false;
                    if (bulb.sprite) {
                        bulb.sprite.setTint(0xffffff); // Remove yellow tint
                    }
                });
            }
            
            // Stop current flow animation since circuit is now incomplete
            visualizeCurrentFlow(false);
            
            // Clear connection graphics to remove yellow success lines
            clearConnectionGraphics();
            
            // Update wire connections after clearing circuit state
            updateWireConnections();
            
            // Re-evaluate circuit to turn off bulb if circuit is now broken
            evaluateCircuit();
            
            console.log('Item successfully returned to bank');
        }

        function placeItemOnGrid(item, gridX, gridY, needsRotation = false) {
            
            // Hide HTML element
            if (item.htmlElement) {
                item.htmlElement.style.display = 'none';
            }
            
            // Store rotation state
            item.isRotated = needsRotation;
            
            // Create game sprite with rotation
            createGameSprite(item, gridX, gridY, needsRotation);
            
            // Update item state
            item.inBank = false;
            item.placed = true;
            item.gridX = gridX;
            item.gridY = gridY;
            
            // Update grid - mark all cells occupied by this item (considering rotation)
            const effectiveWidth = needsRotation ? item.size.height : item.size.width;
            const effectiveHeight = needsRotation ? item.size.width : item.size.height;
            
            for (let dy = 0; dy < effectiveHeight; dy++) {
                for (let dx = 0; dx < effectiveWidth; dx++) {
                    setGridPosition(gridX + dx, gridY + dy, item);
                }
            }
            
            // Check if this fills a gap (considering rotation)
            const gap = gameState.gaps.find(g => {
                if (needsRotation) {
                    return g.x === gridX && g.y === gridY &&
                           g.size.width === item.size.height &&
                           g.size.height === item.size.width;
                } else {
                    return g.x === gridX && g.y === gridY &&
                           g.size.width === item.size.width &&
                           g.size.height === item.size.height;
                }
            });
            
            if (gap) {
                gap.filled = true;
                gap.filledWith = item;
                if (gap.sprite) {
                    gap.sprite.setVisible(false);
                }
                
                // Show success feedback for correct placement
                const rotationText = needsRotation ? ' (rotated)' : '';
                showFeedback(`✅ ${item.name} placed${rotationText}!`, 'success');
            }
            
            // Add to placed items
            gameState.placedItems.push(item);
            
            // Update wire connections when item is placed
            updateWireConnections();
        }

        function setupInputHandling() {
            // Set up drag and drop for item bank items
            setupItemBankDragDrop();
            
            // Set up canvas drop zone
            setupCanvasDropZone();
            
            // Set up placed item interaction
            setupPlacedItemInteraction();
            
            // Set up window resize handler to keep HTML elements positioned correctly
            window.addEventListener('resize', updateAllHtmlPositions);
        }
        
        function updateAllHtmlPositions() {
            // Update positions of all placed items
            gameState.placedItems.forEach(item => {
                if (item.sprite && item.sprite.updateHtmlPosition) {
                    item.sprite.updateHtmlPosition();
                }
            });
        }
        

        
        // Add a more frequent position update to handle any timing issues
        function startPositionUpdater() {
            setInterval(() => {
                updateAllHtmlPositions();
            }, 100); // Update every 100ms to catch any positioning issues
        }

        function setupItemBankDragDrop() {
            gameState.itemBank.forEach(item => {
                if (item.htmlElement) {
                    item.htmlElement.addEventListener('mousedown', function(e) {
                        if (item.inBank) {
                            startDragging(item, e);
                        }
                    });
                }
            });
        }

        function startDragging(item, e) {
            e.preventDefault();
            
            gameState.draggedItem = item;
            gameState.isDragging = true;
            
            // Create drag preview
            createDragPreview(item, e.clientX, e.clientY);
            
            // Change cursor
            document.body.style.cursor = 'grabbing';
            
            // Add global mouse move and up listeners
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
            
            // Highlight valid drop zones
            highlightDropZones(true);
        }

        function createDragPreview(item, x, y) {
            // Calculate preview size based on item's actual grid size - maintain original size
            const cellSize = gameState.cellSize;
            const previewWidth = cellSize * item.size.width; // Full size to match original item
            const previewHeight = cellSize * item.size.height;
            
            const preview = document.createElement('div');
            preview.id = 'drag-preview';
            preview.style.cssText = `
                position: fixed;
                left: ${x - previewWidth/2}px;
                top: ${y - previewHeight/2}px;
                width: ${previewWidth}px;
                height: ${previewHeight}px;
                background-image: url('assets/items/${item.imageKey}.png');
                background-size: contain;
                background-repeat: no-repeat;
                background-position: center;
                border: 2px solid #333;
                border-radius: 5px;
                opacity: 0.8;
                pointer-events: none;
                z-index: 1000;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            `;
            
            // No labels needed - just the image background
            
            document.body.appendChild(preview);
        }

        function handleDragMove(e) {
            if (!gameState.isDragging || !gameState.draggedItem) return;
            
            // Check if over valid drop zone and if rotation is needed
            const dropResult = checkDropLocation(e.clientX, e.clientY);
            
            // Update drag preview position and rotation
            const preview = document.getElementById('drag-preview');
            if (preview) {
                const previewWidth = parseFloat(preview.style.width);
                const previewHeight = parseFloat(preview.style.height);
                preview.style.left = (e.clientX - previewWidth/2) + 'px';
                preview.style.top = (e.clientY - previewHeight/2) + 'px';
                
                // Apply rotation if needed for vertical gaps
                if (dropResult.valid && dropResult.needsRotation) {
                    preview.style.transform = 'rotate(90deg)';
                    preview.style.opacity = '0.8';
                } else {
                    preview.style.transform = 'rotate(0deg)';
                    preview.style.opacity = '0.7';
                }
            }
            
            // Update drop zone highlighting
            updateDropZoneHighlight(e.clientX, e.clientY);
        }

        function handleDragEnd(e) {
            if (!gameState.isDragging || !gameState.draggedItem) return;
            
            // Remove drag preview
            const preview = document.getElementById('drag-preview');
            if (preview) {
                preview.remove();
            }
            
            // Check if dropped on valid location
            const dropResult = checkDropLocation(e.clientX, e.clientY);
            
            if (dropResult.valid) {
                // Place item on grid with rotation if needed
                placeItemOnGrid(gameState.draggedItem, dropResult.gridX, dropResult.gridY, dropResult.needsRotation);
            } else {
                // Return to bank (item stays in bank)
                console.log('Invalid drop location - item stays in bank');
            }
            
            // Clean up
            cleanupDrag();
        }

        function cleanupDrag() {
            // Remove event listeners
            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
            
            // Reset cursor
            document.body.style.cursor = 'default';
            
            // Hide drop zone highlights
            highlightDropZones(false);
            
            // Reset drag state
            gameState.draggedItem = null;
            gameState.isDragging = false;
        }

        function checkDropLocationFromCanvas(canvasX, canvasY) {
            console.log('checkDropLocationFromCanvas called with:', canvasX, canvasY);
            
            // Check if coordinates are within canvas bounds
            if (canvasX < 0 || canvasX > canvasSize || canvasY < 0 || canvasY > canvasSize) {
                console.log('Outside canvas bounds');
                return { valid: false };
            }
            
            // Convert to grid coordinates
            const gridPos = worldToGrid(canvasX, canvasY);
            console.log('Grid position:', gridPos);
            
            return checkDropAtGridPosition(gridPos);
        }

        function checkDropLocation(clientX, clientY) {
            // Get canvas bounds
            const canvas = document.querySelector('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            
            console.log('checkDropLocation called with:', clientX, clientY);
            console.log('Canvas rect:', canvasRect);
            
            // Check if over canvas
            if (clientX < canvasRect.left || clientX > canvasRect.right ||
                clientY < canvasRect.top || clientY > canvasRect.bottom) {
                console.log('Outside canvas bounds');
                return { valid: false };
            }
            
            // Convert to canvas coordinates
            const canvasX = clientX - canvasRect.left;
            const canvasY = clientY - canvasRect.top;
            console.log('Canvas coordinates:', canvasX, canvasY);
            
            // Convert to grid coordinates
            const gridPos = worldToGrid(canvasX, canvasY);
            console.log('Grid position:', gridPos);
            
            return checkDropAtGridPosition(gridPos);
        }

        function checkDropAtGridPosition(gridPos) {
            
            // Get the dragged item's size
            const draggedItem = gameState.draggedItem;
            if (!draggedItem || !draggedItem.size) {
                console.log('No dragged item or size');
                return { valid: false };
            }
            console.log('Dragged item:', draggedItem.name, 'size:', draggedItem.size);
            
            console.log('Available gaps:', gameState.gaps.map(g => ({
                x: g.x, y: g.y, 
                size: g.size, 
                filled: g.filled,
                filledWith: g.filledWith ? g.filledWith.name : null
            })));
            
            // Check if there's a gap that matches the item size (normal orientation)
            let matchingGap = gameState.gaps.find(gap => {
                console.log('Checking gap:', gap.x, gap.y, 'filled:', gap.filled, 'size:', gap.size);
                if (gap.filled || 
                    gap.size.width !== draggedItem.size.width ||
                    gap.size.height !== draggedItem.size.height) {
                    console.log('Gap rejected - filled or size mismatch');
                    return false;
                }
                
                // Check if the drop position is anywhere within the gap area
                const withinGap = gridPos.x >= gap.x && 
                                 gridPos.x < gap.x + gap.size.width &&
                                 gridPos.y >= gap.y && 
                                 gridPos.y < gap.y + gap.size.height;
                
                console.log('Within gap check:', withinGap);
                return withinGap;
            });
            
            let needsRotation = false;
            
            // If no normal match, check for rotated match (for 3-cell items in vertical gaps)
            if (!matchingGap && draggedItem.size.width === 3 && draggedItem.size.height === 1) {
                matchingGap = gameState.gaps.find(gap => {
                    if (gap.filled || 
                        gap.size.width !== 1 || gap.size.height !== 3) {
                        return false;
                    }
                    
                    // Check if the drop position is anywhere within the gap area
                    const withinGap = gridPos.x >= gap.x && 
                                     gridPos.x < gap.x + gap.size.width &&
                                     gridPos.y >= gap.y && 
                                     gridPos.y < gap.y + gap.size.height;
                    
                    return withinGap;
                });
                
                if (matchingGap) {
                    needsRotation = true;
                }
            }
            
            if (matchingGap) {
                // Check if all cells that the item would occupy are empty
                let allCellsEmpty = true;
                const checkWidth = needsRotation ? draggedItem.size.height : draggedItem.size.width;
                const checkHeight = needsRotation ? draggedItem.size.width : draggedItem.size.height;
                
                for (let dy = 0; dy < checkHeight; dy++) {
                    for (let dx = 0; dx < checkWidth; dx++) {
                        if (!isGridPositionEmpty(matchingGap.x + dx, matchingGap.y + dy)) {
                            allCellsEmpty = false;
                            break;
                        }
                    }
                    if (!allCellsEmpty) break;
                }
                
                if (allCellsEmpty) {
                    return { 
                        valid: true, 
                        gridX: matchingGap.x, 
                        gridY: matchingGap.y, 
                        gap: matchingGap,
                        needsRotation: needsRotation
                    };
                }
            }
            
            return { valid: false };
        }

        function highlightDropZones(show) {
            const draggedItem = gameState.draggedItem;
            
            gameState.gaps.forEach(gap => {
                if (!gap.filled && gap.sprite) {
                    const graphics = gap.sprite.getChildren()[0]; // Get the graphics object
                    
                    // Calculate gap size based on the gap's size property
                    const gapSize = gap.size || { width: 1, height: 1 };
                    const cellSize = gameState.cellSize;
                    
                    // Use same positioning logic as markGaps to maintain consistent size
                    const x = gap.x * cellSize;
                    const y = gap.y * cellSize;
                    const width = cellSize * gapSize.width;
                    const height = cellSize * gapSize.height;
                    
                    graphics.clear();
                    
                    // Check if this gap is compatible with the dragged item (including rotation)
                    let isCompatible = false;
                    if (!draggedItem) {
                        isCompatible = false;
                    } else {
                        // Check normal orientation
                        const normalMatch = (draggedItem.size.width === gapSize.width && 
                                           draggedItem.size.height === gapSize.height);
                        
                        // Check rotated orientation (for 3-cell items in vertical gaps)
                        const rotatedMatch = (draggedItem.size.width === 3 && draggedItem.size.height === 1 &&
                                            gapSize.width === 1 && gapSize.height === 3);
                        
                        isCompatible = normalMatch || rotatedMatch;
                    }
                    
                    if (show && isCompatible) {
                        // Show solid green highlight for compatible gaps
                        graphics.lineStyle(3, 0x4CAF50, 1.0);
                        graphics.strokeRect(x, y, width, height);
                    } else if (show && !isCompatible) {
                        // Show orange highlight for incompatible gaps
                        graphics.lineStyle(2, 0xFF9800, 0.6);
                        graphics.strokeRect(x, y, width, height);
                    } else {
                        // Show dashed red outline (default state) - use same logic as markGaps
                        graphics.lineStyle(2, 0xFF6B6B, 0.8);
                        
                        const dashLength = 5;
                        const gapLength = 5;
                        
                        // Top line
                        for (let i = 0; i < width; i += dashLength + gapLength) {
                            const lineWidth = Math.min(dashLength, width - i);
                            graphics.moveTo(x + i, y);
                            graphics.lineTo(x + i + lineWidth, y);
                        }
                        
                        // Bottom line
                        for (let i = 0; i < width; i += dashLength + gapLength) {
                            const lineWidth = Math.min(dashLength, width - i);
                            graphics.moveTo(x + i, y + height);
                            graphics.lineTo(x + i + lineWidth, y + height);
                        }
                        
                        // Left line
                        for (let i = 0; i < height; i += dashLength + gapLength) {
                            const lineHeight = Math.min(dashLength, height - i);
                            graphics.moveTo(x, y + i);
                            graphics.lineTo(x, y + i + lineHeight);
                        }
                        
                        // Right line
                        for (let i = 0; i < height; i += dashLength + gapLength) {
                            const lineHeight = Math.min(dashLength, height - i);
                            graphics.moveTo(x + width, y + i);
                            graphics.lineTo(x + width, y + i + lineHeight);
                        }
                        
                        graphics.strokePath();
                    }
                }
            });
        }

        function updateDropZoneHighlight(clientX, clientY) {
            const dropResult = checkDropLocation(clientX, clientY);
            
            // Update cursor based on drop validity
            if (dropResult.valid) {
                document.body.style.cursor = 'copy';
            } else {
                document.body.style.cursor = 'not-allowed';
            }
        }

        function setupCanvasDropZone() {
            const canvas = document.querySelector('canvas');
            
            canvas.addEventListener('dragover', function(e) {
                e.preventDefault();
            });
            
            canvas.addEventListener('drop', function(e) {
                e.preventDefault();
                // Drag and drop is handled by mouse events
            });
        }

        function setupPlacedItemInteraction() {
            // Set up click handling for placed items (for removal)
            scene.input.on('gameobjectdown', function(pointer, gameObject) {
                // Find the item that was clicked
                const clickedItem = gameState.itemBank.find(item => 
                    item.mainSprite === gameObject
                );
                
                if (clickedItem && clickedItem.placed && !clickedItem.isDragging) {
                    // Check if it's a pre-placed component
                    if (isPreplacedComponent(clickedItem.gridX, clickedItem.gridY)) {
                        showFeedback('❌ Pre-placed components cannot be removed', 'error');
                        return;
                    }
                    
                    // Only handle click removal if not dragging and not pre-placed
                    // Return item to bank (handles gap state internally)
                    returnItemToBank(clickedItem);
                    
                    // Show enhanced feedback
                    showFeedback('✅ Item returned to bank! You can place it again or try different materials.', 'success');
                }
            });
        }

        // Utility functions
        function gridToWorld(gridX, gridY) {
            return {
                x: gridX * gameState.cellSize + gameState.cellSize / 2,
                y: gridY * gameState.cellSize + gameState.cellSize / 2
            };
        }

        function isPreplacedComponent(gridX, gridY) {
            // Check if position contains battery, bulb, or pre-placed wire
            const gridContent = getGridPosition(gridX, gridY);
            return gridContent === 'battery' || gridContent === 'bulb' || gridContent === 'wire';
        }

        function worldToGrid(worldX, worldY) {
            return {
                x: Math.floor(worldX / gameState.cellSize),
                y: Math.floor(worldY / gameState.cellSize)
            };
        }

        function isValidGridPosition(gridX, gridY) {
            return gridX >= 0 && gridX < gameState.gridWidth && 
                   gridY >= 0 && gridY < gameState.gridHeight;
        }

        function isGridPositionEmpty(gridX, gridY) {
            if (!isValidGridPosition(gridX, gridY)) return false;
            const gridContent = gameState.grid[gridY][gridX];
            // Allow placement on empty positions or gap positions
            return gridContent === null || gridContent === 'gap';
        }

        function setGridPosition(gridX, gridY, item) {
            if (isValidGridPosition(gridX, gridY)) {
                gameState.grid[gridY][gridX] = item;
            }
        }

        function getGridPosition(gridX, gridY) {
            if (isValidGridPosition(gridX, gridY)) {
                return gameState.grid[gridY][gridX];
            }
            return null;
        }

        // Circuit evaluation functions
        function evaluateCircuit() {
            console.log('=== EVALUATING CIRCUIT ===');
            console.log('Current layout:', gameState.currentLayout);
            
            // Check if all gaps are filled before testing
            const unfilledGaps = gameState.gaps.filter(gap => !gap.filled);
            if (unfilledGaps.length > 0) {
                console.log('Not all gaps are filled:', unfilledGaps.length, 'remaining');
                showFeedback(`Please fill all ${unfilledGaps.length} missing part${unfilledGaps.length > 1 ? 's' : ''} before testing the circuit!`, 'error');
                updateLightBulb(false);
                return false;
            }
            
            // First check for short circuit (Stage 2 only)
            console.log('Checking for short circuit...');
            const shortCircuitDetected = detectShortCircuit();
            console.log('Short circuit detection result:', shortCircuitDetected);
            
            if (shortCircuitDetected) {
                console.log('SHORT CIRCUIT DETECTED! Showing warning...');
                gameState.circuitState = 'short_circuit';
                updateLightBulb(false); // Keep bulb off
                
                // Update wire connections to show the red short circuit path
                updateWireConnections();
                
                // Show red current flow animation
                visualizeCurrentFlow(true, true); // true for flow, true for short circuit (red)
                
                // Show short circuit warning modal after animation
                setTimeout(() => {
                    showShortCircuitModal();
                }, 1500);
                
                return false; // Circuit is not working properly
            }
            
            // Debug: Show current state of gaps
            console.log('Gap states:');
            gameState.gaps.forEach((gap, index) => {
                const item = getGridPosition(gap.x, gap.y);
                console.log(`Gap ${index} at (${gap.x},${gap.y}): filled=${gap.filled}, item=`, item);
            });
            
            // Find path from battery positive to battery negative through the bulb
            const hasCompletePath = findCircuitPath();
            
            console.log('Circuit evaluation result:', hasCompletePath);
            
            // Additional check for Stage 2: if there's an insulator in the 1-slot gap, 
            // the circuit cannot be complete even if other paths exist
            if (gameState.currentLayout === 'second' && hasCompletePath) {
                const oneSlotGap = gameState.gaps.find(gap => gap.x === 9 && gap.y === 10);
                if (oneSlotGap) {
                    const oneSlotItem = getGridPosition(oneSlotGap.x, oneSlotGap.y);
                    const isInsulator = oneSlotItem && oneSlotItem.conductive === false;
                    console.log('1-slot gap item:', oneSlotItem, 'is insulator:', isInsulator);
                    
                    if (isInsulator) {
                        console.log('Insulator in 1-slot gap blocks circuit completion');
                        updateLightBulb(false);
                        gameState.circuitState = 'incomplete';
                        return false;
                    }
                }
            }
            
            if (hasCompletePath) {
                gameState.circuitState = 'complete';
            } else {
                gameState.circuitState = 'incomplete';
            }
            
            // Update light bulb(s) based on stage
            if (gameState.currentLayout === 'third') {
                // Stage 3: Update both bulbs
                updateDualBulbs(hasCompletePath);
            } else if (gameState.currentLayout === 'fourth') {
                // Stage 4: Bulbs are already updated in findFourthCircuitPath
                // No additional update needed here
            } else if (gameState.currentLayout === 'fifth') {
                // Stage 5: Bulbs are already updated in findFifthCircuitPath
                // No additional update needed here
            } else {
                // Stage 1 & 2: Update single bulb
                updateLightBulb(hasCompletePath);
            }
            
            // Update wire connections to show the complete circuit path
            updateWireConnections();
            
            return hasCompletePath;
        }

        function findCircuitPath() {
            console.log('Checking circuit path...');
            console.log('Current layout:', gameState.currentLayout);
            console.log('Battery at:', gameState.battery.x, gameState.battery.y, 'size:', gameState.battery.width + 'x' + gameState.battery.height);
            
            if (gameState.bulb) {
                console.log('Single bulb at:', gameState.bulb.x, gameState.bulb.y, 'size:', gameState.bulb.width + 'x' + gameState.bulb.height);
            } else if (gameState.bulbs) {
                console.log('Dual bulbs:');
                gameState.bulbs.forEach((bulb, index) => {
                    console.log(`  Bulb ${index + 1} at:`, bulb.x, bulb.y, 'size:', bulb.width + 'x' + bulb.height);
                });
            }
            
            if (gameState.currentLayout === 'second') {
                // Second circuit layout with T-junctions
                return findSecondCircuitPath();
            } else if (gameState.currentLayout === 'third') {
                // Third circuit layout with series dual bulbs
                return findThirdCircuitPath();
            } else if (gameState.currentLayout === 'fourth') {
                // Fourth circuit layout with parallel dual bulbs
                return findFourthCircuitPath();
            } else if (gameState.currentLayout === 'fifth') {
                // Fifth circuit layout with series-parallel dual bulbs
                return findFifthCircuitPath();
            } else {
                // First circuit layout (original)
                return findFirstCircuitPath();
            }
        }
        
        function findFirstCircuitPath() {
            // Original two-wire circuit: positive terminal -> top wire -> bulb -> bottom wire -> negative terminal
            const topWireY = 4;        // Top wire row
            const bottomWireY = 10;    // Bottom wire row
            
            // Check path from battery L-wire to bulb L-wire via top wire (row 4)
            const topPathComplete = checkPathSegment(3, topWireY, 11, topWireY);
            console.log('Top path (battery to bulb via top wire):', topPathComplete);
            
            // Check path from bulb L-wire to battery L-wire via bottom wire (row 10)
            const bottomPathComplete = checkPathSegment(11, bottomWireY, 3, bottomWireY);
            console.log('Bottom path (bulb to battery via bottom wire):', bottomPathComplete);
            
            // Check if vertical wire connections are conductive
            const batteryVWiresConnected = isConductive(2, 5) && isConductive(2, 9);
            const bulbVWiresConnected = isConductive(12, 5) && isConductive(12, 9);
            // Check if L-shaped wire connections are conductive
            const batteryLWiresConnected = isConductive(2, 4) && isConductive(2, 10);
            const bulbLWiresConnected = isConductive(12, 4) && isConductive(12, 10);
            console.log('Battery vertical wires connected:', batteryVWiresConnected);
            console.log('Battery L-wires connected:', batteryLWiresConnected);
            console.log('Bulb vertical wires connected:', bulbVWiresConnected);
            console.log('Bulb L-wires connected:', bulbLWiresConnected);
            
            const circuitComplete = topPathComplete && bottomPathComplete && batteryVWiresConnected && batteryLWiresConnected && bulbVWiresConnected && bulbLWiresConnected;
            console.log('First circuit complete:', circuitComplete);
            
            return circuitComplete;
        }
        
        function findSecondCircuitPath() {
            // Second circuit layout with T-junctions and multiple paths
            // Battery position: (1, 6-8), Bulb position: (11-13, 6-8)
            
            // Check if battery connections are conductive
            const batteryConnected = isConductive(1, 4) && isConductive(1, 5) && isConductive(1, 9) && isConductive(1, 10);
            console.log('Battery connections:', batteryConnected);
            
            // Check if bulb connections are conductive  
            const bulbConnected = isConductive(12, 4) && isConductive(12, 5) && isConductive(12, 9) && isConductive(12, 10);
            console.log('Bulb connections:', bulbConnected);
            
            if (!batteryConnected || !bulbConnected) {
                console.log('Battery or bulb not properly connected');
                return false;
            }
            
            // Check multiple possible paths using breadth-first search
            const hasPath = findPathBFS();
            console.log('Second circuit complete:', hasPath);
            
            return hasPath;
        }
        
        function findPathBFS() {
            // Use breadth-first search to find any complete path from battery to bulb
            const startPositions = [
                { x: 1, y: 4 }, // Battery top connection
                { x: 1, y: 10 } // Battery bottom connection
            ];
            
            const endPositions = [
                { x: 12, y: 4 }, // Bulb top connection
                { x: 12, y: 5 }, // Bulb side connections
                { x: 12, y: 9 },
                { x: 12, y: 10 } // Bulb bottom connection
            ];
            
            for (const start of startPositions) {
                for (const end of endPositions) {
                    if (findPathBetweenPoints(start, end)) {
                        console.log(`Found path from (${start.x},${start.y}) to (${end.x},${end.y})`);
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        function findPathBetweenPoints(start, end) {
            const queue = [start];
            const visited = new Set();
            visited.add(`${start.x},${start.y}`);
            
            const directions = [
                { dx: -1, dy: 0 }, // left
                { dx: 1, dy: 0 },  // right  
                { dx: 0, dy: -1 }, // up
                { dx: 0, dy: 1 }   // down
            ];
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Check if we reached the end
                if (current.x === end.x && current.y === end.y) {
                    return true;
                }
                
                // Explore adjacent positions
                for (const dir of directions) {
                    const nextX = current.x + dir.dx;
                    const nextY = current.y + dir.dy;
                    const key = `${nextX},${nextY}`;
                    
                    // Check bounds
                    if (nextX < 0 || nextX >= gameState.gridWidth || 
                        nextY < 0 || nextY >= gameState.gridHeight) {
                        continue;
                    }
                    
                    // Skip if already visited
                    if (visited.has(key)) {
                        continue;
                    }
                    
                    // Check if position is conductive
                    if (isConductive(nextX, nextY)) {
                        visited.add(key);
                        queue.push({ x: nextX, y: nextY });
                    }
                }
            }
            
            return false;
        }
        
        function checkPathSegment(startX, startY, endX, endY) {
            // Check if there's a continuous conductive path between two points
            console.log(`Checking path from (${startX},${startY}) to (${endX},${endY})`);
            
            // For horizontal wire segments, check each position along the path
            if (startY === endY) {
                // Horizontal path - check each position from start to end
                const minX = Math.min(startX, endX);
                const maxX = Math.max(startX, endX);
                
                for (let x = minX; x <= maxX; x++) {
                    if (!isConductive(x, startY)) {
                        console.log(`Path blocked at (${x},${startY})`);
                        return false;
                    }
                }
                console.log(`Complete horizontal path found from (${startX},${startY}) to (${endX},${endY})`);
                return true;
            }
            
            // For other paths, use breadth-first search
            const queue = [{x: startX, y: startY}];
            const visited = new Set();
            
            while (queue.length > 0) {
                const current = queue.shift();
                const key = `${current.x},${current.y}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                
                // Check if we reached the destination
                if (current.x === endX && current.y === endY) {
                    console.log(`Path found from (${startX},${startY}) to (${endX},${endY})`);
                    return true;
                }
                
                // Check adjacent positions
                const adjacent = [
                    {x: current.x + 1, y: current.y},
                    {x: current.x - 1, y: current.y},
                    {x: current.x, y: current.y + 1},
                    {x: current.x, y: current.y - 1}
                ];
                
                adjacent.forEach(pos => {
                    const adjKey = `${pos.x},${pos.y}`;
                    if (!visited.has(adjKey) && isConductive(pos.x, pos.y)) {
                        queue.push(pos);
                    }
                });
            }
            
            console.log(`No path found from (${startX},${startY}) to (${endX},${endY})`);
            return false;
        }

        function isConductive(x, y) {
            // Check bounds
            if (!isValidGridPosition(x, y)) {
                return false;
            }
            
            const gridItem = getGridPosition(x, y);
            
            // Empty positions are not conductive
            if (gridItem === null) {
                return false;
            }
            
            // Check different component types
            if (gridItem === 'battery' || gridItem === 'bulb' || gridItem === 'wire') {
                return true;
            }
            
            // Check placed items
            if (typeof gridItem === 'object' && gridItem.conductive !== undefined) {
                return gridItem.conductive;
            }
            
            // Default to non-conductive
            return false;
        }

        function updateDualBulbs(isLit) {
            // Update both bulbs in Stage 3
            if (gameState.bulbs) {
                gameState.bulbs.forEach(bulb => {
                    bulb.isLit = isLit;
                    if (bulb.bulbSprite) {
                        // Update sprite frame (0 = off, 1 = on)
                        bulb.bulbSprite.setFrame(isLit ? 1 : 0);
                    }
                });
            }
        }

        function findThirdCircuitPath() {
            // Stage 3: Series circuit with dual bulbs
            // All gaps must be filled with conductors for the circuit to work
            console.log('Checking Stage 3 series circuit path...');
            
            // Check if all gaps are filled with conductors
            const allGapsConductors = gameState.gaps.every(gap => {
                const item = getGridPosition(gap.x, gap.y);
                return item && item.conductive === true;
            });
            
            if (!allGapsConductors) {
                console.log('Not all gaps filled with conductors in series circuit');
                return false;
            }
            
            // In a series circuit, if all gaps are filled with conductors,
            // the circuit is complete (simplified logic for educational purposes)
            console.log('Series circuit complete - all gaps filled with conductors');
            return true;
        }

        function findFourthCircuitPath() {
            // Stage 4: Parallel circuit with dual bulbs
            // At least one complete path must exist for at least one bulb to light up
            console.log('Checking Stage 4 parallel circuit path...');
            
            // Check if all gaps are filled with conductors for a complete circuit
            const allGapsConductors = gameState.gaps.every(gap => {
                // For multi-cell gaps, check all cells in the gap
                for (let dx = 0; dx < gap.size.width; dx++) {
                    for (let dy = 0; dy < gap.size.height; dy++) {
                        const item = getGridPosition(gap.x + dx, gap.y + dy);
                        if (!item || !item.conductive) {
                            return false;
                        }
                    }
                }
                return true;
            });
            
            if (allGapsConductors) {
                console.log('Parallel circuit complete - all gaps filled with conductors, both bulbs should light');
                // Both bulbs light up when all gaps are filled
                if (gameState.bulbs) {
                    gameState.bulbs.forEach(bulb => {
                        bulb.isLit = true;
                        if (bulb.bulbSprite && bulb.bulbSprite.setFrame) {
                            bulb.bulbSprite.setFrame(1); // Frame 1 = lit bulb
                        }
                    });
                }
                return true;
            }
            
            // Check if the 2-cell gap (3,4)-(4,4) is filled with conductors
            // This should light up the left bulb regardless of what's in other gaps
            const gap2Cell = gameState.gaps.find(gap => gap.x === 3 && gap.y === 4);
            let leftBulbShouldLight = false;
            
            if (gap2Cell) {
                const item1 = getGridPosition(3, 4);
                const item2 = getGridPosition(4, 4);
                const gap2CellFilled = item1 && item1.conductive && item2 && item2.conductive;
                
                if (gap2CellFilled) {
                    console.log('Left bulb path complete - 2-cell gap filled with conductors');
                    leftBulbShouldLight = true;
                }
            }
            
            // Check if the right bulb path is complete (3-cell gap + 1-cell gap both filled)
            const gap3Cell = gameState.gaps.find(gap => gap.x === 8 && gap.y === 4);
            const gap1Cell = gameState.gaps.find(gap => gap.x === 9 && gap.y === 10);
            let rightBulbShouldLight = false;
            
            if (gap3Cell && gap1Cell) {
                // Check 3-cell gap (8,4)-(10,4)
                const gap3CellFilled = isConductive(8, 4) && isConductive(9, 4) && isConductive(10, 4);
                // Check 1-cell gap (9,10)
                const gap1CellFilled = isConductive(9, 10);
                
                if (gap3CellFilled && gap1CellFilled) {
                    console.log('Right bulb path complete - 3-cell and 1-cell gaps filled with conductors');
                    rightBulbShouldLight = true;
                }
            }
            
            // Update bulb states
            if (gameState.bulbs) {
                // Left bulb (first bulb)
                gameState.bulbs[0].isLit = leftBulbShouldLight;
                if (gameState.bulbs[0].bulbSprite && gameState.bulbs[0].bulbSprite.setFrame) {
                    gameState.bulbs[0].bulbSprite.setFrame(leftBulbShouldLight ? 1 : 0);
                }
                
                // Right bulb (second bulb)
                if (gameState.bulbs[1]) {
                    gameState.bulbs[1].isLit = rightBulbShouldLight;
                    if (gameState.bulbs[1].bulbSprite && gameState.bulbs[1].bulbSprite.setFrame) {
                        gameState.bulbs[1].bulbSprite.setFrame(rightBulbShouldLight ? 1 : 0);
                    }
                }
            }
            
            // Return true only if ALL bulbs are lit (for success modal)
            const allBulbsLit = leftBulbShouldLight && rightBulbShouldLight;
            console.log(`Stage 4 evaluation: left=${leftBulbShouldLight}, right=${rightBulbShouldLight}, allLit=${allBulbsLit}`);
            return allBulbsLit;
        }

        function findFifthCircuitPath() {
            // Stage 5: Series-Parallel circuit with 3 bulbs
            // Circuit logic:
            // - Bulb 1 at (5,6): lights when 2-cell gap (3,4)-(4,4) AND 1-cell gap (3,10) are filled (series connection)
            // - Bulbs 2 and 3: light when ALL gaps are filled with conductors (requires complete circuit)
            console.log('Checking Stage 5 series-parallel circuit path...');
            
            // Check if all gaps are filled with conductors for a complete circuit
            const allGapsConductors = gameState.gaps.every(gap => {
                // For multi-cell gaps, check all cells in the gap
                for (let dx = 0; dx < gap.size.width; dx++) {
                    for (let dy = 0; dy < gap.size.height; dy++) {
                        const item = getGridPosition(gap.x + dx, gap.y + dy);
                        if (!item || !item.conductive) {
                            return false;
                        }
                    }
                }
                return true;
            });
            
            // Check individual bulb paths
            // Bulb 1 at (5,6): needs 2-cell gap (3,4)-(4,4) AND 1-cell gap (3,10) filled (series connection)
            const gap2Cell = gameState.gaps.find(gap => gap.x === 3 && gap.y === 4);
            const gap1CellBottom = gameState.gaps.find(gap => gap.x === 3 && gap.y === 10);
            let bulb1ShouldLight = false;
            
            if (gap2Cell && gap1CellBottom) {
                const gap2CellFilled = isConductive(3, 4) && isConductive(4, 4);
                const gap1CellBottomFilled = isConductive(3, 10);
                
                if (gap2CellFilled && gap1CellBottomFilled) {
                    console.log('Bulb 1 path complete - 2-cell gap and bottom 1-cell gap filled with conductors');
                    bulb1ShouldLight = true;
                }
            }
            
            // Bulbs 2 and 3: only light when ALL gaps are filled (complete circuit)
            let bulbs2And3ShouldLight = false;
            if (allGapsConductors) {
                console.log('Complete circuit - all gaps filled with conductors, bulbs 2 and 3 should light');
                bulbs2And3ShouldLight = true;
            }
            
            // Update bulb states
            if (gameState.bulbs) {
                // Bulb 1 at (5,6) - can light independently
                if (gameState.bulbs[0]) {
                    gameState.bulbs[0].isLit = bulb1ShouldLight;
                    if (gameState.bulbs[0].bulbSprite && gameState.bulbs[0].bulbSprite.setFrame) {
                        gameState.bulbs[0].bulbSprite.setFrame(bulb1ShouldLight ? 1 : 0);
                    }
                }
                
                // Bulb 2 at (8,4) - only lights when all gaps filled
                if (gameState.bulbs[1]) {
                    gameState.bulbs[1].isLit = bulbs2And3ShouldLight;
                    if (gameState.bulbs[1].bulbSprite && gameState.bulbs[1].bulbSprite.setFrame) {
                        gameState.bulbs[1].bulbSprite.setFrame(bulbs2And3ShouldLight ? 1 : 0);
                    }
                }
                
                // Bulb 3 at (8,9) - only lights when all gaps filled
                if (gameState.bulbs[2]) {
                    gameState.bulbs[2].isLit = bulbs2And3ShouldLight;
                    if (gameState.bulbs[2].bulbSprite && gameState.bulbs[2].bulbSprite.setFrame) {
                        gameState.bulbs[2].bulbSprite.setFrame(bulbs2And3ShouldLight ? 1 : 0);
                    }
                }
            }
            
            // Return true only if ALL bulbs are lit (for success modal)
            const allBulbsLit = bulb1ShouldLight && bulbs2And3ShouldLight;
            console.log(`Stage 5 evaluation: bulb1=${bulb1ShouldLight}, bulbs2And3=${bulbs2And3ShouldLight}, allLit=${allBulbsLit}`);
            return allBulbsLit;
        }

        // Visual Connection System Functions
        function updateWireConnections() {
            console.log('Updating wire connections...');
            
            // Clear existing connection graphics
            clearConnectionGraphics();
            
            // Draw connections from battery terminals
            drawBatteryConnections();
            
            // Draw connections to bulb terminals
            drawBulbConnections();
            
            // For each placed conductive item, draw connections to adjacent components
            gameState.itemBank.forEach(item => {
                if (item.placed && item.conductive) {
                    drawConnectionsForItem(item);
                }
            });
            
            // Draw connections between pre-placed wires and adjacent components
            gameState.preplacedWires.forEach(wire => {
                drawConnectionsForWire(wire);
            });
            
            // If circuit is complete or short circuit, draw the continuous path (without animation - handled by visualizeCurrentFlow)
            const isCircuitLit = (gameState.bulb && gameState.bulb.isLit) || 
                                (gameState.bulbs && gameState.bulbs.some(bulb => bulb.isLit)) ||
                                gameState.circuitState === 'short_circuit';
            if (isCircuitLit) {
                drawContinuousPathOnly();
            }
            
            console.log('Wire connections updated');
        }

        function clearConnectionGraphics() {
            // Destroy all existing connection graphics
            gameState.connectionGraphics.forEach(graphic => {
                if (graphic && graphic.destroy) {
                    graphic.destroy();
                }
            });
            gameState.connectionGraphics = [];
        }

        function drawBatteryConnections() {
            // No extra connections needed - vertical wires at (2,3) and (2,7) are sufficient
            // The vertical wires show that the battery is hooked up to the circuit
        }

        function drawBulbConnections() {
            // No extra connections needed - vertical wires at (12,3) and (12,7) are sufficient
            // The vertical wires show that the light bulb is hooked up to the circuit
        }

        function drawConnectionsForItem(item) {
            // Removed wire drawing for placed items to keep gap indicators clean
            return;
        }

        function drawConnectionsForWire(wire) {
            // Removed wire drawing to adjacent items to keep circuit clean
            return;
        }

        function drawWireConnection(fromPos, toPos, color, lineWidth) {
            const graphics = scene.add.graphics();
            graphics.lineStyle(lineWidth, color, 0.8);
            
            // Draw connecting wire with proper endpoints
            graphics.moveTo(fromPos.x, fromPos.y);
            graphics.lineTo(toPos.x, toPos.y);
            graphics.strokePath();
            
            // Add subtle glow effect for active connections
            const isLit = (gameState.bulb && gameState.bulb.isLit) || 
                         (gameState.bulbs && gameState.bulbs.some(bulb => bulb.isLit));
            if (isLit) {
                const glowGraphics = scene.add.graphics();
                glowGraphics.lineStyle(lineWidth + 2, color, 0.3);
                glowGraphics.moveTo(fromPos.x, fromPos.y);
                glowGraphics.lineTo(toPos.x, toPos.y);
                glowGraphics.strokePath();
                glowGraphics.setDepth(-1);
                gameState.connectionGraphics.push(glowGraphics);
            }
            
            // Store reference for cleanup
            gameState.connectionGraphics.push(graphics);
        }

        function getAdjacentPositions(gridX, gridY) {
            const positions = [];
            
            // Check all 4 adjacent positions (up, down, left, right)
            const directions = [
                { x: 0, y: -1 }, // Up
                { x: 0, y: 1 },  // Down
                { x: -1, y: 0 }, // Left
                { x: 1, y: 0 }   // Right
            ];
            
            directions.forEach(dir => {
                const newX = gridX + dir.x;
                const newY = gridY + dir.y;
                
                if (isValidGridPosition(newX, newY)) {
                    positions.push({ x: newX, y: newY });
                }
            });
            
            return positions;
        }

        function drawContinuousPathOnly() {
            // Draw the complete electrical path when circuit is active (without animation)
            const isLit = (gameState.bulb && gameState.bulb.isLit) || 
                         (gameState.bulbs && gameState.bulbs.some(bulb => bulb.isLit));
            console.log('drawContinuousPathOnly called - isLit:', isLit, 'circuitState:', gameState.circuitState);
            
            if (!isLit && gameState.circuitState !== 'short_circuit') {
                console.log('Skipping path drawing - conditions not met');
                return;
            }
            
            console.log('Drawing continuous electrical path for layout:', gameState.currentLayout);
            
            // Check if we should draw short circuit path
            if (gameState.circuitState === 'short_circuit') {
                console.log('Drawing SHORT CIRCUIT path');
                drawShortCircuitPathOnly();
                return;
            }
            
            // Create a special graphics object for the complete path
            const pathGraphics = scene.add.graphics();
            pathGraphics.lineStyle(6, 0xFFD700, 0.6); // Golden color for active path
            pathGraphics.setDepth(8); // Behind battery and bulb (depth 10) but above wires (depth 5)
            
            if (gameState.currentLayout === 'first') {
                drawFirstCircuitPath(pathGraphics);
            } else if (gameState.currentLayout === 'second') {
                drawSecondCircuitPath(pathGraphics);
            } else if (gameState.currentLayout === 'third') {
                drawThirdCircuitPath(pathGraphics);
            } else if (gameState.currentLayout === 'fourth') {
                drawFourthCircuitPath(pathGraphics);
            } else if (gameState.currentLayout === 'fifth') {
                drawFifthCircuitPath(pathGraphics);
            }
            
            pathGraphics.strokePath();
            
            // Store for cleanup
            gameState.connectionGraphics.push(pathGraphics);
        }
        
        function drawShortCircuitPathOnly() {
            // Draw the short circuit path in red
            console.log('=== DRAWING SHORT CIRCUIT PATH INDICATOR ===');
            console.log('Scene available:', !!scene);
            
            // Create a special graphics object for the short circuit path
            const pathGraphics = scene.add.graphics();
            pathGraphics.lineStyle(6, 0xFF0000, 0.8); // Red color for short circuit path
            pathGraphics.setDepth(8); // Behind battery and bulb (depth 10) but above wires (depth 5)
            
            // Get the short circuit path and draw it
            const shortCircuitPath = getShortCircuitPath();
            
            if (shortCircuitPath.length > 0) {
                // Start at first position
                const startPos = gridToWorld(shortCircuitPath[0].x, shortCircuitPath[0].y);
                pathGraphics.moveTo(startPos.x, startPos.y);
                
                // Draw line through each position in the short circuit path
                for (let i = 1; i < shortCircuitPath.length; i++) {
                    const pos = gridToWorld(shortCircuitPath[i].x, shortCircuitPath[i].y);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
                
                pathGraphics.strokePath();
                console.log('Short circuit path drawn with', shortCircuitPath.length, 'points');
            }
            
            // Store for cleanup
            gameState.connectionGraphics.push(pathGraphics);
        }
        
        function drawFirstCircuitPath(pathGraphics) {
            // First circuit path (original logic) - only for stages with single bulb
            if (!gameState.bulb) {
                console.log('Skipping drawFirstCircuitPath - no single bulb');
                return;
            }
            
            // Start from battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            pathGraphics.moveTo(batteryTopPos.x, batteryTopPos.y - gameState.cellSize * 0.5);
            
            // Connect vertically to vertical wire at (2,5), then to L-shaped wire at (2,4), then horizontally to top wire at (3,4)
            const batteryVWirePos = gridToWorld(2, 5);
            pathGraphics.lineTo(batteryVWirePos.x, batteryVWirePos.y);
            const batteryLWirePos = gridToWorld(2, 4);
            pathGraphics.lineTo(batteryLWirePos.x, batteryLWirePos.y);
            const batteryTopWirePos = gridToWorld(3, 4);
            pathGraphics.lineTo(batteryTopWirePos.x, batteryTopWirePos.y);
            
            // Trace through top wire to bulb
            for (let x = 3; x <= 11; x++) {
                if (isConductive(x, 4)) { // Row 4 is top wire
                    const pos = gridToWorld(x, 4);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect horizontally from top wire to bulb L-shaped wire at (12,4)
            const bulbTopLWirePos = gridToWorld(12, 4);
            pathGraphics.lineTo(bulbTopLWirePos.x, bulbTopLWirePos.y);
            
            // Connect vertically to vertical wire at (12,5)
            const bulbTopVWirePos = gridToWorld(12, 5);
            pathGraphics.lineTo(bulbTopVWirePos.x, bulbTopVWirePos.y);
            
            // Connect to bulb (through the bulb component)
            const bulbCenterPos = gridToWorld(gameState.bulb.x + 1, gameState.bulb.y + 1);
            pathGraphics.lineTo(bulbCenterPos.x, bulbCenterPos.y);
            
            // Connect to vertical wire at (12,9)
            const bulbBottomVWirePos = gridToWorld(12, 9);
            pathGraphics.lineTo(bulbBottomVWirePos.x, bulbBottomVWirePos.y);
            
            // Connect vertically to bulb L-shaped wire at (12,10)
            const bulbBottomLWirePos = gridToWorld(12, 10);
            pathGraphics.lineTo(bulbBottomLWirePos.x, bulbBottomLWirePos.y);
            
            // Connect horizontally to bottom wire at (11,10)
            const bulbBottomWirePos = gridToWorld(11, 10);
            pathGraphics.lineTo(bulbBottomWirePos.x, bulbBottomWirePos.y);
            
            // Trace through bottom wire back to battery
            for (let x = 11; x >= 3; x--) {
                if (isConductive(x, 10)) { // Row 10 is bottom wire
                    const pos = gridToWorld(x, 10);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect horizontally from bottom wire to battery L-shaped wire at (2,10)
            const batteryBottomLWirePos = gridToWorld(2, 10);
            pathGraphics.lineTo(batteryBottomLWirePos.x, batteryBottomLWirePos.y);
            
            // Connect vertically to vertical wire at (2,9)
            const batteryBottomVWirePos = gridToWorld(2, 9);
            pathGraphics.lineTo(batteryBottomVWirePos.x, batteryBottomVWirePos.y);
            
            // End vertically at battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            pathGraphics.lineTo(batteryBottomPos.x, batteryBottomPos.y + gameState.cellSize * 0.5);
        }
        
        function drawSecondCircuitPath(pathGraphics) {
            // Second circuit path with T-junctions - only for stages with single bulb
            if (!gameState.bulb) {
                console.log('Skipping drawSecondCircuitPath - no single bulb');
                return;
            }
            
            // Start from battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            pathGraphics.moveTo(batteryTopPos.x, batteryTopPos.y - gameState.cellSize * 0.5);
            
            // Connect vertically to vertical wire at (1,5), then to L-shaped wire at (1,4), then horizontally to top wire at (2,4)
            const batteryVWirePos = gridToWorld(1, 5);
            pathGraphics.lineTo(batteryVWirePos.x, batteryVWirePos.y);
            const batteryLWirePos = gridToWorld(1, 4);
            pathGraphics.lineTo(batteryLWirePos.x, batteryLWirePos.y);
            const batteryTopWirePos = gridToWorld(2, 4);
            pathGraphics.lineTo(batteryTopWirePos.x, batteryTopWirePos.y);
            
            // Trace through top wire to bulb
            for (let x = 2; x <= 12; x++) {
                if (isConductive(x, 4)) { // Row 4 is top wire
                    const pos = gridToWorld(x, 4);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect vertically to vertical wire at (12,5)
            const bulbTopVWirePos = gridToWorld(12, 5);
            pathGraphics.lineTo(bulbTopVWirePos.x, bulbTopVWirePos.y);
            
            // Connect to bulb (through the bulb component)
            const bulbCenterPos = gridToWorld(gameState.bulb.x + 1, gameState.bulb.y + 1);
            pathGraphics.lineTo(bulbCenterPos.x, bulbCenterPos.y);
            
            // Connect to vertical wire at (12,9)
            const bulbBottomVWirePos = gridToWorld(12, 9);
            pathGraphics.lineTo(bulbBottomVWirePos.x, bulbBottomVWirePos.y);
            
            // Connect vertically to bulb L-shaped wire at (12,10)
            const bulbBottomLWirePos = gridToWorld(12, 10);
            pathGraphics.lineTo(bulbBottomLWirePos.x, bulbBottomLWirePos.y);
            
            // Trace through bottom wire back to battery
            for (let x = 12; x >= 2; x--) {
                if (isConductive(x, 10)) { // Row 10 is bottom wire
                    const pos = gridToWorld(x, 10);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect horizontally from bottom wire to battery L-shaped wire at (1,10)
            const batteryBottomLWirePos = gridToWorld(1, 10);
            pathGraphics.lineTo(batteryBottomLWirePos.x, batteryBottomLWirePos.y);
            
            // Connect vertically to vertical wire at (1,9)
            const batteryBottomVWirePos = gridToWorld(1, 9);
            pathGraphics.lineTo(batteryBottomVWirePos.x, batteryBottomVWirePos.y);
            
            // End vertically at battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            pathGraphics.lineTo(batteryBottomPos.x, batteryBottomPos.y + gameState.cellSize * 0.5);
        }

        function drawThirdCircuitPath(pathGraphics) {
            // Third circuit path for series circuit with dual bulbs
            if (!gameState.bulbs || gameState.bulbs.length < 2) {
                console.log('Skipping drawThirdCircuitPath - no dual bulbs');
                return;
            }
            
            // Start from battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            pathGraphics.moveTo(batteryTopPos.x, batteryTopPos.y - gameState.cellSize * 0.5);
            
            // Connect to L-shaped wire at (2,4)
            const batteryLWirePos = gridToWorld(2, 4);
            pathGraphics.lineTo(batteryLWirePos.x, batteryLWirePos.y);
            
            // Top horizontal wire from battery toward first bulb
            for (let x = 3; x <= 6; x++) {
                if (isConductive(x, 4)) {
                    const pos = gridToWorld(x, 4);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect to first bulb center (entering from left)
            const bulb1CenterPos = gridToWorld(gameState.bulbs[0].x + 1, gameState.bulbs[0].y + 1);
            pathGraphics.lineTo(bulb1CenterPos.x, bulb1CenterPos.y);
            
            // Continue from first bulb to right side of top horizontal wire
            for (let x = 10; x <= 11; x++) {
                if (isConductive(x, 4)) {
                    const pos = gridToWorld(x, 4);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect to L-shaped wire at (12,4)
            const rightTopLWirePos = gridToWorld(12, 4);
            pathGraphics.lineTo(rightTopLWirePos.x, rightTopLWirePos.y);
            
            // Right vertical connection down (complete vertical path)
            if (isConductive(12, 5)) {
                const pos = gridToWorld(12, 5);
                pathGraphics.lineTo(pos.x, pos.y);
            }
            
            // Continue through the 3-cell gap (if filled)
            for (let y = 6; y <= 8; y++) {
                if (isConductive(12, y)) {
                    const pos = gridToWorld(12, y);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Right vertical connection down to second bulb level
            if (isConductive(12, 9)) {
                const pos = gridToWorld(12, 9);
                pathGraphics.lineTo(pos.x, pos.y);
            }
            
            // Connect to L-shaped wire at (12,10)
            const rightBottomLWirePos = gridToWorld(12, 10);
            pathGraphics.lineTo(rightBottomLWirePos.x, rightBottomLWirePos.y);
            
            // Bottom horizontal wire from right toward second bulb
            for (let x = 11; x >= 10; x--) {
                if (isConductive(x, 10)) {
                    const pos = gridToWorld(x, 10);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect to second bulb center (entering from right)
            const bulb2CenterPos = gridToWorld(gameState.bulbs[1].x + 1, gameState.bulbs[1].y + 1);
            pathGraphics.lineTo(bulb2CenterPos.x, bulb2CenterPos.y);
            
            // Continue from second bulb to left side of bottom horizontal wire
            for (let x = 6; x >= 3; x--) {
                if (isConductive(x, 10)) {
                    const pos = gridToWorld(x, 10);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect to L-shaped wire at (2,10)
            const batteryBottomLWirePos = gridToWorld(2, 10);
            pathGraphics.lineTo(batteryBottomLWirePos.x, batteryBottomLWirePos.y);
            
            // Left vertical connection up to battery
            if (isConductive(2, 9)) {
                const pos = gridToWorld(2, 9);
                pathGraphics.lineTo(pos.x, pos.y);
            }
            
            // End at battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            pathGraphics.lineTo(batteryBottomPos.x, batteryBottomPos.y + gameState.cellSize * 0.5);
        }

        function drawFourthCircuitPath(pathGraphics) {
            // Fourth circuit path for parallel circuit with dual bulbs
            if (!gameState.bulbs || gameState.bulbs.length < 2) {
                console.log('Skipping drawFourthCircuitPath - no dual bulbs');
                return;
            }
            
            // Declare bottomTJunctionPos at function scope to avoid reference errors
            const bottomTJunctionPos = gridToWorld(6, 10);
            
            // Start from battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            pathGraphics.moveTo(batteryTopPos.x, batteryTopPos.y - gameState.cellSize * 0.5);
            
            // Connect to L-shaped wire at (1,4)
            const batteryLWirePos = gridToWorld(1, 4);
            pathGraphics.lineTo(batteryLWirePos.x, batteryLWirePos.y);
            
            // Top horizontal wire from battery toward first bulb
            const pos2_4 = gridToWorld(2, 4);
            pathGraphics.lineTo(pos2_4.x, pos2_4.y);
            
            // Check if the 2-cell gap (3,4)-(4,4) is filled
            if (isConductive(3, 4) && isConductive(4, 4)) {
                const pos3_4 = gridToWorld(3, 4);
                const pos4_4 = gridToWorld(4, 4);
                pathGraphics.lineTo(pos3_4.x, pos3_4.y);
                pathGraphics.lineTo(pos4_4.x, pos4_4.y);
            }
            
            // Continue to wire before T-junction
            const pos5_4 = gridToWorld(5, 4);
            pathGraphics.lineTo(pos5_4.x, pos5_4.y);
            
            // Connect to T-junction at (6,4) and first bulb
            const tJunctionPos = gridToWorld(6, 4);
            pathGraphics.lineTo(tJunctionPos.x, tJunctionPos.y);
            
            // Branch down to first bulb if it's lit
            if (gameState.bulbs[0].isLit) {
                const bulb1CenterPos = gridToWorld(gameState.bulbs[0].x + 1, gameState.bulbs[0].y + 1);
                pathGraphics.lineTo(bulb1CenterPos.x, bulb1CenterPos.y);
            }
            
            // Only continue to right bulb if it's lit and all required gaps are filled
            if (gameState.bulbs[1].isLit && isConductive(8, 4) && isConductive(9, 4) && isConductive(10, 4) && isConductive(9, 10)) {
                // Return to T-junction and continue right
                pathGraphics.moveTo(tJunctionPos.x, tJunctionPos.y);
                
                // Continue through the 3-cell gap to second bulb
                for (let x = 8; x <= 11; x++) {
                    const pos = gridToWorld(x, 4);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
                
                // Connect to L-shaped wire at (12,4)
                const pos12_4 = gridToWorld(12, 4);
                pathGraphics.lineTo(pos12_4.x, pos12_4.y);
                
                // Connect to second bulb
                const bulb2CenterPos = gridToWorld(gameState.bulbs[1].x + 1, gameState.bulbs[1].y + 1);
                pathGraphics.lineTo(bulb2CenterPos.x, bulb2CenterPos.y);
            }
            
            // Draw return path through bottom wire only if left bulb is lit
            if (gameState.bulbs[0].isLit) {
                // Start from first bulb bottom
                const bulb1CenterPos = gridToWorld(gameState.bulbs[0].x + 1, gameState.bulbs[0].y + 1);
                pathGraphics.moveTo(bulb1CenterPos.x, bulb1CenterPos.y);
                
                // Connect to T-junction at (6,10)
                pathGraphics.lineTo(bottomTJunctionPos.x, bottomTJunctionPos.y);
                
                // Bottom horizontal wire back to battery
                for (let x = 5; x >= 1; x--) {
                    const pos = gridToWorld(x, 10);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
                
                // Connect to battery negative terminal
                const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
                pathGraphics.lineTo(batteryBottomPos.x, batteryBottomPos.y + gameState.cellSize * 0.5);
            }
            
            // If second bulb is also lit, draw its return path
            if (gameState.bulbs[1].isLit) {
                // Second bulb return path
                const bulb2CenterPos = gridToWorld(gameState.bulbs[1].x + 1, gameState.bulbs[1].y + 1);
                pathGraphics.moveTo(bulb2CenterPos.x, bulb2CenterPos.y);
                
                // Connect to L-shaped wire at (12,10)
                const pos12_10 = gridToWorld(12, 10);
                pathGraphics.lineTo(pos12_10.x, pos12_10.y);
                
                // Connect to right side bottom wire
                const pos11_10 = gridToWorld(11, 10);
                pathGraphics.lineTo(pos11_10.x, pos11_10.y);
                
                // Check if the bottom gap (9,10) is filled - updated position
                if (isConductive(9, 10)) {
                    const pos9_10 = gridToWorld(9, 10);
                    pathGraphics.lineTo(pos9_10.x, pos9_10.y);
                    
                    // Continue to bottom horizontal wires
                    const pos8_10 = gridToWorld(8, 10);
                    pathGraphics.lineTo(pos8_10.x, pos8_10.y);
                    
                    const pos7_10 = gridToWorld(7, 10);
                    pathGraphics.lineTo(pos7_10.x, pos7_10.y);
                    
                    // Continue to T-junction
                    pathGraphics.lineTo(bottomTJunctionPos.x, bottomTJunctionPos.y);
                }
            }
        }

        function drawFifthCircuitPath(pathGraphics) {
            // Fifth circuit path for series-parallel circuit with 3 bulbs
            if (!gameState.bulbs || gameState.bulbs.length < 3) {
                console.log('Skipping drawFifthCircuitPath - need 3 bulbs');
                return;
            }
            
            // Draw path for bulb 1 (left bulb) if it's lit
            if (gameState.bulbs[0].isLit) {
                // Start from battery positive terminal
                const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
                pathGraphics.moveTo(batteryTopPos.x, batteryTopPos.y - gameState.cellSize * 0.5);
                
                // Path to bulb 1: battery → (1,4) → (2,4) → gaps (3,4)-(4,4) → (5,4) → (6,4) → bulb1
                const positions = [
                    [1, 4], [2, 4], [3, 4], [4, 4], [5, 4], [6, 4]
                ];
                
                positions.forEach(([x, y]) => {
                    const pos = gridToWorld(x, y);
                    pathGraphics.lineTo(pos.x, pos.y);
                });
                
                // Branch down to bulb 1
                const pos6_5 = gridToWorld(6, 5);
                pathGraphics.lineTo(pos6_5.x, pos6_5.y);
                
                const pos6_6 = gridToWorld(6, 6);
                pathGraphics.lineTo(pos6_6.x, pos6_6.y);
                
                const bulb1CenterPos = gridToWorld(gameState.bulbs[0].x + 1, gameState.bulbs[0].y + 1);
                pathGraphics.lineTo(bulb1CenterPos.x, bulb1CenterPos.y);
                
                // Return path from bulb 1
                const pos6_8 = gridToWorld(6, 8);
                pathGraphics.lineTo(pos6_8.x, pos6_8.y);
                
                const pos6_9 = gridToWorld(6, 9);
                pathGraphics.lineTo(pos6_9.x, pos6_9.y);
                
                const pos6_10 = gridToWorld(6, 10);
                pathGraphics.lineTo(pos6_10.x, pos6_10.y);
                
                // Bottom path back to battery through 1-cell gap
                const returnPositions = [
                    [5, 10], [4, 10], [3, 10], [2, 10], [1, 10]
                ];
                
                returnPositions.forEach(([x, y]) => {
                    const pos = gridToWorld(x, y);
                    pathGraphics.lineTo(pos.x, pos.y);
                });
                
                // Connect to battery negative terminal
                const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
                pathGraphics.lineTo(batteryBottomPos.x, batteryBottomPos.y + gameState.cellSize * 0.5);
            }
            
            // Draw path for bulbs 2 and 3 (right bulbs) if they're lit
            if (gameState.bulbs[1].isLit && gameState.bulbs[2].isLit) {
                // Start from battery positive terminal
                const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
                pathGraphics.moveTo(batteryTopPos.x, batteryTopPos.y - gameState.cellSize * 0.5);
                
                // Path through top wire: battery → (1,4) → (2,4) → gaps (3,4)-(4,4) → (5,4) → (6,4) → (7,4) → (8,4) → (9,4)
                const topPositions = [
                    [1, 4], [2, 4], [3, 4], [4, 4], [5, 4], [6, 4], [7, 4], [8, 4], [9, 4]
                ];
                
                topPositions.forEach(([x, y]) => {
                    const pos = gridToWorld(x, y);
                    pathGraphics.lineTo(pos.x, pos.y);
                });
                
                // Branch up to bulb 2 (top right - shifted up to y=3)
                const pos9_3 = gridToWorld(9, 3);
                pathGraphics.lineTo(pos9_3.x, pos9_3.y);
                
                const bulb2CenterPos = gridToWorld(gameState.bulbs[1].x + 1, gameState.bulbs[1].y + 1);
                pathGraphics.lineTo(bulb2CenterPos.x, bulb2CenterPos.y);
                
                // Return to main path at (9,4) and continue right
                pathGraphics.moveTo(gridToWorld(9, 4).x, gridToWorld(9, 4).y);
                
                // Continue to right side
                const rightPositions = [
                    [10, 4], [11, 4], [12, 4]
                ];
                
                rightPositions.forEach(([x, y]) => {
                    const pos = gridToWorld(x, y);
                    pathGraphics.lineTo(pos.x, pos.y);
                });
                
                // Down through vertical gap
                const pos12_5 = gridToWorld(12, 5);
                pathGraphics.lineTo(pos12_5.x, pos12_5.y);
                
                // Through vertical 3-cell gap (12,6)-(12,8)
                const verticalPositions = [
                    [12, 6], [12, 7], [12, 8]
                ];
                
                verticalPositions.forEach(([x, y]) => {
                    const pos = gridToWorld(x, y);
                    pathGraphics.lineTo(pos.x, pos.y);
                });
                
                const pos12_9 = gridToWorld(12, 9);
                pathGraphics.lineTo(pos12_9.x, pos12_9.y);
                
                const pos12_10 = gridToWorld(12, 10);
                pathGraphics.lineTo(pos12_10.x, pos12_10.y);
                
                // Back through bottom wire
                const bottomRightPositions = [
                    [11, 10], [10, 10]
                ];
                
                bottomRightPositions.forEach(([x, y]) => {
                    const pos = gridToWorld(x, y);
                    pathGraphics.lineTo(pos.x, pos.y);
                });
                
                // Through bulb 3 (bottom right)
                const bulb3CenterPos = gridToWorld(gameState.bulbs[2].x + 1, gameState.bulbs[2].y + 1);
                pathGraphics.lineTo(bulb3CenterPos.x, bulb3CenterPos.y);
                
                // Continue back to battery
                const bottomLeftPositions = [
                    [7, 10], [6, 10], [5, 10], [4, 10], [3, 10], [2, 10], [1, 10]
                ];
                
                bottomLeftPositions.forEach(([x, y]) => {
                    const pos = gridToWorld(x, y);
                    pathGraphics.lineTo(pos.x, pos.y);
                });
                
                // Connect to battery negative terminal
                const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
                pathGraphics.lineTo(batteryBottomPos.x, batteryBottomPos.y + gameState.cellSize * 0.5);
            }
        }

        // Short Circuit Detection System
        function detectShortCircuit() {
            // Only check for short circuits in Stage 2 (second layout)
            if (gameState.currentLayout !== 'second') {
                return false;
            }
            
            console.log('Checking for short circuit in Stage 2...');
            console.log('Current gaps:', gameState.gaps);
            console.log('Placed items:', gameState.placedItems);
            
            // Debug: Print grid state around critical positions
            console.log('=== GRID DEBUG ===');
            for (let y = 3; y <= 11; y++) {
                let row = '';
                for (let x = 0; x <= 14; x++) {
                    const item = getGridPosition(x, y);
                    if (item === null) {
                        row += '. ';
                    } else if (item === 'wire') {
                        row += 'W ';
                    } else if (item === 'battery') {
                        row += 'B ';
                    } else if (item === 'bulb') {
                        row += 'O ';
                    } else if (item === 'gap') {
                        row += 'M ';
                    } else if (item && item.conductive) {
                        row += 'C ';
                    } else if (item && !item.conductive) {
                        row += 'I ';
                    } else {
                        row += '? ';
                    }
                }
                console.log(`Row ${y}: ${row}`);
            }
            console.log('=== END GRID DEBUG ===');
            
            // Check if conductors are placed in BOTH the 2-slot AND 3-slot missing part indicators
            
            // 2-slot gap: positions (3,4) and (4,4) - horizontal gap
            const twoSlotPositions = [
                { x: 3, y: 4 },
                { x: 4, y: 4 }
            ];
            
            const hasConductorIn2Slot = twoSlotPositions.every(pos => {
                const item = getGridPosition(pos.x, pos.y);
                const isConductive = item && (item.conductive || item === 'wire');
                console.log(`2-slot position (${pos.x},${pos.y}): item=`, item, `type=${typeof item}, conductive=${isConductive}`);
                if (item && typeof item === 'object') {
                    console.log(`  Item properties:`, Object.keys(item));
                    console.log(`  Item.conductive:`, item.conductive);
                    console.log(`  Item.type:`, item.type);
                }
                return isConductive;
            });
            
            // 3-slot gap: positions (6,6), (6,7), (6,8) - vertical gap
            const threeSlotPositions = [
                { x: 6, y: 6 },
                { x: 6, y: 7 },
                { x: 6, y: 8 }
            ];
            
            const hasConductorIn3Slot = threeSlotPositions.every(pos => {
                const item = getGridPosition(pos.x, pos.y);
                const isConductive = item && (item.conductive || item === 'wire');
                console.log(`3-slot position (${pos.x},${pos.y}): item=`, item, `type=${typeof item}, conductive=${isConductive}`);
                if (item && typeof item === 'object') {
                    console.log(`  Item properties:`, Object.keys(item));
                    console.log(`  Item.conductive:`, item.conductive);
                    console.log(`  Item.type:`, item.type);
                }
                return isConductive;
            });
            
            console.log('Has conductor in 2-slot gap (3,4)-(4,4):', hasConductorIn2Slot);
            console.log('Has conductor in 3-slot gap (6,6)-(6,8):', hasConductorIn3Slot);
            
            // Short circuit occurs when BOTH 2-slot and 3-slot gaps have conductors
            // The 1-slot gap does not affect short circuit detection
            if (hasConductorIn2Slot && hasConductorIn3Slot) {
                console.log('SHORT CIRCUIT DETECTED: Both 2-slot and 3-slot gaps have conductors');
                console.log('Current can flow from battery + through T-junction bypass path to battery -');
                return true;
            }
            
            console.log('Short circuit conditions not met - need conductors in BOTH 2-slot and 3-slot gaps');
            return false;
        }
        
        function getShortCircuitPath() {
            // Return the specific short circuit path for Stage 2
            // Battery + → (6,4) T-junction → (6,6)-(6,8) 3-slot conductor → (6,10) T-junction → Battery -
            console.log('getShortCircuitPath called');
            const path = [
                { x: 1, y: 7 },   // Battery center (visual starting point)
                { x: 1, y: 4 },   // Battery + connection
                { x: 2, y: 4 },   // Wire to 2-slot gap
                { x: 3, y: 4 },   // 2-slot conductor part 1
                { x: 4, y: 4 },   // 2-slot conductor part 2
                { x: 5, y: 4 },   // Wire to T-junction
                { x: 6, y: 4 },   // T-junction top
                { x: 6, y: 5 },   // Vertical wire down
                { x: 6, y: 6 },   // 3-slot conductor part 1
                { x: 6, y: 7 },   // 3-slot conductor part 2
                { x: 6, y: 8 },   // 3-slot conductor part 3
                { x: 6, y: 9 },   // Vertical wire down
                { x: 6, y: 10 },  // T-junction bottom
                { x: 5, y: 10 },  // Wire from T-junction
                { x: 4, y: 10 },  // Wire
                { x: 3, y: 10 },  // Wire
                { x: 2, y: 10 },  // Wire
                { x: 1, y: 10 },  // Battery - connection
                { x: 1, y: 7 }    // Battery center (visual ending point)
            ];
            console.log('Short circuit path generated with', path.length, 'points');
            return path;
        }
        
        function reconstructPath(parent, start, end) {
            const path = [];
            let current = end;
            
            while (current) {
                path.unshift(current);
                const key = `${current.x},${current.y}`;
                current = parent.get(key);
                
                // Stop when we reach the start
                if (current && current.x === start.x && current.y === start.y) {
                    path.unshift(start);
                    break;
                }
            }
            
            return path;
        }
        
        function isBulbPosition(x, y) {
            // Check if position is within any bulb area
            if (gameState.bulb) {
                // Single bulb (Stage 1 & 2)
                return x >= gameState.bulb.x && x < gameState.bulb.x + gameState.bulb.width &&
                       y >= gameState.bulb.y && y < gameState.bulb.y + gameState.bulb.height;
            } else if (gameState.bulbs) {
                // Multiple bulbs (Stage 3)
                return gameState.bulbs.some(bulb => 
                    x >= bulb.x && x < bulb.x + bulb.width &&
                    y >= bulb.y && y < bulb.y + bulb.height
                );
            }
            return false;
        }
        
        function showShortCircuitModal() {
            // Create short circuit warning modal
            const modal = document.getElementById('success-modal');
            const content = document.getElementById('success-content');
            
            content.innerHTML = `
                <h2 style="color: #F44336;">⚠️ Short Circuit Detected!</h2>
                <div id="short-circuit-details">
                    <p><strong>Oops! You've created a short circuit.</strong> The electricity is taking a shortcut from the battery's + terminal directly to the - terminal, bypassing the light bulb completely!</p>
                    
                    <div style="background-color: #FFEBEE; padding: 15px; border-radius: 8px; border-left: 4px solid #F44336; margin: 15px 0;">
                        <h4 style="color: #C62828; margin-bottom: 10px;">What is a Short Circuit?</h4>
                        <p style="color: #333; margin-bottom: 8px;">A short circuit happens when electricity finds an easier path than the one we want it to take. Instead of flowing through the light bulb, it's going directly from the battery's + side to the - side.</p>
                    </div>
                    
                    <div style="background-color: #FFF3E0; padding: 15px; border-radius: 8px; border-left: 4px solid #FF9800; margin: 15px 0;">
                        <h4 style="color: #E65100; margin-bottom: 10px;">Why is this a problem?</h4>
                        <ul style="color: #333; margin: 0; padding-left: 20px;">
                            <li style="margin-bottom: 8px;">The light bulb won't work because electricity isn't flowing through it</li>
                            <li style="margin-bottom: 8px;">Too much electricity flows too fast, which can be dangerous</li>
                            <li style="margin-bottom: 8px;">In real life, this could damage equipment or cause fires</li>
                        </ul>
                    </div>
                    
                    <div style="background-color: #E8F5E8; padding: 15px; border-radius: 8px; border-left: 4px solid #4CAF50; margin: 15px 0;">
                        <h4 style="color: #2E7D32; margin-bottom: 10px;">How to fix it:</h4>
                        <ul style="color: #333; margin: 0; padding-left: 20px;">
                            <li style="margin-bottom: 8px;">Check the wire for any stray connections or exposed conductors that may cause a short circuit.</li>
                            <li style="margin-bottom: 8px;">All wires should be properly insulated.</li>
                            <li style="margin-bottom: 8px;">Double check circuit design and make sure that it follow the intended path.</li>
                        </ul>
                    </div>
                </div>
                <div id="short-circuit-actions" style="display: flex; gap: 15px; justify-content: center; margin-top: 25px;">
                    <button id="try-again-btn" style="flex: 1; max-width: 150px;">🔄 Try Again</button>
                    <button id="reset-circuit-btn" style="flex: 1; max-width: 150px; background-color: #F44336;">🔄 Reset Circuit</button>
                </div>
            `;
            
            // Show modal
            modal.style.display = 'block';
            
            // Add event listeners for buttons
            document.getElementById('try-again-btn').addEventListener('click', function() {
                modal.style.display = 'none';
            });
            
            document.getElementById('reset-circuit-btn').addEventListener('click', function() {
                modal.style.display = 'none';
                resetCurrentStage();
            });
        }

        function visualizeCurrentFlow(hasFlow, isShortCircuit = false) {
            console.log('visualizeCurrentFlow called with hasFlow:', hasFlow, 'isShortCircuit:', isShortCircuit);
            const isLit = (gameState.bulb && gameState.bulb.isLit) || 
                         (gameState.bulbs && gameState.bulbs.some(bulb => bulb.isLit));
            console.log('isLit:', isLit);
            console.log('scene available:', !!scene);
            
            // Remove existing flow visualization
            if (gameState.flowVisualization) {
                console.log('Cleaning up existing flow visualization, count:', gameState.flowVisualization.length);
                gameState.flowVisualization.forEach(particle => {
                    // Clean up animation timers
                    if (particle.animationTimer) {
                        particle.animationTimer.destroy();
                    }
                    if (particle.destroy) particle.destroy();
                });
                gameState.flowVisualization = [];
            }
            
            if (!hasFlow) {
                console.log('hasFlow is false, stopping animation');
                return;
            }
            
            // For short circuits, show animation even if bulb is not lit
            if (!isLit && !isShortCircuit) {
                console.log('Bulb is not lit and not short circuit, not starting animation');
                return;
            }
            
            // Create a chain of synchronized pulsating particles
            gameState.flowVisualization = [];
            
            console.log('Starting synchronized chain of pulsating particles...');
            
            // Build the complete circuit path
            const circuitPath = buildCompleteCircuitPath();
            console.log('Circuit path:', circuitPath);
            
            if (circuitPath.length === 0) {
                console.log('No valid circuit path found');
                return;
            }
            
            const particles = [];
            // Use consistent 3-cell spacing for all stages (exactly 3 grid cells apart)
            const targetSpacing = gameState.cellSize * 3;
            console.log(`Target spacing set to: ${targetSpacing} pixels (3 cells of ${gameState.cellSize}px each)`);
            
            // Handle stage 4 and 5 differently - create particles for each bulb path with smart spacing
            if (gameState.currentLayout === 'fourth' || gameState.currentLayout === 'fifth') {
                console.log('Creating particles for stage 4/5 parallel circuit with smart spacing');
                console.log('Bulb states:', gameState.bulbs ? gameState.bulbs.map(b => ({id: b.id, isLit: b.isLit})) : 'no bulbs');
                
                // Get individual paths for each bulb based on current stage
                let leftBulbPath = [];
                let rightBulbPath = [];
                let thirdBulbPath = [];
                
                if (gameState.currentLayout === 'fourth') {
                    leftBulbPath = buildLeftBulbPath();
                    rightBulbPath = buildRightBulbPath();
                } else if (gameState.currentLayout === 'fifth') {
                    leftBulbPath = buildFifthLeftBulbPath();
                    rightBulbPath = buildFifthRightBulbPath();
                    thirdBulbPath = buildFifthThirdBulbPath();
                }
                
                console.log('Path lengths - left:', leftBulbPath.length, 'right:', rightBulbPath.length, 'third:', thirdBulbPath.length);
                
                // Create particles with slightly reduced spacing to fit 2 additional particles
                const baseSpacing = gameState.cellSize * 2.7; // Slightly less than 3 cells to fit more particles
                
                // Collect all lit bulb paths
                const litPaths = [];
                if (gameState.bulbs && gameState.bulbs[0] && gameState.bulbs[0].isLit && leftBulbPath.length > 0) {
                    litPaths.push({ path: leftBulbPath, type: 'left' });
                }
                if (gameState.bulbs && gameState.bulbs[1] && gameState.bulbs[1].isLit && rightBulbPath.length > 0) {
                    litPaths.push({ path: rightBulbPath, type: 'right' });
                }
                if (gameState.currentLayout === 'fifth' && gameState.bulbs && gameState.bulbs[2] && gameState.bulbs[2].isLit && thirdBulbPath.length > 0) {
                    litPaths.push({ path: thirdBulbPath, type: 'third' });
                }
                
                // Enhanced particle placement to fit more particles with equal spacing
                const globalParticles = [];
                const minDistance = baseSpacing;
                
                // First pass: collect all potential particle positions from all paths with denser spacing
                const allPotentialPositions = [];
                litPaths.forEach(({ path, type }) => {
                    const pathPositions = calculateEvenlySpacedPositions(path, baseSpacing);
                    pathPositions.forEach(pos => {
                        allPotentialPositions.push({
                            ...pos,
                            pathType: type,
                            circuitPath: path
                        });
                    });
                });
                
                // Sort potential positions by path type to ensure balanced distribution
                allPotentialPositions.sort((a, b) => {
                    if (a.pathType !== b.pathType) {
                        return a.pathType.localeCompare(b.pathType);
                    }
                    return a.pathIndex - b.pathIndex;
                });
                
                console.log(`Total potential positions: ${allPotentialPositions.length}`);
                
                // Second pass: select positions that maintain minimum distance, with priority for balanced distribution
                let targetParticleCount = Math.min(allPotentialPositions.length, 12); // Target 2 more than typical
                let placedCount = 0;
                
                for (let i = 0; i < allPotentialPositions.length && placedCount < targetParticleCount; i++) {
                    const candidate = allPotentialPositions[i];
                    let canPlace = true;
                    
                    // Check distance from all already placed particles
                    for (let placed of globalParticles) {
                        const distance = Math.sqrt(
                            Math.pow(candidate.x - placed.x, 2) + 
                            Math.pow(candidate.y - placed.y, 2)
                        );
                        
                        if (distance < minDistance) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    if (canPlace) {
                        globalParticles.push(candidate);
                        placedCount++;
                        
                        const particleColor = isShortCircuit ? 0xFF0000 : 0xFFFF00;
                        const particle = scene.add.circle(candidate.x, candidate.y, 6, particleColor);
                        particle.setAlpha(1.0);
                        particle.setDepth(8);
                        particle.active = true;
                        
                        const glow = scene.add.circle(candidate.x, candidate.y, 12, particleColor);
                        glow.setAlpha(0.4);
                        glow.setDepth(7);
                        glow.active = true;
                        
                        particles.push({ 
                            particle, 
                            glow, 
                            startIndex: candidate.pathIndex,
                            particleIndex: globalParticles.length - 1,
                            pathType: candidate.pathType,
                            circuitPath: candidate.circuitPath
                        });
                        gameState.flowVisualization.push(particle, glow);
                        
                        console.log(`Placed ${candidate.pathType} particle ${placedCount}/${targetParticleCount} at (${Math.round(candidate.x)}, ${Math.round(candidate.y)})`);
                    }
                }
                
                console.log(`Total particles created: ${particles.length} with smart offset spacing`)
            } else {
                // Original logic for other stages using even spacing
                const particlePositions = calculateEvenlySpacedPositions(circuitPath, targetSpacing);
                
                console.log(`Circuit path length: ${circuitPath.length}, Particle count: ${particlePositions.length} with target spacing ${targetSpacing} (Stage: ${gameState.currentLayout})`);
                
                // Create particles at evenly spaced positions along the path
                for (let i = 0; i < particlePositions.length; i++) {
                    const startPosition = particlePositions[i];
                    
                    console.log(`Creating particle ${i} at path index ${startPosition.pathIndex}, position:`, startPosition);
                    
                    // Create particle with appropriate color (yellow for normal, red for short circuit)
                    const particleColor = isShortCircuit ? 0xFF0000 : 0xFFFF00;
                    const particle = scene.add.circle(startPosition.x, startPosition.y, 6, particleColor);
                    particle.setAlpha(1.0);
                    particle.setDepth(8); // Behind battery and bulb (depth 10) but above wires (depth 5)
                    particle.active = true; // Set active property for animation
                    
                    // Create glow effect with matching color
                    const glow = scene.add.circle(startPosition.x, startPosition.y, 12, particleColor);
                    glow.setAlpha(0.4);
                    glow.setDepth(7); // Behind particle
                    glow.active = true; // Set active property for animation
                    
                    particles.push({ 
                        particle, 
                        glow, 
                        startIndex: startPosition.pathIndex,
                        particleIndex: i,
                        circuitPath: circuitPath
                    });
                    gameState.flowVisualization.push(particle, glow);
                    
                    console.log(`Particle ${i} created successfully at evenly spaced position`);
                }
            }
            
            console.log(`Created ${particles.length} particles in chain`);
            
            // Start synchronized pulsating animation
            startPulsatingChainAnimation(particles, circuitPath);
        }

        function calculateEvenlySpacedPositions(path, targetSpacing) {
            if (path.length === 0) return [];
            
            console.log(`Calculating positions with equal spacing for path with ${path.length} points`);
            
            // Calculate total path length in pixels
            let totalPathLength = 0;
            for (let i = 1; i < path.length; i++) {
                const prevPoint = path[i - 1];
                const currentPoint = path[i];
                const segmentDistance = Math.sqrt(
                    Math.pow(currentPoint.x - prevPoint.x, 2) + 
                    Math.pow(currentPoint.y - prevPoint.y, 2)
                );
                totalPathLength += segmentDistance;
            }
            
            console.log(`Total path length: ${totalPathLength} pixels`);
            
            // Target spacing: exactly 3 cells = 3 * cellSize pixels
            const targetSpacingPixels = gameState.cellSize * 3;
            console.log(`Target spacing: ${targetSpacingPixels} pixels (3 cells)`);
            
            // Calculate number of charges that fit with proper 3-cell spacing
            const numCharges = Math.max(1, Math.floor(totalPathLength / targetSpacingPixels));
            console.log(`Placing ${numCharges} charges with 3-cell spacing (${targetSpacingPixels}px)`);
            
            const positions = [];
            
            // Place charges at exact 3-cell intervals
            for (let i = 0; i < numCharges; i++) {
                const distance = i * targetSpacingPixels;
                
                // Don't place if we exceed the path length
                if (distance >= totalPathLength) break;
                
                const position = getPositionAtDistance(path, distance);
                
                if (position) {
                    positions.push({
                        x: position.x,
                        y: position.y,
                        pathIndex: distance / totalPathLength * (path.length - 1)
                    });
                    
                    console.log(`Placed charge ${positions.length} at distance ${Math.round(distance)}px = (${Math.round(position.x)}, ${Math.round(position.y)})`);
                }
            }
            
            console.log(`Final: placed ${positions.length} charges with perfectly equal spacing`);
            console.log('Charge positions:', positions.map((p, i) => {
                if (i > 0) {
                    const prev = positions[i - 1];
                    const dist = Math.sqrt(Math.pow(p.x - prev.x, 2) + Math.pow(p.y - prev.y, 2));
                    return `Charge ${i + 1}: pixel (${Math.round(p.x)}, ${Math.round(p.y)}) - spacing: ${Math.round(dist / gameState.cellSize * 10) / 10} cells`;
                }
                return `Charge ${i + 1}: pixel (${Math.round(p.x)}, ${Math.round(p.y)}) - start`;
            }));
            
            return positions;
        }



        function buildCompleteCircuitPath() {
            console.log('Building circuit path for layout:', gameState.currentLayout);
            
            // Check if we should use short circuit path (Stage 2 only)
            if (gameState.currentLayout === 'second' && gameState.circuitState === 'short_circuit') {
                console.log('Using short circuit path for visualization');
                return buildShortCircuitPath();
            }
            
            if (gameState.currentLayout === 'second') {
                return buildSecondCircuitPath();
            } else if (gameState.currentLayout === 'third') {
                return buildThirdCircuitPath();
            } else if (gameState.currentLayout === 'fourth') {
                return buildFourthCircuitPath();
            } else if (gameState.currentLayout === 'fifth') {
                return buildFifthCircuitPath();
            } else {
                return buildFirstCircuitPath();
            }
        }
        
        function buildShortCircuitPath() {
            console.log('Building short circuit path...');
            const path = [];
            const shortCircuitPositions = getShortCircuitPath();
            
            // Convert grid positions to world positions for visualization
            shortCircuitPositions.forEach(pos => {
                const worldPos = gridToWorld(pos.x, pos.y);
                path.push({ 
                    x: worldPos.x, 
                    y: worldPos.y, 
                    isShortCircuit: true 
                });
            });
            
            console.log('Short circuit path built with', path.length, 'points');
            return path;
        }

        function buildFirstCircuitPath() {
            if (!gameState.bulb) {
                console.log('Skipping buildFirstCircuitPath - no single bulb');
                return [];
            }
            
            const path = [];
            const batteryPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            const bulbPos = gridToWorld(gameState.bulb.x, gameState.bulb.y);
            
            console.log('Building first circuit path...');
            console.log('Battery position:', batteryPos);
            console.log('Bulb position:', bulbPos);
            
            // Start at battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            path.push({ x: batteryTopPos.x, y: batteryTopPos.y - gameState.cellSize * 0.5, isTerminal: true });
            
            // Connection vertically to vertical wire at (2,5)
            const batteryVWirePos = gridToWorld(2, 5);
            path.push({ x: batteryVWirePos.x, y: batteryVWirePos.y, isWire: true });
            
            // Connection to L-shaped wire at (2,4)
            const batteryLWirePos = gridToWorld(2, 4);
            path.push({ x: batteryLWirePos.x, y: batteryLWirePos.y, isWire: true });
            
            // Top wire (positive path) from battery to bulb (including L-shaped wire positions)
            for (let x = 3; x <= 12; x++) {
                if (isConductive(x, 4)) { // Row 4 is top wire
                    const pos = gridToWorld(x, 4);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added top wire position: (${pos.x}, ${pos.y})`);
                }
            }
            
            // Connection vertically to vertical wire at (12,5)
            const bulbTopVWirePos = gridToWorld(12, 5);
            path.push({ x: bulbTopVWirePos.x, y: bulbTopVWirePos.y, isWire: true });
            
            // Connection to bulb (through the bulb component)
            const bulbCenterPos = gridToWorld(gameState.bulb.x + 1, gameState.bulb.y + 1);
            path.push({ x: bulbCenterPos.x, y: bulbCenterPos.y, isBulb: true });
            
            // Connection to vertical wire at (12,9)
            const bulbBottomVWirePos = gridToWorld(12, 9);
            path.push({ x: bulbBottomVWirePos.x, y: bulbBottomVWirePos.y, isWire: true });
            
            // Bottom wire (negative path) from bulb back to battery (including L-shaped wire positions)
            for (let x = 12; x >= 2; x--) {
                if (isConductive(x, 10)) { // Row 10 is bottom wire
                    const pos = gridToWorld(x, 10);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added bottom wire position: (${pos.x}, ${pos.y})`);
                }
            }
            
            // Connection vertically to vertical wire at (2,9)
            const batteryBottomVWirePos = gridToWorld(2, 9);
            path.push({ x: batteryBottomVWirePos.x, y: batteryBottomVWirePos.y, isWire: true });
            
            // Battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            path.push({ x: batteryBottomPos.x, y: batteryBottomPos.y + gameState.cellSize * 0.5, isTerminal: true });
            
            console.log(`First circuit path built with ${path.length} points`);
            return path;
        }

        function buildSecondCircuitPath() {
            if (!gameState.bulb) {
                console.log('Skipping buildSecondCircuitPath - no single bulb');
                return [];
            }
            
            const path = [];
            
            console.log('Building second circuit path...');
            
            // Start at battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            path.push({ x: batteryTopPos.x, y: batteryTopPos.y - gameState.cellSize * 0.5, isTerminal: true });
            
            // Connection vertically to vertical wire at (1,5)
            const batteryVWirePos = gridToWorld(1, 5);
            path.push({ x: batteryVWirePos.x, y: batteryVWirePos.y, isWire: true });
            
            // Connection to L-shaped wire at (1,4)
            const batteryLWirePos = gridToWorld(1, 4);
            path.push({ x: batteryLWirePos.x, y: batteryLWirePos.y, isWire: true });
            
            // Top wire (positive path) from battery to T-junction (starting from x=2)
            for (let x = 2; x <= 6; x++) {
                if (isConductive(x, 4)) { // Row 4 is top wire
                    const pos = gridToWorld(x, 4);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added top wire position: (${pos.x}, ${pos.y})`);
                }
            }
            
            // Continue horizontally from T-junction to bulb (starting from x=7 to avoid duplicate)
            for (let x = 7; x <= 12; x++) {
                if (isConductive(x, 4)) { // Continue on row 4
                    const pos = gridToWorld(x, 4);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added top wire position after T-junction: (${pos.x}, ${pos.y})`);
                }
            }
            
            // Connection vertically to vertical wire at (12,5)
            const bulbTopVWirePos = gridToWorld(12, 5);
            path.push({ x: bulbTopVWirePos.x, y: bulbTopVWirePos.y, isWire: true });
            
            // Connection to bulb (through the bulb component)
            const bulbCenterPos = gridToWorld(gameState.bulb.x + 1, gameState.bulb.y + 1);
            path.push({ x: bulbCenterPos.x, y: bulbCenterPos.y, isBulb: true });
            
            // Connection to vertical wire at (12,9)
            const bulbBottomVWirePos = gridToWorld(12, 9);
            path.push({ x: bulbBottomVWirePos.x, y: bulbBottomVWirePos.y, isWire: true });
            
            // Bottom wire (negative path) from bulb back to T-junction (starting from x=12)
            for (let x = 12; x >= 6; x--) {
                if (isConductive(x, 10)) { // Row 10 is bottom wire
                    const pos = gridToWorld(x, 10);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added bottom wire position: (${pos.x}, ${pos.y})`);
                }
            }
            
            // At T-junction (6,10), continue horizontally to battery (starting from x=5 to avoid duplicate)
            for (let x = 5; x >= 1; x--) {
                if (isConductive(x, 10)) { // Continue on row 10
                    const pos = gridToWorld(x, 10);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added bottom wire position after T-junction: (${pos.x}, ${pos.y})`);
                }
            }
            
            // Connection vertically to vertical wire at (1,9)
            const batteryBottomVWirePos = gridToWorld(1, 9);
            path.push({ x: batteryBottomVWirePos.x, y: batteryBottomVWirePos.y, isWire: true });
            
            // Battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            path.push({ x: batteryBottomPos.x, y: batteryBottomPos.y + gameState.cellSize * 0.5, isTerminal: true });
            
            console.log(`Second circuit path built with ${path.length} points`);
            return path;
        }

        function buildThirdCircuitPath() {
            if (!gameState.bulbs || gameState.bulbs.length < 2) {
                console.log('Skipping buildThirdCircuitPath - no dual bulbs');
                return [];
            }
            
            const path = [];
            
            console.log('Building third circuit path (series circuit)...');
            
            // Start at battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            path.push({ x: batteryTopPos.x, y: batteryTopPos.y - gameState.cellSize * 0.5, isTerminal: true });
            
            // Connection to L-shaped wire at (2,4)
            const batteryLWirePos = gridToWorld(2, 4);
            path.push({ x: batteryLWirePos.x, y: batteryLWirePos.y, isWire: true });
            
            // Top horizontal wire from battery toward first bulb
            for (let x = 3; x <= 6; x++) {
                if (isConductive(x, 4)) {
                    const pos = gridToWorld(x, 4);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                }
            }
            
            // Connection to first bulb center (entering from left)
            const bulb1CenterPos = gridToWorld(gameState.bulbs[0].x + 1, gameState.bulbs[0].y + 1);
            path.push({ x: bulb1CenterPos.x, y: bulb1CenterPos.y, isBulb: true });
            
            // Continue from first bulb to right side of top horizontal wire
            for (let x = 10; x <= 11; x++) {
                if (isConductive(x, 4)) {
                    const pos = gridToWorld(x, 4);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                }
            }
            
            // Connection to L-shaped wire at (12,4)
            const rightTopLWirePos = gridToWorld(12, 4);
            path.push({ x: rightTopLWirePos.x, y: rightTopLWirePos.y, isWire: true });
            
            // Right vertical connection down (complete vertical path)
            if (isConductive(12, 5)) {
                const pos = gridToWorld(12, 5);
                path.push({ x: pos.x, y: pos.y, isWire: true });
            }
            
            // Continue through the 3-cell gap (if filled)
            for (let y = 6; y <= 8; y++) {
                if (isConductive(12, y)) {
                    const pos = gridToWorld(12, y);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                }
            }
            
            // Right vertical connection down to second bulb level
            if (isConductive(12, 9)) {
                const pos = gridToWorld(12, 9);
                path.push({ x: pos.x, y: pos.y, isWire: true });
            }
            
            // Connection to L-shaped wire at (12,10)
            const rightBottomLWirePos = gridToWorld(12, 10);
            path.push({ x: rightBottomLWirePos.x, y: rightBottomLWirePos.y, isWire: true });
            
            // Bottom horizontal wire from right toward second bulb
            for (let x = 11; x >= 10; x--) {
                if (isConductive(x, 10)) {
                    const pos = gridToWorld(x, 10);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                }
            }
            
            // Connection to second bulb center (entering from right)
            const bulb2CenterPos = gridToWorld(gameState.bulbs[1].x + 1, gameState.bulbs[1].y + 1);
            path.push({ x: bulb2CenterPos.x, y: bulb2CenterPos.y, isBulb: true });
            
            // Continue from second bulb to left side of bottom horizontal wire
            for (let x = 6; x >= 3; x--) {
                if (isConductive(x, 10)) {
                    const pos = gridToWorld(x, 10);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                }
            }
            
            // Connection to L-shaped wire at (2,10)
            const batteryBottomLWirePos = gridToWorld(2, 10);
            path.push({ x: batteryBottomLWirePos.x, y: batteryBottomLWirePos.y, isWire: true });
            
            // Left vertical connection up to battery
            if (isConductive(2, 9)) {
                const pos = gridToWorld(2, 9);
                path.push({ x: pos.x, y: pos.y, isWire: true });
            }
            
            // Battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            path.push({ x: batteryBottomPos.x, y: batteryBottomPos.y + gameState.cellSize * 0.5, isTerminal: true });
            
            console.log(`Third circuit path built with ${path.length} points`);
            return path;
        }

        function buildFourthCircuitPath() {
            if (!gameState.bulbs || gameState.bulbs.length < 2) {
                console.log('Skipping buildFourthCircuitPath - no dual bulbs');
                return [];
            }
            
            const paths = [];
            
            console.log('Building fourth circuit path (parallel circuit)...');
            
            // Create separate path for left bulb (bulb1)
            if (gameState.bulbs[0].isLit) {
                const leftBulbPath = buildLeftBulbPath();
                if (leftBulbPath.length > 0) {
                    paths.push(...leftBulbPath);
                }
            }
            
            // Create separate path for right bulb (bulb2)
            if (gameState.bulbs[1].isLit) {
                const rightBulbPath = buildRightBulbPath();
                if (rightBulbPath.length > 0) {
                    paths.push(...rightBulbPath);
                }
            }
            
            console.log(`Fourth circuit path built with ${paths.length} points`);
            return paths;
        }

        function buildLeftBulbPath() {
            const path = [];
            
            // Only build path if left bulb is actually lit and required gap is filled
            if (!gameState.bulbs || !gameState.bulbs[0] || !gameState.bulbs[0].isLit) {
                console.log('Left bulb path not built - bulb not lit');
                return path;
            }
            
            // Check if left bulb path is complete (2-cell gap filled)
            const item3_4 = getGridPosition(3, 4);
            const item4_4 = getGridPosition(4, 4);
            const gap2CellFilled = isConductive(3, 4) && isConductive(4, 4);
            console.log(`Left bulb path check - gap2CellFilled: ${gap2CellFilled}`);
            console.log(`(3,4): ${isConductive(3, 4)}, item:`, item3_4);
            console.log(`(4,4): ${isConductive(4, 4)}, item:`, item4_4);
            if (!gap2CellFilled) {
                console.log('Left bulb path not built - 2-cell gap not filled');
                return path; // Don't build path if required gap isn't filled
            }
            
            // Left bulb path: battery positive → (1,4) → (2,4) → gaps (3,4)-(4,4) → (5,4) → (6,4) → (6,5) → left bulb → (6,9) → (6,10) → (5,10) → (4,10) → (3,10) → (2,10) → (1,10) → (1,9) → battery negative
            
            // Start at battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            path.push({ x: batteryTopPos.x, y: batteryTopPos.y - gameState.cellSize * 0.5, isTerminal: true });
            
            // Connection to L-shaped wire at (1,4)
            const pos1_4 = gridToWorld(1, 4);
            path.push({ x: pos1_4.x, y: pos1_4.y, isWire: true });
            
            // Horizontal wire to (2,4)
            const pos2_4 = gridToWorld(2, 4);
            path.push({ x: pos2_4.x, y: pos2_4.y, isWire: true });
            
            // Through the 2-cell gap (3,4)-(4,4)
            const pos3_4 = gridToWorld(3, 4);
            const pos4_4 = gridToWorld(4, 4);
            path.push({ x: pos3_4.x, y: pos3_4.y, isWire: true });
            path.push({ x: pos4_4.x, y: pos4_4.y, isWire: true });
            
            // Continue to wire at (5,4)
            const pos5_4 = gridToWorld(5, 4);
            path.push({ x: pos5_4.x, y: pos5_4.y, isWire: true });
            
            // Connection to T-junction at (6,4)
            const pos6_4 = gridToWorld(6, 4);
            path.push({ x: pos6_4.x, y: pos6_4.y, isWire: true });
            
            // Branch down through vertical wire to (6,5) with intermediate points for better charge spacing
            const pos6_5 = gridToWorld(6, 5);
            path.push({ x: pos6_5.x, y: pos6_5.y, isWire: true });
            
            // Add intermediate points along vertical path to bulb for better charge distribution
            const bulb1TopPos = gridToWorld(gameState.bulbs[0].x + 1, gameState.bulbs[0].y);
            path.push({ x: bulb1TopPos.x, y: bulb1TopPos.y, isWire: true });
            
            // Connection to left bulb center
            const bulb1CenterPos = gridToWorld(gameState.bulbs[0].x + 1, gameState.bulbs[0].y + 1);
            path.push({ x: bulb1CenterPos.x, y: bulb1CenterPos.y, isBulb: true });
            
            // Add intermediate points along vertical path from bulb for better charge distribution
            const bulb1BottomPos = gridToWorld(gameState.bulbs[0].x + 1, gameState.bulbs[0].y + 2);
            path.push({ x: bulb1BottomPos.x, y: bulb1BottomPos.y, isWire: true });
            
            // Return path from left bulb through vertical wire to (6,9)
            const pos6_9 = gridToWorld(6, 9);
            path.push({ x: pos6_9.x, y: pos6_9.y, isWire: true });
            
            // Connection to bottom T-junction at (6,10)
            const pos6_10 = gridToWorld(6, 10);
            path.push({ x: pos6_10.x, y: pos6_10.y, isWire: true });
            
            // Bottom horizontal wire back to battery: (5,10) → (4,10) → (3,10) → (2,10) → (1,10)
            const pos5_10 = gridToWorld(5, 10);
            path.push({ x: pos5_10.x, y: pos5_10.y, isWire: true });
            
            const pos4_10 = gridToWorld(4, 10);
            path.push({ x: pos4_10.x, y: pos4_10.y, isWire: true });
            
            const pos3_10 = gridToWorld(3, 10);
            path.push({ x: pos3_10.x, y: pos3_10.y, isWire: true });
            
            const pos2_10 = gridToWorld(2, 10);
            path.push({ x: pos2_10.x, y: pos2_10.y, isWire: true });
            
            // Connection to L-shaped wire at (1,10)
            const pos1_10 = gridToWorld(1, 10);
            path.push({ x: pos1_10.x, y: pos1_10.y, isWire: true });
            
            // Connection vertically to (1,9)
            const pos1_9 = gridToWorld(1, 9);
            path.push({ x: pos1_9.x, y: pos1_9.y, isWire: true });
            
            // Battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            path.push({ x: batteryBottomPos.x, y: batteryBottomPos.y + gameState.cellSize * 0.5, isTerminal: true });
            
            console.log(`Left bulb path built with ${path.length} points`);
            return path;
        }

        function buildRightBulbPath() {
            const path = [];
            
            // Only build path if right bulb is actually lit and all required gaps are filled
            if (!gameState.bulbs || !gameState.bulbs[1] || !gameState.bulbs[1].isLit) {
                return path;
            }
            
            // Check if right bulb path is complete (3-cell gap + 1-cell gap both filled)
            const gap3CellFilled = isConductive(8, 4) && isConductive(9, 4) && isConductive(10, 4);
            const gap1CellFilled = isConductive(9, 10);
            const gap2CellFilled = isConductive(3, 4) && isConductive(4, 4);
            
            if (!gap3CellFilled || !gap1CellFilled || !gap2CellFilled) {
                return path; // Don't build path if required gaps aren't filled
            }
            
            // Right bulb path: battery positive → (1,4) → (2,4) → gaps (3,4)-(4,4) → (5,4) → (6,4) → gaps (8,4)-(10,4) → (11,4) → (12,4) → (12,5) → right bulb → (12,9) → (12,10) → (11,10) → (10,10) → gap (9,10) → (8,10) → (7,10) → (6,10) → (5,10) → (4,10) → (3,10) → (2,10) → (1,10) → (1,9) → battery negative
            
            // Start at battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            path.push({ x: batteryTopPos.x, y: batteryTopPos.y - gameState.cellSize * 0.5, isTerminal: true });
            
            // Connection to L-shaped wire at (1,4)
            const pos1_4 = gridToWorld(1, 4);
            path.push({ x: pos1_4.x, y: pos1_4.y, isWire: true });
            
            // Horizontal wire to (2,4)
            const pos2_4 = gridToWorld(2, 4);
            path.push({ x: pos2_4.x, y: pos2_4.y, isWire: true });
            
            // Through the 2-cell gap (3,4)-(4,4)
            const pos3_4 = gridToWorld(3, 4);
            const pos4_4 = gridToWorld(4, 4);
            path.push({ x: pos3_4.x, y: pos3_4.y, isWire: true });
            path.push({ x: pos4_4.x, y: pos4_4.y, isWire: true });
            
            // Continue to wire at (5,4)
            const pos5_4 = gridToWorld(5, 4);
            path.push({ x: pos5_4.x, y: pos5_4.y, isWire: true });
            
            // Connection to T-junction at (6,4)
            const pos6_4 = gridToWorld(6, 4);
            path.push({ x: pos6_4.x, y: pos6_4.y, isWire: true });
            
            // Through the 3-cell gap (8,4)-(10,4)
            const pos8_4 = gridToWorld(8, 4);
            const pos9_4 = gridToWorld(9, 4);
            const pos10_4 = gridToWorld(10, 4);
            path.push({ x: pos8_4.x, y: pos8_4.y, isWire: true });
            path.push({ x: pos9_4.x, y: pos9_4.y, isWire: true });
            path.push({ x: pos10_4.x, y: pos10_4.y, isWire: true });
            
            // Continue to horizontal wire at (11,4)
            const pos11_4 = gridToWorld(11, 4);
            path.push({ x: pos11_4.x, y: pos11_4.y, isWire: true });
            
            // Connection to L-shaped wire at (12,4)
            const pos12_4 = gridToWorld(12, 4);
            path.push({ x: pos12_4.x, y: pos12_4.y, isWire: true });
            
            // Connection through vertical wire to (12,5) with intermediate points for better charge spacing
            const pos12_5 = gridToWorld(12, 5);
            path.push({ x: pos12_5.x, y: pos12_5.y, isWire: true });
            
            // Add intermediate points along vertical path to bulb for better charge distribution
            const bulb2TopPos = gridToWorld(gameState.bulbs[1].x + 1, gameState.bulbs[1].y);
            path.push({ x: bulb2TopPos.x, y: bulb2TopPos.y, isWire: true });
            
            // Connection to right bulb center
            const bulb2CenterPos = gridToWorld(gameState.bulbs[1].x + 1, gameState.bulbs[1].y + 1);
            path.push({ x: bulb2CenterPos.x, y: bulb2CenterPos.y, isBulb: true });
            
            // Add intermediate points along vertical path from bulb for better charge distribution
            const bulb2BottomPos = gridToWorld(gameState.bulbs[1].x + 1, gameState.bulbs[1].y + 2);
            path.push({ x: bulb2BottomPos.x, y: bulb2BottomPos.y, isWire: true });
            
            // Return path from right bulb through vertical wire to (12,9)
            const pos12_9 = gridToWorld(12, 9);
            path.push({ x: pos12_9.x, y: pos12_9.y, isWire: true });
            
            // Connection to L-shaped wire at (12,10)
            const pos12_10 = gridToWorld(12, 10);
            path.push({ x: pos12_10.x, y: pos12_10.y, isWire: true });
            
            // Continue through horizontal wires: (11,10) → (10,10) → gap (9,10) → (8,10) → (7,10) → (6,10) → (5,10) → (4,10) → (3,10) → (2,10) → (1,10)
            const pos11_10 = gridToWorld(11, 10);
            path.push({ x: pos11_10.x, y: pos11_10.y, isWire: true });
            
            const pos10_10 = gridToWorld(10, 10);
            path.push({ x: pos10_10.x, y: pos10_10.y, isWire: true });
            
            // Through bottom gap (9,10)
            const pos9_10 = gridToWorld(9, 10);
            path.push({ x: pos9_10.x, y: pos9_10.y, isWire: true });
            
            // Continue to bottom horizontal wires
            const pos8_10 = gridToWorld(8, 10);
            path.push({ x: pos8_10.x, y: pos8_10.y, isWire: true });
            
            const pos7_10 = gridToWorld(7, 10);
            path.push({ x: pos7_10.x, y: pos7_10.y, isWire: true });
            
            // Back to bottom T-junction at (6,10)
            const pos6_10 = gridToWorld(6, 10);
            path.push({ x: pos6_10.x, y: pos6_10.y, isWire: true });
            
            // Continue back to battery: (5,10) → (4,10) → (3,10) → (2,10) → (1,10)
            const pos5_10 = gridToWorld(5, 10);
            path.push({ x: pos5_10.x, y: pos5_10.y, isWire: true });
            
            const pos4_10 = gridToWorld(4, 10);
            path.push({ x: pos4_10.x, y: pos4_10.y, isWire: true });
            
            const pos3_10 = gridToWorld(3, 10);
            path.push({ x: pos3_10.x, y: pos3_10.y, isWire: true });
            
            const pos2_10 = gridToWorld(2, 10);
            path.push({ x: pos2_10.x, y: pos2_10.y, isWire: true });
            
            // Connection to L-shaped wire at (1,10)
            const pos1_10 = gridToWorld(1, 10);
            path.push({ x: pos1_10.x, y: pos1_10.y, isWire: true });
            
            // Connection vertically to (1,9)
            const pos1_9 = gridToWorld(1, 9);
            path.push({ x: pos1_9.x, y: pos1_9.y, isWire: true });
            
            // Battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            path.push({ x: batteryBottomPos.x, y: batteryBottomPos.y + gameState.cellSize * 0.5, isTerminal: true });
            
            return path;
        }

        function buildFifthCircuitPath() {
            if (!gameState.bulbs || gameState.bulbs.length < 3) {
                console.log('Skipping buildFifthCircuitPath - need 3 bulbs');
                return [];
            }
            
            const paths = [];
            
            console.log('Building fifth circuit path (series-parallel circuit with 3 bulbs)...');
            
            // Create separate path for left bulb (bulb1)
            if (gameState.bulbs[0].isLit) {
                const leftBulbPath = buildFifthLeftBulbPath();
                if (leftBulbPath.length > 0) {
                    paths.push(...leftBulbPath);
                }
            }
            
            // Create separate path for right bulb (bulb2)
            if (gameState.bulbs[1].isLit) {
                const rightBulbPath = buildFifthRightBulbPath();
                if (rightBulbPath.length > 0) {
                    paths.push(...rightBulbPath);
                }
            }
            
            // Create separate path for third bulb (bulb3)
            if (gameState.bulbs[2].isLit) {
                const thirdBulbPath = buildFifthThirdBulbPath();
                if (thirdBulbPath.length > 0) {
                    paths.push(...thirdBulbPath);
                }
            }
            
            console.log(`Fifth circuit path built with ${paths.length} points`);
            return paths;
        }

        function buildFifthLeftBulbPath() {
            const path = [];
            
            // Only build path if left bulb is actually lit and required gaps are filled
            if (!gameState.bulbs || !gameState.bulbs[0] || !gameState.bulbs[0].isLit) {
                console.log('Left bulb path not built - bulb not lit');
                return path;
            }
            
            // Check if left bulb path is complete (2-cell gap and bottom 1-cell gap filled)
            const gap2CellFilled = isConductive(3, 4) && isConductive(4, 4);
            const gap1CellBottomFilled = isConductive(3, 10);
            console.log(`Left bulb path check - gap2CellFilled: ${gap2CellFilled}, gap1CellBottomFilled: ${gap1CellBottomFilled}`);
            
            if (!gap2CellFilled || !gap1CellBottomFilled) {
                console.log('Left bulb path not built - required gaps not filled');
                return path;
            }
            
            // Start at battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            path.push({ x: batteryTopPos.x, y: batteryTopPos.y - gameState.cellSize * 0.5, isTerminal: true });
            
            // Path: battery → (1,4) → (2,4) → gaps (3,4)-(4,4) → (5,4) → (6,4) → (6,5) → (6,6) → bulb1 → (6,8) → (6,9) → (6,10) → back to battery
            const positions = [
                [1, 4], [2, 4], [3, 4], [4, 4], [5, 4], [6, 4]
            ];
            
            positions.forEach(([x, y]) => {
                const pos = gridToWorld(x, y);
                path.push({ x: pos.x, y: pos.y, isWire: true });
            });
            
            // Branch down to bulb 1 at (5,6)
            const pos6_5 = gridToWorld(6, 5);
            path.push({ x: pos6_5.x, y: pos6_5.y, isWire: true });
            
            const pos6_6 = gridToWorld(6, 6);
            path.push({ x: pos6_6.x, y: pos6_6.y, isWire: true });
            
            const bulb1CenterPos = gridToWorld(gameState.bulbs[0].x + 1, gameState.bulbs[0].y + 1);
            path.push({ x: bulb1CenterPos.x, y: bulb1CenterPos.y, isBulb: true });
            
            // Return path from bulb 1
            const pos6_8 = gridToWorld(6, 8);
            path.push({ x: pos6_8.x, y: pos6_8.y, isWire: true });
            
            const pos6_9 = gridToWorld(6, 9);
            path.push({ x: pos6_9.x, y: pos6_9.y, isWire: true });
            
            const pos6_10 = gridToWorld(6, 10);
            path.push({ x: pos6_10.x, y: pos6_10.y, isWire: true });
            
            // Back to battery through bottom wire and 1-cell gap
            const returnPositions = [
                [5, 10], [4, 10], [3, 10], [2, 10], [1, 10]
            ];
            
            returnPositions.forEach(([x, y]) => {
                const pos = gridToWorld(x, y);
                path.push({ x: pos.x, y: pos.y, isWire: true });
            });
            
            // Battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            path.push({ x: batteryBottomPos.x, y: batteryBottomPos.y + gameState.cellSize * 0.5, isTerminal: true });
            
            console.log(`Fifth left bulb path built with ${path.length} points`);
            return path;
        }

        function buildFifthRightBulbPath() {
            const path = [];
            
            // Only build path for bulb 2 (top right) if it's lit
            if (!gameState.bulbs || !gameState.bulbs[1] || !gameState.bulbs[1].isLit) {
                console.log('Bulb 2 path not built - bulb not lit');
                return path;
            }
            
            // Check if all gaps are filled (required for bulbs 2 and 3)
            const gap2CellFilled = isConductive(3, 4) && isConductive(4, 4);
            const gap1CellFilled = isConductive(3, 10);
            const gap3CellVerticalFilled = isConductive(12, 6) && isConductive(12, 7) && isConductive(12, 8);
            
            if (!gap2CellFilled || !gap1CellFilled || !gap3CellVerticalFilled) {
                console.log('Bulb 2 path not built - not all gaps filled');
                return path;
            }
            
            // Start at battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            path.push({ x: batteryTopPos.x, y: batteryTopPos.y - gameState.cellSize * 0.5, isTerminal: true });
            
            // Path to bulb 2: battery → (1,4) → (2,4) → gaps (3,4)-(4,4) → (5,4) → (6,4) → (7,4) → (8,4) → (9,4) → (9,3) → bulb2
            const topPositions = [
                [1, 4], [2, 4], [3, 4], [4, 4], [5, 4], [6, 4], [7, 4], [8, 4], [9, 4]
            ];
            
            topPositions.forEach(([x, y]) => {
                const pos = gridToWorld(x, y);
                path.push({ x: pos.x, y: pos.y, isWire: true });
            });
            
            // Branch up to bulb 2 (top right at 8,3)
            const pos9_3 = gridToWorld(9, 3);
            path.push({ x: pos9_3.x, y: pos9_3.y, isWire: true });
            
            const bulb2CenterPos = gridToWorld(gameState.bulbs[1].x + 1, gameState.bulbs[1].y + 1);
            path.push({ x: bulb2CenterPos.x, y: bulb2CenterPos.y, isBulb: true });
            
            // Return path: bulb2 → (9,3) → (9,4) → (10,4) → (11,4) → (12,4) → (12,5) → through vertical gap → (12,9) → (12,10) → back to battery
            path.push({ x: pos9_3.x, y: pos9_3.y, isWire: true });
            
            const returnPositions = [
                [9, 4], [10, 4], [11, 4], [12, 4], [12, 5], [12, 6], [12, 7], [12, 8], [12, 9], [12, 10],
                [11, 10], [10, 10], [9, 10], [8, 10], [7, 10], [6, 10], [5, 10], [4, 10], [3, 10], [2, 10], [1, 10]
            ];
            
            returnPositions.forEach(([x, y]) => {
                const pos = gridToWorld(x, y);
                path.push({ x: pos.x, y: pos.y, isWire: true });
            });
            
            // Battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            path.push({ x: batteryBottomPos.x, y: batteryBottomPos.y + gameState.cellSize * 0.5, isTerminal: true });
            
            console.log(`Fifth bulb 2 path built with ${path.length} points`);
            return path;
        }

        function buildFifthThirdBulbPath() {
            const path = [];
            
            // Only build path for bulb 3 (bottom right) if it's lit
            if (!gameState.bulbs || !gameState.bulbs[2] || !gameState.bulbs[2].isLit) {
                console.log('Bulb 3 path not built - bulb not lit');
                return path;
            }
            
            // Check if all gaps are filled (required for bulbs 2 and 3)
            const gap2CellFilled = isConductive(3, 4) && isConductive(4, 4);
            const gap1CellFilled = isConductive(3, 10);
            const gap3CellVerticalFilled = isConductive(12, 6) && isConductive(12, 7) && isConductive(12, 8);
            
            if (!gap2CellFilled || !gap1CellFilled || !gap3CellVerticalFilled) {
                console.log('Bulb 3 path not built - not all gaps filled');
                return path;
            }
            
            // Start at battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            path.push({ x: batteryTopPos.x, y: batteryTopPos.y - gameState.cellSize * 0.5, isTerminal: true });
            
            // Path to bulb 3: battery → top wire → right side → through vertical gap → bulb3
            const topPositions = [
                [1, 4], [2, 4], [3, 4], [4, 4], [5, 4], [6, 4], [7, 4], [8, 4], [9, 4], [10, 4], [11, 4], [12, 4]
            ];
            
            topPositions.forEach(([x, y]) => {
                const pos = gridToWorld(x, y);
                path.push({ x: pos.x, y: pos.y, isWire: true });
            });
            
            // Down the right side through vertical gap
            const rightVerticalPositions = [
                [12, 5], [12, 6], [12, 7], [12, 8], [12, 9], [12, 10]
            ];
            
            rightVerticalPositions.forEach(([x, y]) => {
                const pos = gridToWorld(x, y);
                path.push({ x: pos.x, y: pos.y, isWire: true });
            });
            
            // To bulb 3 (bottom right at 8,9)
            const bottomRightPositions = [
                [11, 10], [10, 10]
            ];
            
            bottomRightPositions.forEach(([x, y]) => {
                const pos = gridToWorld(x, y);
                path.push({ x: pos.x, y: pos.y, isWire: true });
            });
            
            const bulb3CenterPos = gridToWorld(gameState.bulbs[2].x + 1, gameState.bulbs[2].y + 1);
            path.push({ x: bulb3CenterPos.x, y: bulb3CenterPos.y, isBulb: true });
            
            // Return path: bulb3 → back to battery
            const bottomLeftPositions = [
                [7, 10], [6, 10], [5, 10], [4, 10], [3, 10], [2, 10], [1, 10]
            ];
            
            bottomLeftPositions.forEach(([x, y]) => {
                const pos = gridToWorld(x, y);
                path.push({ x: pos.x, y: pos.y, isWire: true });
            });
            
            // Battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            path.push({ x: batteryBottomPos.x, y: batteryBottomPos.y + gameState.cellSize * 0.5, isTerminal: true });
            
            console.log(`Fifth bulb 3 path built with ${path.length} points`);
            return path;
        }

        function calculatePathDistance(path) {
            let totalDistance = 0;
            
            for (let i = 1; i < path.length; i++) {
                const prev = path[i - 1];
                const curr = path[i];
                const distance = Math.sqrt(
                    Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)
                );
                totalDistance += distance;
            }
            
            return totalDistance;
        }

        function calculatePathLength(path) {
            let totalLength = 0;
            for (let i = 1; i < path.length; i++) {
                const prev = path[i - 1];
                const curr = path[i];
                totalLength += Math.sqrt(
                    Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)
                );
            }
            return totalLength;
        }

        function getPositionAtDistance(path, targetDistance) {
            let currentDistance = 0;
            
            for (let i = 1; i < path.length; i++) {
                const prev = path[i - 1];
                const curr = path[i];
                const segmentDistance = Math.sqrt(
                    Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)
                );
                
                if (currentDistance + segmentDistance >= targetDistance) {
                    // The target distance is within this segment
                    const remainingDistance = targetDistance - currentDistance;
                    const ratio = remainingDistance / segmentDistance;
                    
                    return {
                        x: prev.x + (curr.x - prev.x) * ratio,
                        y: prev.y + (curr.y - prev.y) * ratio
                    };
                }
                
                currentDistance += segmentDistance;
            }
            
            // If we've gone past the end, return the last position
            return path[path.length - 1];
        }

        function startPulsatingChainAnimation(particles, circuitPath) {
            console.log(`Starting pulsating animation for ${particles.length} particles`);
            
            // Create synchronized pulsating effect for all particles
            particles.forEach(({ particle, glow }, index) => {
                console.log(`Setting up pulsing for particle ${index}`);
                
                // Pulsating scale animation
                scene.tweens.add({
                    targets: [particle, glow],
                    scaleX: 1.5,
                    scaleY: 1.5,
                    duration: 600,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
                
                // Pulsating alpha animation for extra effect
                scene.tweens.add({
                    targets: particle,
                    alpha: 0.6,
                    duration: 800,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            });
            
            // Start movement animation after a brief delay to see pulsing first
            setTimeout(() => {
                console.log('Starting movement animation...');
                console.log('Circuit path for movement:', circuitPath.length, 'points');
                const isLit = (gameState.bulb && gameState.bulb.isLit) || 
                             (gameState.bulbs && gameState.bulbs.some(bulb => bulb.isLit));
                console.log('isLit:', isLit);
                console.log('gameState.circuitState:', gameState.circuitState);
                animateLinearMovement(particles, circuitPath);
            }, 1000);
        }

        function animateLinearMovement(particles, circuitPath) {
            // Allow animation for both normal circuits (bulb lit) and short circuits
            const isLit = (gameState.bulb && gameState.bulb.isLit) || 
                         (gameState.bulbs && gameState.bulbs.some(bulb => bulb.isLit));
            console.log('animateLinearMovement called - isLit:', isLit, 'circuitState:', gameState.circuitState);
            
            if (!isLit && gameState.circuitState !== 'short_circuit') {
                console.log('Skipping linear movement - conditions not met');
                return;
            }
            
            console.log('Starting circuit flow animation');
            console.log('Circuit path length:', circuitPath.length);
            console.log('First few path points:', circuitPath.slice(0, 5));
            
            // Now implement proper circuit flow since basic movement works
            particles.forEach((particleData, index) => {
                const { particle, glow, circuitPath: particlePath } = particleData;
                const pathToUse = particlePath || circuitPath; // Use particle's specific path if available
                console.log(`Starting circuit flow for particle ${index} with path length ${pathToUse.length}`);
                animateParticleAroundCircuit(particle, glow, pathToUse, index);
            });
        }

        function animateParticleAroundCircuit(particle, glow, circuitPath, particleIndex) {
            console.log(`animateParticleAroundCircuit called for particle ${particleIndex}`);
            const isLit = (gameState.bulb && gameState.bulb.isLit) || 
                         (gameState.bulbs && gameState.bulbs.some(bulb => bulb.isLit));
            console.log('Conditions - isLit:', isLit, 'circuitState:', gameState.circuitState, 'particle.active:', particle.active, 'pathLength:', circuitPath.length);
            
            if ((!isLit && gameState.circuitState !== 'short_circuit') || !particle.active || circuitPath.length === 0) {
                console.log('Cannot animate particle', particleIndex, '- conditions not met');
                return;
            }
            
            console.log(`Animating particle ${particleIndex} around circuit`);
            
            // Find the closest path point to the particle's current position to maintain spacing
            let currentPathIndex = 0;
            let minDistance = Infinity;
            
            for (let i = 0; i < circuitPath.length; i++) {
                const pathPoint = circuitPath[i];
                const distance = Math.sqrt(
                    Math.pow(particle.x - pathPoint.x, 2) + 
                    Math.pow(particle.y - pathPoint.y, 2)
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    currentPathIndex = i;
                }
            }
            
            console.log(`Particle ${particleIndex} starting from path index ${currentPathIndex}`);
            
            const animationSpeed = 300; // milliseconds per path segment
            
            const moveToNextPoint = () => {
                // Allow animation for both normal circuits (bulb lit) and short circuits
                const isLit = (gameState.bulb && gameState.bulb.isLit) || 
                             (gameState.bulbs && gameState.bulbs.some(bulb => bulb.isLit));
                if ((!isLit && gameState.circuitState !== 'short_circuit') || !particle.active) {
                    console.log('Stopping animation - circuit incomplete');
                    return;
                }
                
                // Move to next point in circuit
                currentPathIndex = (currentPathIndex + 1) % circuitPath.length;
                const nextPoint = circuitPath[currentPathIndex];
                
                console.log(`Moving particle ${particleIndex} to point ${currentPathIndex}:`, nextPoint);
                
                // Check for large jumps that indicate wrapping (distance > 2 cells)
                const currentPos = { x: particle.x, y: particle.y };
                const jumpDistance = Math.sqrt(
                    Math.pow(nextPoint.x - currentPos.x, 2) + 
                    Math.pow(nextPoint.y - currentPos.y, 2)
                );
                const maxNormalDistance = gameState.cellSize * 2; // 2 cells max for normal movement
                
                if (jumpDistance > maxNormalDistance) {
                    console.log(`Detected large jump (${Math.round(jumpDistance)}px > ${maxNormalDistance}px) - using fade transition`);
                    
                    // Fade out at current position
                    scene.tweens.add({
                        targets: [particle, glow],
                        alpha: 0,
                        duration: animationSpeed / 2,
                        ease: 'Linear',
                        onComplete: () => {
                            // Move to new position instantly
                            particle.x = nextPoint.x;
                            particle.y = nextPoint.y;
                            glow.x = nextPoint.x;
                            glow.y = nextPoint.y;
                            
                            // Fade back in at new position
                            scene.tweens.add({
                                targets: [particle, glow],
                                alpha: 1,
                                duration: animationSpeed / 2,
                                ease: 'Linear',
                                onComplete: () => {
                                    // Continue to next point
                                    moveToNextPoint();
                                }
                            });
                        }
                    });
                } else {
                    // Normal smooth movement for adjacent points
                    scene.tweens.add({
                        targets: [particle, glow],
                        x: nextPoint.x,
                        y: nextPoint.y,
                        duration: animationSpeed,
                        ease: 'Linear',
                        onComplete: () => {
                            // Continue to next point immediately for smooth flow
                            moveToNextPoint();
                        }
                    });
                }
            };
            
            // Start the animation
            moveToNextPoint();
        }



        function getActualCircuitPath() {
            // Return the path from positive terminal through both wires to negative terminal
            const path = [];
            
            // Top wire (positive path) - from battery to bulb
            const topY = 4; // Row 4 is top wire
            for (let x = 3; x <= 11; x++) {
                if (isConductive(x, topY)) {
                    path.push({x: x, y: topY});
                }
            }
            
            // Through the bulb (if both vertical wire connections are conductive)
            if (isConductive(12, 5) && isConductive(12, 9)) {
                path.push({x: gameState.bulb.x + 1, y: gameState.bulb.y + 1}); // Bulb center (3x3)
            }
            
            // Bottom wire (negative path) - from bulb back to battery
            const bottomY = 10; // Row 10 is bottom wire
            for (let x = 11; x >= 3; x--) {
                if (isConductive(x, bottomY)) {
                    path.push({x: x, y: bottomY});
                }
            }
            
            return path;
        }

        function getCircuitAnalysis() {
            const analysis = {
                gapsFilled: 0,
                totalGaps: gameState.gaps.length,
                conductorsPlaced: 0,
                insulatorsPlaced: 0,
                placedItems: []
            };
            
            gameState.gaps.forEach(gap => {
                if (gap.filled) {
                    analysis.gapsFilled++;
                    const item = getGridPosition(gap.x, gap.y);
                    if (item && typeof item === 'object') {
                        analysis.placedItems.push({
                            name: item.name,
                            type: item.type,
                            conductive: item.conductive,
                            position: {x: gap.x, y: gap.y}
                        });
                        
                        if (item.conductive) {
                            analysis.conductorsPlaced++;
                        } else {
                            analysis.insulatorsPlaced++;
                        }
                    }
                }
            });
            
            return analysis;
        }

        function showFeedback(message, type = 'info') {
            const feedbackArea = document.getElementById('feedback-area');
            feedbackArea.textContent = message;
            feedbackArea.className = `feedback-${type}`;
            
            // Add pulse animation for important feedback
            if (type === 'success' || type === 'error') {
                feedbackArea.style.animation = 'pulse 0.5s ease-in-out';
                setTimeout(() => {
                    feedbackArea.style.animation = '';
                }, 500);
            }
        }

        // Button event handlers
        document.getElementById('test-circuit-btn').addEventListener('click', function() {
            console.log('Testing circuit...');
            
            // Disable button during testing
            this.disabled = true;
            this.textContent = '⚡ Testing...';
            
            const analysis = getCircuitAnalysis();
            console.log('Circuit analysis:', analysis);
            
            setTimeout(() => {
                const isComplete = evaluateCircuit();
                
                // Check if any bulb is lit (for Stage 4 partial completion)
                const anyBulbLit = (gameState.bulb && gameState.bulb.isLit) || 
                                  (gameState.bulbs && gameState.bulbs.some(bulb => bulb.isLit));
                
                if (isComplete) {
                    console.log('Circuit is complete - showing success flow and modal');
                    showFeedback('🎉 Circuit Complete! Electricity is flowing!', 'success');
                    
                    // Show current flow animation
                    visualizeCurrentFlow(true);
                    
                    // Show success modal after animation
                    setTimeout(() => {
                        console.log('Showing success modal');
                        showSuccessModal();
                    }, 1500);
                } else if (anyBulbLit && (gameState.currentLayout === 'fourth' || gameState.currentLayout === 'fifth')) {
                    // Stage 4 & 5: Show flow visualization even if not all bulbs are lit
                    console.log('Stage 4/5 partial completion - showing flow for lit bulbs');
                    showFeedback('⚡ Partial Circuit! Some bulbs are working. Fill more gaps to light all bulbs!', 'info');
                    
                    // Show current flow animation for lit bulbs
                    visualizeCurrentFlow(true);
                } else {
                    // Check if it's a short circuit (handled by evaluateCircuit)
                    if (gameState.circuitState === 'short_circuit') {
                        console.log('Short circuit detected - showing error feedback');
                        showFeedback('⚠️ Short Circuit Detected! Check the warning for details.', 'error');
                        // Current flow animation is already handled in evaluateCircuit
                    } else {
                        // Stop any current flow animation
                        visualizeCurrentFlow(false);
                        
                        // Provide specific feedback about why circuit failed
                        let message = '';
                        if (analysis.gapsFilled === 0) {
                            message = '❌ No materials placed. Drag materials to the gaps!';
                        } else if (analysis.gapsFilled < analysis.totalGaps) {
                            message = `❌ Try filling more gaps to complete the circuit.`;
                        } else {
                            message = '❌ Some materials are blocking electricity. Try different materials.';
                        }
                        showFeedback(message, 'error');
                    }
                }
                
                // Re-enable button
                this.disabled = false;
                this.textContent = '⚡ Test Circuit';
            }, 500); // Small delay for better UX
        });

        document.getElementById('reset-btn').addEventListener('click', function() {
            console.log('Reset button clicked - functionality will be added later');
        });

        // Stage selector menu functionality
        const stageMenuBtn = document.getElementById('stage-menu-btn');
        const stageSelector = document.getElementById('stage-selector');
        const stageOptions = document.querySelectorAll('.stage-option');
        
        // Toggle stage selector menu
        stageMenuBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            const isVisible = stageSelector.style.display === 'block';
            stageSelector.style.display = isVisible ? 'none' : 'block';
        });
        
        // Close menu when clicking outside
        document.addEventListener('click', function(e) {
            if (!stageSelector.contains(e.target) && e.target !== stageMenuBtn) {
                stageSelector.style.display = 'none';
            }
        });
        
        // Handle stage selection
        stageOptions.forEach(option => {
            option.addEventListener('click', function() {
                const selectedStage = this.dataset.stage;
                
                // Update active state
                stageOptions.forEach(opt => opt.classList.remove('active'));
                this.classList.add('active');
                
                // Load the selected stage
                loadCircuitLayout(selectedStage);
                
                // Close the menu
                stageSelector.style.display = 'none';
                
                console.log('Switched to stage:', selectedStage);
            });
        });
        
        // Function to update stage selector UI when stage changes programmatically
        function updateStageSelector(stageName) {
            const stageOptions = document.querySelectorAll('.stage-option');
            stageOptions.forEach(option => {
                if (option.dataset.stage === stageName) {
                    option.classList.add('active');
                } else {
                    option.classList.remove('active');
                }
            });
        }
        
        function updateStageTitle(stageName) {
            const stageTitle = document.getElementById('stage-title');
            if (stageTitle) {
                switch(stageName) {
                    case 'first':
                        stageTitle.textContent = 'Stage 1: Basic Circuit';
                        break;
                    case 'second':
                        stageTitle.textContent = 'Stage 2: Short Circuit';
                        break;
                    case 'third':
                        stageTitle.textContent = 'Stage 3: Series Circuit';
                        break;
                    case 'fourth':
                        stageTitle.textContent = 'Stage 4: Parallel Circuit';
                        break;
                    case 'fifth':
                        stageTitle.textContent = 'Stage 5: Series-Parallel Circuit';
                        break;
                    default:
                        stageTitle.textContent = 'Circuit Game';
                }
            }
        }

        function updateSuccessActions() {
            const successActions = document.getElementById('success-actions');
            
            // Clear existing buttons
            successActions.innerHTML = '';
            
            // Always add Try Again button
            const tryAgainBtn = document.createElement('button');
            tryAgainBtn.id = 'play-again-btn';
            tryAgainBtn.innerHTML = '🔄 Try Again';
            tryAgainBtn.addEventListener('click', function() {
                hideSuccessModal();
                resetCurrentStage();
            });
            successActions.appendChild(tryAgainBtn);
            
            // Add stage-specific buttons
            if (gameState.currentLayout === 'first') {
                // Stage 1: Add "Next Stage" button to go to Stage 2
                const nextStageBtn = document.createElement('button');
                nextStageBtn.id = 'next-stage-btn';
                nextStageBtn.innerHTML = '➡️ Next Stage';
                nextStageBtn.addEventListener('click', function() {
                    hideSuccessModal();
                    loadCircuitLayout('second');
                });
                successActions.appendChild(nextStageBtn);
            } else if (gameState.currentLayout === 'second') {
                // Stage 2: Add "Next Stage" button to go to Stage 3
                const nextStageBtn = document.createElement('button');
                nextStageBtn.id = 'next-stage-btn';
                nextStageBtn.innerHTML = '➡️ Next Stage';
                nextStageBtn.addEventListener('click', function() {
                    hideSuccessModal();
                    loadCircuitLayout('third');
                });
                successActions.appendChild(nextStageBtn);
            } else if (gameState.currentLayout === 'third') {
                // Stage 3: Add "Next Stage" button to go to Stage 4
                const nextStageBtn = document.createElement('button');
                nextStageBtn.id = 'next-stage-btn';
                nextStageBtn.innerHTML = '➡️ Next Stage';
                nextStageBtn.addEventListener('click', function() {
                    hideSuccessModal();
                    loadCircuitLayout('fourth');
                });
                successActions.appendChild(nextStageBtn);
            } else if (gameState.currentLayout === 'fourth') {
                // Stage 4: Add "Next Stage" button to go to Stage 5
                const nextStageBtn = document.createElement('button');
                nextStageBtn.innerHTML = '➡️ Next Stage';
                nextStageBtn.addEventListener('click', function() {
                    hideSuccessModal();
                    loadCircuitLayout('fifth');
                });
                successActions.appendChild(nextStageBtn);
            } else if (gameState.currentLayout === 'fifth') {
                // Stage 5: Add educational completion message
                const completionBtn = document.createElement('button');
                completionBtn.id = 'completion-btn';
                completionBtn.innerHTML = '🎓 Game Complete!';
                completionBtn.addEventListener('click', function() {
                    hideSuccessModal();
                    resetCurrentStage();
                });
                successActions.appendChild(completionBtn);
            }
        }

        function showSuccessModal() {
            console.log('=== SHOWING SUCCESS MODAL ===');
            
            // Get the modal elements
            const modal = document.getElementById('success-modal');
            const content = document.getElementById('success-content');
            
            // Determine the stage title
            let stageTitle = '🎉 Excellent Work!';
            if (gameState.currentLayout === 'first') {
                stageTitle = '🎉 Excellent Work! - Stage 1 Complete';
            } else if (gameState.currentLayout === 'second') {
                stageTitle = '🎉 Excellent Work! - Stage 2 Complete';
            } else if (gameState.currentLayout === 'third') {
                stageTitle = '🎉 Excellent Work! - Stage 3 Complete';
            } else if (gameState.currentLayout === 'fourth') {
                stageTitle = '🎉 Excellent Work! - Stage 4 Complete';
            } else if (gameState.currentLayout === 'fifth') {
                stageTitle = '🎉 Excellent Work! - Stage 5 Complete';
            }
            
            // Recreate the success modal content structure to ensure it exists
            // Determine if we should use singular or plural for light bulbs
            const isMultipleBulbs = (gameState.currentLayout === 'third' || gameState.currentLayout === 'fourth' || gameState.currentLayout === 'fifth');
            const bulbText = isMultipleBulbs ? 'light bulbs are glowing' : 'light bulb is glowing';
            const bulbExplanation = isMultipleBulbs ? 'light bulbs (making them glow)' : 'light bulb (making it glow)';
            
            content.innerHTML = `
                <h2>${stageTitle}</h2>
                <div id="success-details">
                    <p><strong>You completed the electrical circuit!</strong></p>
                    <p>The ${bulbText} because:</p>
                    <ul id="success-explanation">
                        <li>✅ Electricity flows from the battery's positive (+) terminal</li>
                        <li>✅ Through the <span class="conductor-text">conductors</span> you placed</li>
                        <li>✅ Through the ${bulbExplanation}</li>
                        <li>✅ Back to the battery's negative (-) terminal</li>
                    </ul>
                    <div id="materials-used">
                        <!-- Will be populated by JavaScript -->
                    </div>
                </div>
                <div id="success-actions">
                    <!-- Will be populated by JavaScript -->
                </div>
            `;
            
            // Get analysis of what materials were used
            const analysis = getCircuitAnalysis();
            
            // Populate materials used section with enhanced educational content
            const materialsDiv = document.getElementById('materials-used');
            let materialsHTML = '<h4>🔧 Materials You Used:</h4>';
            
            if (analysis.placedItems.length > 0) {
                materialsHTML += '<ul>';
                analysis.placedItems.forEach(item => {
                    const conductorClass = item.conductive ? 'conductor-text' : 'insulator-text';
                    const conductorType = item.conductive ? 'CONDUCTOR' : 'INSULATOR';
                    const explanation = item.conductive ? 
                        'allows electricity to flow through it easily!' : 
                        'blocks electricity from flowing through it.';
                    
                    materialsHTML += `<li><strong>${item.name}</strong> - <span class="${conductorClass}">${conductorType}</span> that ${explanation}</li>`;
                });
                materialsHTML += '</ul>';
                
                if (analysis.conductorsPlaced > 0) {
                    if (gameState.currentLayout === 'second') {
                        // For Stage 2, show both conductors and insulators
                        const insulatorsPlaced = analysis.placedItems.filter(item => !item.conductive).length;
                        materialsHTML += `<p><strong>🎯 Perfect!</strong> You used <span class="conductor-text">${analysis.conductorsPlaced} conductor(s)</span>`;
                        if (insulatorsPlaced > 0) {
                            materialsHTML += ` and <span class="insulator-text">${insulatorsPlaced} insulator(s)</span>`;
                        }
                        materialsHTML += ` to complete the electrical circuit!</p>`;
                    } else {
                        // For Stage 1, keep original format
                        materialsHTML += `<p><strong>🎯 Perfect!</strong> You used <span class="conductor-text">${analysis.conductorsPlaced} conductor(s)</span> to complete the electrical circuit!</p>`;
                    }
                }
                
                // Add educational explanation (only for Stage 1, other stages have their own sections)
                if (gameState.currentLayout === 'first') {
                    materialsHTML += `<p><strong>💡 What you learned:</strong> Conductors like metals allow electricity to flow, while insulators like rubber and wood block it. That's why the light bulb glows when you use conductive materials!</p>`;
                }
            } else {
                materialsHTML += '<p>No materials were needed - the circuit was already complete!</p>';
            }
            
            // Add stage-specific educational content
            if (gameState.currentLayout === 'second') {
                // Stage 2 educational content about short circuits and parallel circuits
                materialsHTML += `
                    <div style="margin-top: 20px; padding: 15px; background-color: #E8F5E8; border-radius: 8px; border-left: 4px solid #4CAF50;">
                        <h4 style="color: #2E7D32; margin-bottom: 12px;">🎓 What You Learned:</h4>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>Parallel Circuits:</strong> In this stage, you built a parallel circuit where electricity can flow through multiple paths. Even if one path is blocked, electricity can still flow through other paths!</p>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>Short Circuits:</strong> A short circuit happens when electricity takes an unintended shortcut path instead of going where we want it to go.</p>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>Why are they dangerous?</strong> Short circuits can be dangerous because they allow too much electricity to flow too quickly. In real life, this can damage equipment or even cause fires!</p>
                        
                        <p style="margin-bottom: 0; color: #333; line-height: 1.4;"><strong>Safety Tips:</strong></p>
                        <ul style="margin: 5px 0 0 20px; color: #333; line-height: 1.4;">
                            <li>Inspect wires for any damages/uninsulated areas.</li>
                            <li>Make use of electrical protective devices such as fuses and circuit breakers which immediately cut off electricity when short circuits happen.</li>
                        </ul>
                    </div>
                `;
            } else if (gameState.currentLayout === 'third') {
                // Stage 3 educational content about series circuits
                materialsHTML += `
                    <div style="margin-top: 20px; padding: 15px; background-color: #E8F5E8; border-radius: 8px; border-left: 4px solid #4CAF50;">
                        <h4 style="color: #2E7D32; margin-bottom: 12px;">🎓 What You Learned About Series Circuits:</h4>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>🔗 What is a Series Circuit?</strong> A series circuit connects components one after another in a single chain. Think of it like a chain where if one link breaks, the whole chain fails!</p>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>⚡ How it Works:</strong> Electricity must flow through ALL components in order. If any part is missing or broken, the entire circuit stops working and both light bulbs turn off.</p>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>🎄 Real-World Examples:</strong></p>
                        <ul style="margin: 5px 0 10px 20px; color: #333; line-height: 1.4;">
                            <li>Old Christmas lights (when one bulb burns out, they all go dark!)</li>
                            <li>Flashlights (battery → switch → bulb in a single path)</li>
                            <li>Some car headlights</li>
                        </ul>
                        

                        
                        <p style="margin-bottom: 0; color: #333; line-height: 1.4;"><strong>🔧 Key Lesson:</strong> All parts must work together for the circuit to function - just like teamwork!</p>
                    </div>
                `;
            } else if (gameState.currentLayout === 'fourth') {
                // Stage 4 educational content about parallel circuits
                materialsHTML += `
                    <div style="margin-top: 20px; padding: 15px; background-color: #E8F5E8; border-radius: 8px; border-left: 4px solid #4CAF50;">
                        <h4 style="color: #2E7D32; margin-bottom: 12px;">🎓 What You Learned About Parallel Circuits:</h4>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>⚡ What is a Parallel Circuit?</strong> A parallel circuit creates multiple paths for electricity to flow. Think of it like a river that splits into different streams - the water can flow through any or all of the paths!</p>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>🔀 How it Works:</strong> Electricity can flow through multiple paths at the same time. If one path is blocked, electricity can still flow through the other paths, so some bulbs can stay lit even if others go out.</p>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>💡 Key Advantages:</strong></p>
                        <ul style="margin: 5px 0 10px 20px; color: #333; line-height: 1.4;">
                            <li>Each bulb can be controlled independently</li>
                            <li>If one bulb burns out, the others keep working</li>
                            <li>Each bulb gets the full voltage from the battery</li>
                        </ul>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>🏠 Real-World Examples:</strong></p>
                        <ul style="margin: 5px 0 10px 20px; color: #333; line-height: 1.4;">
                            <li>House lights (each room can be turned on/off separately)</li>
                            <li>Car headlights (both work independently)</li>
                            <li>Modern Christmas lights (one bulb out doesn't affect others)</li>
                        </ul>
                        
                        <p style="margin-bottom: 0; color: #333; line-height: 1.4;"><strong>🔧 Key Lesson:</strong> Parallel circuits provide backup paths - if one route fails, electricity finds another way!</p>
                    </div>
                `;
            } else if (gameState.currentLayout === 'fifth') {
                // Stage 5 educational content about series-parallel circuits
                materialsHTML += `
                    <div style="margin-top: 20px; padding: 15px; background-color: #E8F5E8; border-radius: 8px; border-left: 4px solid #4CAF50;">
                        <h4 style="color: #2E7D32; margin-bottom: 12px;">🎓 What You Learned About Series-Parallel Circuits:</h4>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>🔀 What is a Series-Parallel Circuit?</strong> A series-parallel circuit combines both types of connections! Some parts are connected in series (one after another), while other parts are connected in parallel (side by side with multiple paths).</p>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>🧩 How it Works in This Stage:</strong></p>
                        <ul style="margin: 5px 0 10px 20px; color: #333; line-height: 1.4;">
                            <li><strong>Left bulb:</strong> Connected in series - needs both the 2-cell gap AND the 1-cell gap filled</li>
                            <li><strong>Right bulbs:</strong> Connected in parallel - both light up when the vertical 3-cell gap is filled</li>
                        </ul>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>⚡ Key Concepts:</strong></p>
                        <ul style="margin: 5px 0 10px 20px; color: #333; line-height: 1.4;">
                            <li>Series parts must ALL work for electricity to flow through that path</li>
                            <li>Parallel parts can work independently of each other</li>
                            <li>You can control different groups of lights separately</li>
                        </ul>
                        
                        <p style="margin-bottom: 10px; color: #333; line-height: 1.4;"><strong>🏠 Real-World Examples:</strong></p>
                        <ul style="margin: 5px 0 10px 20px; color: #333; line-height: 1.4;">
                            <li>House wiring (main switch controls all, but each room has its own switches)</li>
                            <li>Car electrical system (ignition in series, but headlights and radio in parallel)</li>
                            <li>Computer circuits (some components must work together, others work independently)</li>
                        </ul>
                        
                        <p style="margin-bottom: 0; color: #333; line-height: 1.4;"><strong>🎯 Key Lesson:</strong> Series-parallel circuits give you the best of both worlds - you can have parts that must work together AND parts that work independently!</p>
                    </div>
                `;
            }
            
            materialsDiv.innerHTML = materialsHTML;
            
            // Update success actions based on current stage
            updateSuccessActions();
            
            // Add celebration visual effects
            addCelebrationEffects();
            
            // Show modal with animation
            const modalContent = content; // Reuse the content element we already have
            
            // Ensure modal content starts invisible and centered
            modalContent.style.opacity = '0';
            modalContent.style.transform = 'translate(-50%, -60%) scale(0.8)';
            
            modal.style.display = 'block';
            
            // Trigger animation after a brief delay to ensure proper positioning
            requestAnimationFrame(() => {
                modalContent.style.animation = 'slideIn 0.4s ease-out forwards';
            });
            
            // Add confetti effect to the page background
            setTimeout(() => {
                createConfettiEffect();
            }, 200);
            
            // Play success sound effect (if available)
            playSuccessSound();
        }

        function addCelebrationEffects() {
            // Create sparkle particles around the light bulb(s)
            const createSparklesForBulb = (bulbConfig, delay = 0) => {
                if (bulbConfig.sprite && bulbConfig.isLit) {
                    const bulbPos = gridToWorld(bulbConfig.x, bulbConfig.y);
                    
                    // Create multiple sparkle particles
                    for (let i = 0; i < 12; i++) {
                        setTimeout(() => {
                            const angle = (i / 12) * Math.PI * 2;
                            const distance = 40 + Math.random() * 20;
                            const sparkleX = bulbPos.x + Math.cos(angle) * distance;
                            const sparkleY = bulbPos.y + Math.sin(angle) * distance;
                            
                            const sparkle = scene.add.star(sparkleX, sparkleY, 5, 4, 8, 0xFFD700);
                            sparkle.setAlpha(1);
                            
                            // Animate sparkle
                            scene.tweens.add({
                                targets: sparkle,
                                scaleX: 0,
                                scaleY: 0,
                                alpha: 0,
                                rotation: Math.PI * 2,
                                duration: 1000,
                                ease: 'Power2',
                                onComplete: () => sparkle.destroy()
                            });
                        }, delay + i * 100);
                    }
                }
            };
            
            // Handle single bulb (Stage 1 & 2)
            if (gameState.bulb) {
                createSparklesForBulb(gameState.bulb);
            }
            
            // Handle dual bulbs (Stage 3)
            if (gameState.bulbs) {
                gameState.bulbs.forEach((bulb, index) => {
                    createSparklesForBulb(bulb, index * 200); // Stagger the sparkles
                });
            }
            
            // Add screen flash effect
            const flash = scene.add.rectangle(
                gameState.gridWidth * gameState.cellSize / 2,
                gameState.gridHeight * gameState.cellSize / 2,
                gameState.gridWidth * gameState.cellSize,
                gameState.gridHeight * gameState.cellSize,
                0xFFFFFF
            );
            flash.setAlpha(0.6);
            
            scene.tweens.add({
                targets: flash,
                alpha: 0,
                duration: 300,
                ease: 'Power2',
                onComplete: () => flash.destroy()
            });
        }
        
        function playSuccessSound() {
            // Create a simple success sound using Web Audio API
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create a simple success melody
                const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5
                
                frequencies.forEach((freq, index) => {
                    setTimeout(() => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                    }, index * 150);
                });
            } catch (error) {
                console.log('Audio not available:', error);
            }
        }

        // Success modal buttons are now handled dynamically in updateSuccessActions()

        // Add event listener for new challenge button
        document.addEventListener('DOMContentLoaded', function() {
            
            // Add click outside modal to close
            document.getElementById('success-modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideSuccessModal();
                }
            });
            
            // Add escape key to close modal
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('success-modal').style.display === 'block') {
                    hideSuccessModal();
                }
            });
        });
        
        function createConfettiEffect() {
            // Create colorful confetti particles that fall from the top
            const colors = [0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0xFFA07A, 0x98D8C8, 0xF7DC6F];
            
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const x = Math.random() * (gameState.gridWidth * gameState.cellSize);
                    const y = -20;
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    const confetti = scene.add.rectangle(x, y, 8, 8, color);
                    confetti.setRotation(Math.random() * Math.PI * 2);
                    
                    // Store confetti for cleanup
                    gameState.confettiParticles.push(confetti);
                    
                    // Animate falling confetti
                    scene.tweens.add({
                        targets: confetti,
                        y: gameState.gridHeight * gameState.cellSize + 50,
                        rotation: confetti.rotation + Math.PI * 4,
                        duration: 2000 + Math.random() * 1000,
                        ease: 'Power2',
                        onComplete: () => {
                            // Remove from tracking array when destroyed
                            const index = gameState.confettiParticles.indexOf(confetti);
                            if (index > -1) {
                                gameState.confettiParticles.splice(index, 1);
                            }
                            confetti.destroy();
                        }
                    });
                    
                    // Add side-to-side motion
                    scene.tweens.add({
                        targets: confetti,
                        x: x + (Math.random() - 0.5) * 100,
                        duration: 2000 + Math.random() * 1000,
                        ease: 'Sine.easeInOut',
                        yoyo: true,
                        repeat: 1
                    });
                }, i * 100);
            }
        }
        
        function hideSuccessModal() {
            const modal = document.getElementById('success-modal');
            const modalContent = document.getElementById('success-content');
            
            // Add fade out animation
            modalContent.style.animation = 'slideOut 0.3s ease-in';
            
            setTimeout(() => {
                modal.style.display = 'none';
                modalContent.style.animation = ''; // Reset animation
            }, 300);
        }

        function createNewChallenge() {
            // Reset the current game first
            resetGame();
            
            // Cycle through available circuit layouts
            const availableLayouts = Object.keys(gameState.circuitLayouts);
            const currentIndex = availableLayouts.indexOf(gameState.currentLayout);
            const nextIndex = (currentIndex + 1) % availableLayouts.length;
            const nextLayout = availableLayouts[nextIndex];
            
            // Load the next circuit layout
            loadCircuitLayout(nextLayout);
            
            // Show appropriate challenge message
            const challengeMessages = {
                first: [
                    '🔄 Back to the basics! Simple two-wire circuit.',
                    '⚡ Classic Circuit! Fill the gaps to complete the path.',
                    '🎯 Original Challenge! Connect battery to bulb.'
                ],
                second: [
                    '🆕 New Challenge! Complex circuit with T-junctions and multiple paths!',
                    '⚡ Fresh Circuit! Can you solve this advanced layout?',
                    '🎯 Challenge Mode! Navigate the T-shaped connectors!'
                ]
            };
            
            const messages = challengeMessages[nextLayout] || ['🆕 New Challenge! Try this circuit layout!'];
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            showFeedback(randomMessage, 'info');
            
            console.log('New challenge created with layout:', nextLayout);
        }



        function clearExistingComponents() {
            console.log('Clearing existing components...');
            
            // First, clear all placed items from the circuit (similar to resetGame logic)
            clearPlacedItems();
            
            // Clear all sprites from the scene more aggressively
            if (scene && scene.children) {
                const children = scene.children.list.slice(); // Create a copy to avoid modification during iteration
                children.forEach(child => {
                    // Skip the grid graphics (they should persist)
                    if (child && child.type !== 'Graphics' || (child.type === 'Graphics' && child.lineStyle)) {
                        try {
                            child.destroy();
                        } catch (error) {
                            console.warn('Error destroying child:', error);
                        }
                    }
                });
            }
            
            // Clear battery sprite
            if (gameState.battery && gameState.battery.sprite) {
                try {
                    gameState.battery.sprite.destroy();
                } catch (error) {
                    console.warn('Error destroying battery sprite:', error);
                }
                gameState.battery.sprite = null;
            }
            
            // Clear single bulb sprite and glow effect
            if (gameState.bulb && gameState.bulb.sprite) {
                try {
                    gameState.bulb.sprite.destroy();
                } catch (error) {
                    console.warn('Error destroying bulb sprite:', error);
                }
                gameState.bulb.sprite = null;
            }
            if (gameState.bulb && gameState.bulb.glowEffect) {
                try {
                    gameState.bulb.glowEffect.destroy();
                } catch (error) {
                    console.warn('Error destroying glow effect:', error);
                }
                gameState.bulb.glowEffect = null;
            }
            if (gameState.bulb && gameState.bulb.bulbSprite) {
                gameState.bulb.bulbSprite = null;
            }
            if (gameState.bulb) {
                gameState.bulb.isLit = false;
            }
            
            // Clear dual bulbs (Stage 3)
            if (gameState.bulbs) {
                gameState.bulbs.forEach(bulb => {
                    if (bulb.sprite) {
                        try {
                            bulb.sprite.destroy();
                        } catch (error) {
                            console.warn('Error destroying bulb sprite:', error);
                        }
                        bulb.sprite = null;
                    }
                    if (bulb.glowEffect) {
                        try {
                            bulb.glowEffect.destroy();
                        } catch (error) {
                            console.warn('Error destroying glow effect:', error);
                        }
                        bulb.glowEffect = null;
                    }
                    if (bulb.bulbSprite) {
                        bulb.bulbSprite = null;
                    }
                    bulb.isLit = false;
                });
            }
            
            // Clear existing gaps
            if (gameState.gaps) {
                gameState.gaps.forEach(gap => {
                    if (gap.sprite) {
                        try {
                            gap.sprite.destroy();
                        } catch (error) {
                            console.warn('Error destroying gap sprite:', error);
                        }
                        gap.sprite = null;
                    }
                });
            }
            
            // Clear existing preplaced wires
            if (gameState.preplacedWires) {
                gameState.preplacedWires.forEach(wire => {
                    if (wire.sprite) {
                        try {
                            wire.sprite.destroy();
                        } catch (error) {
                            console.warn('Error destroying wire sprite:', error);
                        }
                        wire.sprite = null;
                    }
                });
            }
            
            // Clear connection graphics
            if (gameState.connectionGraphics) {
                gameState.connectionGraphics.forEach(graphic => {
                    if (graphic) {
                        try {
                            graphic.destroy();
                        } catch (error) {
                            console.warn('Error destroying connection graphic:', error);
                        }
                    }
                });
                gameState.connectionGraphics = [];
            }
            
            // Clear flow visualization (red line indicators from short circuits)
            if (gameState.flowVisualization) {
                console.log('Clearing flow visualization during stage switch, count:', gameState.flowVisualization.length);
                gameState.flowVisualization.forEach(particle => {
                    // Clean up animation timers
                    if (particle.animationTimer) {
                        particle.animationTimer.destroy();
                    }
                    if (particle.destroy) particle.destroy();
                });
                gameState.flowVisualization = [];
            }
            
            // Reset circuit state to clear any short circuit conditions
            gameState.circuitState = 'incomplete';
            
            // Completely clear and reinitialize the grid
            clearGridCompletely();
            
            // Redraw the grid lines
            drawGrid();
            
            console.log('All components cleared');
        }
        
        function clearPlacedItems() {
            console.log('Clearing placed items...');
            
            // First, aggressively clean up all HTML elements that might be placed items
            const canvas = document.querySelector('canvas');
            if (canvas && canvas.parentElement) {
                const canvasContainer = canvas.parentElement;
                // Remove any HTML elements that look like placed items
                const itemElements = canvasContainer.querySelectorAll('div[style*="background-image"][style*="assets/items"]');
                console.log('Found', itemElements.length, 'HTML item elements to remove');
                itemElements.forEach(element => {
                    console.log('Removing HTML item element:', element);
                    element.remove();
                });
                
                // Also remove any absolutely positioned divs that might be items
                const absoluteElements = canvasContainer.querySelectorAll('div[style*="position: absolute"]');
                absoluteElements.forEach(element => {
                    // Check if it looks like an item (has background-image with assets/items)
                    if (element.style.backgroundImage && element.style.backgroundImage.includes('assets/items')) {
                        console.log('Removing absolute positioned item element:', element);
                        element.remove();
                    }
                });
            }
            
            // Remove all placed items from circuit by scanning the entire grid
            for (let y = 0; y < gameState.gridHeight; y++) {
                for (let x = 0; x < gameState.gridWidth; x++) {
                    const gridItem = gameState.grid[y][x];
                    // Only remove items that are actual placed items (not pre-placed components)
                    if (gridItem && typeof gridItem === 'object' && 
                        gridItem.inBank !== undefined && gridItem.placed === true) {
                        console.log('Removing placed item from grid:', gridItem.name, 'at', x, y);
                        
                        // Clear the grid position first
                        gameState.grid[y][x] = null;
                        
                        // Clean up HTML element if it exists
                        if (gridItem.sprite && gridItem.sprite.htmlElement) {
                            try {
                                gridItem.sprite.htmlElement.remove();
                            } catch (error) {
                                console.warn('Error removing HTML element:', error);
                            }
                        }
                        
                        // Destroy the sprite if it exists
                        if (gridItem.sprite) {
                            try {
                                if (gridItem.sprite.children && gridItem.sprite.children.entries) {
                                    gridItem.sprite.children.entries.forEach(child => {
                                        if (child) {
                                            child.setVisible(false);
                                            child.destroy();
                                        }
                                    });
                                }
                                if (gridItem.sprite.clear) {
                                    gridItem.sprite.clear(true, true);
                                }
                                gridItem.sprite.destroy();
                            } catch (error) {
                                console.warn('Error destroying sprite during cleanup:', error);
                            }
                            gridItem.sprite = null;
                            gridItem.mainSprite = null;
                        }
                        
                        // Reset item state completely
                        gridItem.inBank = true;
                        gridItem.placed = false;
                        gridItem.gridX = -1;
                        gridItem.gridY = -1;
                        gridItem.isDragging = false;
                        
                        // Clear any stored positions
                        gridItem.originalX = undefined;
                        gridItem.originalY = undefined;
                        gridItem.originalGridX = undefined;
                        gridItem.originalGridY = undefined;
                        
                        // Clean up any removal hints
                        if (gridItem.removalHint) {
                            gridItem.removalHint.destroy();
                            gridItem.removalHint = null;
                        }
                    }
                }
            }
            
            // Clear placed items array
            gameState.placedItems = [];
            console.log('Cleared placedItems array');
            
            // Reset circuit state to clear any short circuit indicators
            gameState.circuitState = 'incomplete';
            
            // Restore all items to original quantities in item bank
            gameState.itemBank.forEach(item => {
                // Reset item state to be in bank
                item.inBank = true;
                item.placed = false;
                item.gridX = -1;
                item.gridY = -1;
                item.isDragging = false;
                
                // Clear any stored positions
                item.originalX = undefined;
                item.originalY = undefined;
                item.originalGridX = undefined;
                item.originalGridY = undefined;
                
                // Show HTML element again with proper styling
                if (item.htmlElement) {
                    item.htmlElement.style.display = 'block';
                    item.htmlElement.style.opacity = '1';
                    item.htmlElement.style.transform = 'scale(1)';
                    item.htmlElement.style.position = 'relative';
                    item.htmlElement.style.left = '0px';
                    item.htmlElement.style.top = '0px';
                    item.htmlElement.style.zIndex = '1';
                }
            });
            
            console.log('All placed items cleared and item bank restored');
        }
        
        function clearGridCompletely() {
            // Clear all grid positions
            for (let y = 0; y < gameState.gridHeight; y++) {
                for (let x = 0; x < gameState.gridWidth; x++) {
                    gameState.grid[y][x] = null;
                }
            }
            console.log('Grid completely cleared');
        }
        
        function loadCircuitLayout(layoutName) {
            console.log('=== LOADING CIRCUIT LAYOUT:', layoutName, '===');
            console.log('Current placedItems before cleanup:', gameState.placedItems.length);
            console.log('Current grid state before cleanup - checking for placed items...');
            
            // Debug: Check current grid state
            let placedItemsInGrid = 0;
            for (let y = 0; y < gameState.gridHeight; y++) {
                for (let x = 0; x < gameState.gridWidth; x++) {
                    const gridItem = gameState.grid[y][x];
                    if (gridItem && typeof gridItem === 'object' && gridItem.inBank !== undefined && gridItem.placed === true) {
                        placedItemsInGrid++;
                        console.log('Found placed item in grid before cleanup:', gridItem.name, 'at', x, y);
                    }
                }
            }
            console.log('Total placed items found in grid before cleanup:', placedItemsInGrid);
            
            if (!gameState.circuitLayouts[layoutName]) {
                console.error('Circuit layout not found:', layoutName);
                return;
            }
            
            const layout = gameState.circuitLayouts[layoutName];
            
            // Clear everything first
            console.log('Starting clearExistingComponents...');
            clearExistingComponents();
            console.log('Finished clearExistingComponents');
            
            // Set current layout
            gameState.currentLayout = layoutName;
            
            // Update stage selector UI
            updateStageSelector(layoutName);
            
            // Update stage title display
            updateStageTitle(layoutName);
            
            // Clear feedback area
            const feedbackArea = document.getElementById('feedback-area');
            if (feedbackArea) {
                feedbackArea.textContent = 'Try different materials in the gaps to see which ones allow electricity to flow! Drag placed items away to remove them.';
                feedbackArea.className = ''; // Remove any success/error classes
            }
            
            // Close any open modals
            const successModal = document.getElementById('success-modal');
            if (successModal) {
                successModal.style.display = 'none';
            }
            
            // Load layout configuration
            gameState.battery = { ...layout.battery, sprite: null };
            
            // Handle single bulb (Stage 1 & 2) or dual bulbs (Stage 3)
            if (layout.bulbs) {
                // Stage 3: Multiple bulbs
                gameState.bulbs = layout.bulbs.map(bulb => ({ ...bulb, sprite: null }));
                gameState.bulb = null; // Clear single bulb for Stage 3
            } else {
                // Stage 1 & 2: Single bulb
                gameState.bulb = { ...layout.bulb, sprite: null, isLit: false };
                gameState.bulbs = null; // Clear multiple bulbs for Stage 1 & 2
            }
            
            gameState.gaps = layout.gaps.map(gap => ({ ...gap, sprite: null }));
            gameState.preplacedWires = layout.preplacedWires.map(wire => ({ ...wire, sprite: null }));
            
            // Recreate all components
            createCircuitComponents();
            
            // Update wire connections
            updateWireConnections();
            
            // Debug: Verify cleanup was successful
            console.log('=== CLEANUP VERIFICATION ===');
            console.log('PlacedItems after cleanup:', gameState.placedItems.length);
            let remainingPlacedItems = 0;
            for (let y = 0; y < gameState.gridHeight; y++) {
                for (let x = 0; x < gameState.gridWidth; x++) {
                    const gridItem = gameState.grid[y][x];
                    if (gridItem && typeof gridItem === 'object' && gridItem.inBank !== undefined && gridItem.placed === true) {
                        remainingPlacedItems++;
                        console.warn('CLEANUP FAILED: Found remaining placed item:', gridItem.name, 'at', x, y);
                    }
                }
            }
            console.log('Remaining placed items in grid after cleanup:', remainingPlacedItems);
            
            // Check for remaining HTML elements
            const canvas = document.querySelector('canvas');
            if (canvas && canvas.parentElement) {
                const remainingElements = canvas.parentElement.querySelectorAll('div[style*="background-image"][style*="assets/items"]');
                console.log('Remaining HTML item elements after cleanup:', remainingElements.length);
                if (remainingElements.length > 0) {
                    console.warn('CLEANUP FAILED: Found remaining HTML elements:', remainingElements);
                }
            }
            
            console.log('Circuit layout loaded:', layoutName);
        }

        function resetCurrentStage() {
            console.log('Starting current stage reset...');
            
            // Stop all active tweens to prevent yellow line indicators from persisting
            if (scene && scene.tweens) {
                scene.tweens.killAll();
            }
            
            // Clear any remaining confetti particles
            if (gameState.confettiParticles) {
                gameState.confettiParticles.forEach(confetti => {
                    if (confetti && confetti.destroy) {
                        confetti.destroy();
                    }
                });
                gameState.confettiParticles = [];
            }
            
            // Turn off dual bulbs immediately if they exist (Stage 4) to prevent yellow lines
            if (gameState.bulbs) {
                gameState.bulbs.forEach(bulb => {
                    bulb.isLit = false;
                    if (bulb.bulbSprite && bulb.bulbSprite.setFrame) {
                        bulb.bulbSprite.setFrame(0); // Set to off state
                    }
                    if (bulb.glowEffect) {
                        bulb.glowEffect.setVisible(false);
                    }
                });
            }
            
            // 1. Remove all placed items from circuit by scanning the entire grid
            for (let y = 0; y < gameState.gridHeight; y++) {
                for (let x = 0; x < gameState.gridWidth; x++) {
                    const gridItem = gameState.grid[y][x];
                    // Only remove items that are actual placed items (not pre-placed components)
                    if (gridItem && typeof gridItem === 'object' && 
                        gridItem.inBank !== undefined && gridItem.placed === true) {
                        console.log('Removing placed item from grid:', gridItem.name, 'at', x, y);
                        
                        // Clear the grid position first
                        gameState.grid[y][x] = null;
                        
                        // Clean up HTML element if it exists
                        if (gridItem.sprite && gridItem.sprite.htmlElement) {
                            gridItem.sprite.htmlElement.remove();
                        }
                        
                        // Destroy the sprite if it exists
                        if (gridItem.sprite) {
                            try {
                                if (gridItem.sprite.children && gridItem.sprite.children.entries) {
                                    gridItem.sprite.children.entries.forEach(child => {
                                        if (child) {
                                            child.setVisible(false);
                                            child.destroy();
                                        }
                                    });
                                }
                                gridItem.sprite.clear(true, true);
                                gridItem.sprite.destroy();
                            } catch (error) {
                                console.warn('Error destroying sprite during reset:', error);
                            }
                            gridItem.sprite = null;
                            gridItem.mainSprite = null;
                        }
                        
                        // Reset item state completely
                        gridItem.inBank = true;
                        gridItem.placed = false;
                        gridItem.gridX = -1;
                        gridItem.gridY = -1;
                        gridItem.isDragging = false;
                        
                        // Clear any stored positions
                        gridItem.originalX = undefined;
                        gridItem.originalY = undefined;
                        gridItem.originalGridX = undefined;
                        gridItem.originalGridY = undefined;
                        
                        // Clean up any removal hints
                        if (gridItem.removalHint) {
                            gridItem.removalHint.destroy();
                            gridItem.removalHint = null;
                        }
                    }
                }
            }
            
            // 2. Clear placed items array
            gameState.placedItems = [];
            console.log('Cleared placedItems array');
            
            // 3. Restore all items to original quantities in item bank
            gameState.itemBank.forEach(item => {
                // Reset item state to be in bank
                item.inBank = true;
                item.placed = false;
                item.gridX = -1;
                item.gridY = -1;
                item.isDragging = false;
                
                // Clear any stored positions
                item.originalX = undefined;
                item.originalY = undefined;
                item.originalGridX = undefined;
                item.originalGridY = undefined;
                
                // Show HTML element again with proper styling
                if (item.htmlElement) {
                    item.htmlElement.style.display = 'flex';
                    item.htmlElement.style.cursor = 'grab';
                    item.htmlElement.style.opacity = '1';
                    item.htmlElement.style.transform = 'scale(1)';
                    item.htmlElement.style.boxShadow = '';
                    item.htmlElement.style.animation = '';
                }
                
                console.log('Restored item to bank:', item.name);
            });
            
            // 4. Clear all gap positions back to empty state
            gameState.gaps.forEach(gap => {
                gap.filled = false;
                gap.filledWith = null;
                if (gap.sprite) {
                    gap.sprite.setVisible(true);
                }
                
                // Ensure all gap cells are marked as 'gap' in the grid
                const gapSize = gap.size || { width: 1, height: 1 };
                for (let dy = 0; dy < gapSize.height; dy++) {
                    for (let dx = 0; dx < gapSize.width; dx++) {
                        setGridPosition(gap.x + dx, gap.y + dy, 'gap');
                    }
                }
                
                console.log('Reset gap at position:', gap.x, gap.y, 'size:', gapSize);
            });
            
            // 5. Turn off light bulb and clear any success states
            updateLightBulb(false);
            
            // Reset circuit state to incomplete (clears short circuit state)
            gameState.circuitState = 'incomplete';
            
            // Clear flow visualization
            if (gameState.flowVisualization) {
                gameState.flowVisualization.forEach(particle => {
                    if (particle.destroy) particle.destroy();
                });
                gameState.flowVisualization = [];
            }
            
            // Hide success modal if it's showing
            const successModal = document.getElementById('success-modal');
            if (successModal && successModal.style.display !== 'none') {
                successModal.style.display = 'none';
            }
            
            // Clear any drag state
            gameState.draggedItem = null;
            gameState.isDragging = false;
            document.body.style.cursor = 'default';
            
            // Clear any drop zone highlights
            highlightDropZones(false);
            
            // Clean up any remaining HTML elements from placed items in canvas container
            const canvas = document.querySelector('canvas');
            const canvasContainer = canvas.parentElement;
            if (canvasContainer) {
                const itemElements = canvasContainer.querySelectorAll('div[style*="background-image"][style*="assets/items"]');
                itemElements.forEach(element => {
                    element.remove();
                });
            }
            
            // 6. Redraw base circuit with only pre-placed components
            // Clear connection graphics first
            clearConnectionGraphics();
            
            // Update wire connections to show base circuit only
            updateWireConnections();
            
            // Reset feedback to initial state
            showFeedback('Try different materials in the gaps to see which ones allow electricity to flow! Drag placed items away to remove them.', 'info');
            
            console.log('Current stage reset finished - all items returned to bank, gaps cleared, bulb off, staying in current stage');
        }

        function resetGame() {
            console.log('Starting complete game reset...');
            
            // 1. Remove all placed items from circuit by scanning the entire grid
            for (let y = 0; y < gameState.gridHeight; y++) {
                for (let x = 0; x < gameState.gridWidth; x++) {
                    const gridItem = gameState.grid[y][x];
                    // Only remove items that are actual placed items (not pre-placed components)
                    if (gridItem && typeof gridItem === 'object' && 
                        gridItem.inBank !== undefined && gridItem.placed === true) {
                        console.log('Removing placed item from grid:', gridItem.name, 'at', x, y);
                        
                        // Clear the grid position first
                        gameState.grid[y][x] = null;
                        
                        // Clean up HTML element if it exists
                        if (gridItem.sprite && gridItem.sprite.htmlElement) {
                            gridItem.sprite.htmlElement.remove();
                        }
                        
                        // Destroy the sprite if it exists
                        if (gridItem.sprite) {
                            try {
                                if (gridItem.sprite.children && gridItem.sprite.children.entries) {
                                    gridItem.sprite.children.entries.forEach(child => {
                                        if (child) {
                                            child.setVisible(false);
                                            child.destroy();
                                        }
                                    });
                                }
                                gridItem.sprite.clear(true, true);
                                gridItem.sprite.destroy();
                            } catch (error) {
                                console.warn('Error destroying sprite during reset:', error);
                            }
                            gridItem.sprite = null;
                            gridItem.mainSprite = null;
                        }
                        
                        // Reset item state completely
                        gridItem.inBank = true;
                        gridItem.placed = false;
                        gridItem.gridX = -1;
                        gridItem.gridY = -1;
                        gridItem.isDragging = false;
                        
                        // Clear any stored positions
                        gridItem.originalX = undefined;
                        gridItem.originalY = undefined;
                        gridItem.originalGridX = undefined;
                        gridItem.originalGridY = undefined;
                        
                        // Clean up any removal hints
                        if (gridItem.removalHint) {
                            gridItem.removalHint.destroy();
                            gridItem.removalHint = null;
                        }
                    }
                }
            }
            
            // 2. Clear placed items array
            gameState.placedItems = [];
            console.log('Cleared placedItems array');
            
            // 3. Restore all items to original quantities in item bank
            gameState.itemBank.forEach(item => {
                // Reset item state to be in bank
                item.inBank = true;
                item.placed = false;
                item.gridX = -1;
                item.gridY = -1;
                item.isDragging = false;
                
                // Clear any stored positions
                item.originalX = undefined;
                item.originalY = undefined;
                item.originalGridX = undefined;
                item.originalGridY = undefined;
                
                // Show HTML element again with proper styling
                if (item.htmlElement) {
                    item.htmlElement.style.display = 'flex';
                    item.htmlElement.style.cursor = 'grab';
                    item.htmlElement.style.opacity = '1';
                    item.htmlElement.style.transform = 'scale(1)';
                    item.htmlElement.style.boxShadow = '';
                    item.htmlElement.style.animation = '';
                }
                
                console.log('Restored item to bank:', item.name);
            });
            
            // 4. Clear all gap positions back to empty state
            gameState.gaps.forEach(gap => {
                gap.filled = false;
                gap.filledWith = null;
                if (gap.sprite) {
                    gap.sprite.setVisible(true);
                }
                
                // Ensure all gap cells are marked as 'gap' in the grid
                const gapSize = gap.size || { width: 1, height: 1 };
                for (let dy = 0; dy < gapSize.height; dy++) {
                    for (let dx = 0; dx < gapSize.width; dx++) {
                        setGridPosition(gap.x + dx, gap.y + dy, 'gap');
                    }
                }
                
                console.log('Reset gap at position:', gap.x, gap.y, 'size:', gapSize);
            });
            
            // 5. Turn off light bulb and clear any success states
            updateLightBulb(false);
            
            // Reset circuit state to incomplete (clears short circuit state)
            gameState.circuitState = 'incomplete';
            
            // Clear flow visualization
            if (gameState.flowVisualization) {
                gameState.flowVisualization.forEach(particle => {
                    if (particle.destroy) particle.destroy();
                });
                gameState.flowVisualization = [];
            }
            
            // Hide success modal if it's showing
            const successModal = document.getElementById('success-modal');
            if (successModal && successModal.style.display !== 'none') {
                successModal.style.display = 'none';
            }
            
            // Clear any drag state
            gameState.draggedItem = null;
            gameState.isDragging = false;
            document.body.style.cursor = 'default';
            
            // Clear any drop zone highlights
            highlightDropZones(false);
            
            // Clean up any remaining HTML elements from placed items in canvas container
            const canvas = document.querySelector('canvas');
            const canvasContainer = canvas.parentElement;
            if (canvasContainer) {
                const itemElements = canvasContainer.querySelectorAll('div[style*="background-image"][style*="assets/items"]');
                itemElements.forEach(element => {
                    element.remove();
                });
            }
            
            // 6. Redraw base circuit with only pre-placed components
            // Clear connection graphics first
            clearConnectionGraphics();
            
            // Update wire connections to show base circuit only
            updateWireConnections();
            
            // Reset to first circuit layout if we're not already there
            if (gameState.currentLayout !== 'first') {
                resetToFirstCircuitLayout();
            }
            
            // Reset feedback to initial state
            showFeedback('Try different materials in the gaps to see which ones allow electricity to flow! Drag placed items away to remove them.', 'info');
            
            console.log('Complete game reset finished - all items returned to bank, gaps cleared, bulb off');
        }

        function resetToFirstCircuitLayout() {
            // Load the first circuit layout using the new system
            loadCircuitLayout('first');
            console.log('Reset to first circuit layout');
        }

        document.getElementById('reset-btn').addEventListener('click', function() {
            resetCurrentStage();
        });

        // Start the game
        game = new Phaser.Game(config);
    </script>
</body>
</html>