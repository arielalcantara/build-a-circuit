<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conductor & Insulator Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: white;
            margin-bottom: 30px;
            text-align: center;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-weight: 300;
        }
        
        .game-subtitle {
            color: rgba(255,255,255,0.9);
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.1em;
            font-weight: 300;
        }
        
        #game-container {
            display: flex;
            gap: 25px;
            align-items: flex-start;
            background: rgba(255,255,255,0.1);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        #right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #game-canvas {
            border: 3px solid rgba(255,255,255,0.3);
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        
        #item-bank {
            width: 220px;
            padding: 20px;
            background: rgba(255,255,255,0.95);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            backdrop-filter: blur(5px);
        }
        
        #item-bank h3 {
            margin-top: 0;
            margin-bottom: 18px;
            color: #333;
            text-align: center;
            font-size: 1.2em;
            font-weight: 600;
        }
        
        .item-bank-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: start;
            justify-content: center;
        }
        
        .item-tooltip {
            position: absolute;
            background-color: rgba(186, 85, 211, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            min-height: 20px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .item-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(186, 85, 211, 0.95);
        }
        
        .bank-item {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 8px !important;
            position: relative;
            overflow: hidden;
        }
        
        .bank-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }
        
        .bank-item:hover::before {
            left: 100%;
        }
        
        #controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: stretch;
        }
        
        .controls-row {
            display: flex;
            gap: 15px;
        }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        button:hover {
            background-color: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        #test-circuit-btn {
            background-color: #FF9800;
            font-weight: bold;
        }
        
        #test-circuit-btn:hover {
            background-color: #F57C00;
        }
        
        #feedback-area {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .feedback-success {
            background-color: #E8F5E8;
            color: #2E7D32;
            border: 2px solid #4CAF50;
        }
        
        .feedback-error {
            background-color: #FFEBEE;
            color: #C62828;
            border: 2px solid #F44336;
        }
        
        .feedback-info {
            background-color: #E3F2FD;
            color: #1565C0;
            border: 2px solid #2196F3;
        }
        
        #success-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        #success-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            padding: 40px;
            border-radius: 15px;
            text-align: left;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            opacity: 0;
            animation: slideIn 0.4s ease-out forwards;
        }
        
        #success-content h2 {
            color: #4CAF50;
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
        }
        
        #success-details p {
            margin-bottom: 15px;
            color: #333;
            line-height: 1.5;
        }
        
        #success-explanation {
            background-color: #E8F5E8;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
            margin: 15px 0;
        }
        
        #success-explanation li {
            margin-bottom: 8px;
            color: #2E7D32;
            font-weight: 500;
        }
        
        .conductor-text {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .insulator-text {
            color: #F44336;
            font-weight: bold;
        }
        
        #materials-used {
            background-color: #F3E5F5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #9C27B0;
        }
        
        #materials-used h4 {
            color: #7B1FA2;
            margin-bottom: 10px;
        }
        
        #success-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }
        
        #success-actions button {
            flex: 1;
            max-width: 150px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { 
                opacity: 0;
                transform: translate(-50%, -60%) scale(0.8);
            }
            to { 
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        @keyframes slideOut {
            from { 
                opacity: 1;
                transform: translate(-50%, -50%);
            }
            to { 
                opacity: 0;
                transform: translate(-50%, -60%);
            }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Responsive design for larger 15x15 grid */
        @media (max-width: 1200px) {
            #game-container {
                flex-direction: column;
                align-items: center;
            }
            
            #right-panel {
                width: 100%;
                max-width: 500px;
                align-items: center;
            }
            
            #item-bank {
                width: 100%;
            }
            
            .item-bank-grid {
                gap: 6px;
            }
        }
        
        @media (max-width: 1024px) {
            #game-canvas {
                max-width: 90vw;
                max-height: 90vw;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            #game-container {
                padding: 15px;
            }
            
            #game-canvas {
                max-width: 95vw;
                max-height: 95vw;
            }
            
            .controls-row {
                flex-direction: column;
                width: 100%;
            }
            
            .controls-row button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>âš¡ Conductor & Insulator Circuit Game</h1>
    <p class="game-subtitle">Learn about electricity by building circuits with different materials!</p>
    
    <div id="game-container">
        <div id="game-canvas"></div>
        <div id="right-panel">
            <div id="item-bank">
                <h3>Item Bank</h3>
                <div class="item-bank-grid" id="item-bank-grid">
                    <!-- Items will be added here by JavaScript -->
                </div>
            </div>
            
            <div id="controls">
                <div class="controls-row">
                    <button id="test-circuit-btn">âš¡ Test Circuit</button>
                    <button id="reset-btn">ðŸ”„ Reset Game</button>
                </div>
                <div id="feedback-area">
                    Try different materials in the gaps to see which ones allow electricity to flow! Drag placed items away to remove them.
                </div>
            </div>
        </div>
    </div>
    
    <!-- Success Modal -->
    <div id="success-modal">
        <div id="success-content">
            <h2>ðŸŽ‰ Excellent Work!</h2>
            <div id="success-details">
                <p><strong>You completed the electrical circuit!</strong></p>
                <p>The light bulb is glowing because:</p>
                <ul id="success-explanation">
                    <li>âœ… Electricity flows from the battery's positive (+) terminal</li>
                    <li>âœ… Through the <span class="conductor-text">conductors</span> you placed</li>
                    <li>âœ… Through the light bulb (making it glow)</li>
                    <li>âœ… Back to the battery's negative (-) terminal</li>
                </ul>
                <div id="materials-used">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>
            <div id="success-actions">
                <button id="play-again-btn">ðŸ”„ Try Again</button>
                <button id="new-challenge-btn">âš¡ New Challenge</button>
            </div>
        </div>
    </div>

    <!-- Phaser.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    
    <script>
        // Responsive canvas sizing
        function getOptimalCanvasSize() {
            const maxWidth = Math.min(window.innerWidth * 0.6, 900);
            const maxHeight = Math.min(window.innerHeight * 0.7, 900);
            const size = Math.min(maxWidth, maxHeight);
            return Math.max(size, 600); // Minimum size of 600px
        }

        // Game configuration
        const canvasSize = getOptimalCanvasSize();
        const config = {
            type: Phaser.AUTO,
            width: canvasSize, // Responsive size, max 900px (15 cells * 60px)
            height: canvasSize, // Responsive size, max 900px (15 cells * 60px)
            parent: 'game-canvas',
            backgroundColor: '#ffffff',
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false
                }
            }
        };

        // Game variables
        let game;
        let scene;
        let gameState = {
            grid: [],
            gridWidth: 15,
            gridHeight: 15,
            cellSize: canvasSize / 15, // Dynamic cell size based on canvas
            itemBank: [],
            placedItems: [],
            currentLayout: 'first', // Track which circuit layout is active
            circuitLayouts: {}, // Store all circuit configurations
            battery: { x: 2, y: 6, width: 1, height: 3, sprite: null },
            bulb: { x: 11, y: 6, width: 3, height: 3, sprite: null, isLit: false },
            // Two-wire circuit: top wire (positive) and bottom wire (negative)
            gaps: [
                // Top wire gaps (row 4) - Adjacent M labels count as single missing parts
                { x: 5, y: 4, filled: false, size: { width: 1, height: 1 } }, // Single M at (5,4)
                { x: 8, y: 4, filled: false, size: { width: 2, height: 1 } }, // M M at (8,4) and (9,4) = 1x2 gap
                // Bottom wire gaps (row 10) - Adjacent M labels count as single missing parts  
                { x: 6, y: 10, filled: false, size: { width: 3, height: 1 } }  // M M M at (6,10), (7,10), (8,10) = 1x3 gap
            ],
            preplacedWires: [
                // Top horizontal wire (positive path) - row 4
                { x: 3, y: 4 }, // H - Horizontal wire after L-shaped connection
                { x: 4, y: 4 }, // H - Horizontal wire before first gap
                // Gap at x:5 (M)
                { x: 6, y: 4 }, // H - Horizontal wire after first gap
                { x: 7, y: 4 }, // H - Horizontal wire before second gap
                // Gaps at x:8,9 (M M)
                { x: 10, y: 4 }, // H - Horizontal wire after gaps
                { x: 11, y: 4 }, // H - Horizontal wire before L-shaped connection
                
                // Battery connections
                { x: 2, y: 4 }, // L - L-shaped wire at top
                { x: 2, y: 5 }, // V - Vertical wire connecting to battery
                { x: 2, y: 9 }, // V - Vertical wire connecting from battery
                { x: 2, y: 10 }, // L - L-shaped wire at bottom
                
                // Bulb connections
                { x: 12, y: 4 }, // L - L-shaped wire at top
                { x: 12, y: 5 }, // V - Vertical wire connecting to bulb
                { x: 12, y: 9 }, // V - Vertical wire connecting from bulb
                { x: 12, y: 10 }, // L - L-shaped wire at bottom
                
                // Bottom horizontal wire (negative path) - row 10
                { x: 3, y: 10 }, // H - Horizontal wire after L-shaped connection
                { x: 4, y: 10 }, // H - Horizontal wire
                { x: 5, y: 10 }, // H - Horizontal wire before gaps
                // Gaps at x:6,7,8 (M M M)
                { x: 9, y: 10 }, // H - Horizontal wire after gaps
                { x: 10, y: 10 }, // H - Horizontal wire
                { x: 11, y: 10 }  // H - Horizontal wire before L-shaped connection
            ],
            draggedItem: null,
            isDragging: false,
            connectionGraphics: [] // Store connection graphics for cleanup
        };

        // Define all circuit layouts
        gameState.circuitLayouts = {
            first: {
                battery: { x: 2, y: 6, width: 1, height: 3 },
                bulb: { x: 11, y: 6, width: 3, height: 3 },
                gaps: [
                    { x: 5, y: 4, filled: false, size: { width: 1, height: 1 } },
                    { x: 8, y: 4, filled: false, size: { width: 2, height: 1 } },
                    { x: 6, y: 10, filled: false, size: { width: 3, height: 1 } }
                ],
                preplacedWires: [
                    // Top horizontal wire (positive path) - row 4
                    { x: 3, y: 4 }, { x: 4, y: 4 }, { x: 6, y: 4 }, { x: 7, y: 4 },
                    { x: 10, y: 4 }, { x: 11, y: 4 },
                    // Battery connections
                    { x: 2, y: 4 }, { x: 2, y: 5 }, { x: 2, y: 9 }, { x: 2, y: 10 },
                    // Bulb connections
                    { x: 12, y: 4 }, { x: 12, y: 5 }, { x: 12, y: 9 }, { x: 12, y: 10 },
                    // Bottom horizontal wire (negative path) - row 10
                    { x: 3, y: 10 }, { x: 4, y: 10 }, { x: 5, y: 10 },
                    { x: 9, y: 10 }, { x: 10, y: 10 }, { x: 11, y: 10 }
                ]
            },
            second: {
                battery: { x: 1, y: 6, width: 1, height: 3 },  // B at (1,6), (1,7), (1,8)
                bulb: { x: 11, y: 6, width: 3, height: 3 },    // O O O at (11,6)-(13,8)
                gaps: [
                    // Row 4: M M at positions (3,4) and (4,4) = 1x2 gap
                    { x: 3, y: 4, filled: false, size: { width: 2, height: 1 } },
                    // Vertical gap: M at positions (6,6), (6,7), (6,8) = 1x3 vertical gap
                    { x: 6, y: 6, filled: false, size: { width: 1, height: 3 } },
                    // Row 10: M at position (9,10) = 1x1 gap
                    { x: 9, y: 10, filled: false, size: { width: 1, height: 1 } }
                ],
                preplacedWires: [
                    // Row 4: . L H M M H T H H H H H L . .
                    { x: 1, y: 4 },   // L - L-shaped wire
                    { x: 2, y: 4 },   // H - Horizontal wire
                    // Gaps at (3,4) and (4,4) - M M
                    { x: 5, y: 4 },   // H - Horizontal wire
                    { x: 6, y: 4 },   // T - T-shaped wire
                    { x: 7, y: 4 },   // H - Horizontal wire
                    { x: 8, y: 4 },   // H - Horizontal wire
                    { x: 9, y: 4 },   // H - Horizontal wire
                    { x: 10, y: 4 },  // H - Horizontal wire
                    { x: 11, y: 4 },  // H - Horizontal wire
                    { x: 12, y: 4 },  // L - L-shaped wire (bulb connection)
                    
                    // Row 5: . V . . . . V . . . . . V . .
                    { x: 1, y: 5 },   // V - Vertical wire
                    { x: 6, y: 5 },   // V - Vertical wire (T-junction connection)
                    { x: 12, y: 5 },  // V - Vertical wire (bulb connection)
                    
                    // Row 9: . V . . . . V . . . . . V . .
                    { x: 1, y: 9 },   // V - Vertical wire
                    { x: 6, y: 9 },   // V - Vertical wire (T-junction connection)
                    { x: 12, y: 9 },  // V - Vertical wire (bulb connection)
                    
                    // Row 10: . L H H H H T H H M H H L . .
                    { x: 1, y: 10 },  // L - L-shaped wire
                    { x: 2, y: 10 },  // H - Horizontal wire
                    { x: 3, y: 10 },  // H - Horizontal wire
                    { x: 4, y: 10 },  // H - Horizontal wire
                    { x: 5, y: 10 },  // H - Horizontal wire
                    { x: 6, y: 10 },  // T - T-shaped wire
                    { x: 7, y: 10 },  // H - Horizontal wire
                    { x: 8, y: 10 },  // H - Horizontal wire
                    // Gap at (9,10) - M
                    { x: 10, y: 10 }, // H - Horizontal wire
                    { x: 11, y: 10 }, // H - Horizontal wire
                    { x: 12, y: 10 }  // L - L-shaped wire (bulb connection)
                ]
            }
        };

        function preload() {
            scene = this;
            
            // Add loading progress feedback
            scene.load.on('progress', function (value) {
                console.log('Loading progress:', value);
            });
            
            scene.load.on('complete', function () {
                console.log('All assets loaded successfully');
            });
            
            scene.load.on('loaderror', function (file) {
                console.error('Failed to load:', file.src);
            });
            
            // Load image assets
            scene.load.image('battery', 'assets/items/battery.png');
            scene.load.spritesheet('lightbulb', 'assets/items/light-bulb.png', { frameWidth: 300, frameHeight: 300 });
            
            // Load item bank images
            scene.load.image('coin', 'assets/items/coin.png');
            scene.load.image('bottlecap', 'assets/items/bottlecap.png');
            scene.load.image('key', 'assets/items/key.png');
            scene.load.image('paperclip', 'assets/items/paperclip.png');
            scene.load.image('spoon', 'assets/items/spoon.png');
            scene.load.image('ruler', 'assets/items/ruler.png');
            scene.load.image('lego', 'assets/items/lego.png');
            scene.load.image('pebble', 'assets/items/pebble.png');
            scene.load.image('button', 'assets/items/button.png');
            scene.load.image('eraser', 'assets/items/eraser.png');
            scene.load.image('rubberband', 'assets/items/rubberband.png');
            scene.load.image('popsiclestick', 'assets/items/popsiclestick.png');
            scene.load.image('straw', 'assets/items/straw.png');
        }

        function create() {
            console.log('Game scene created');
            
            // Check if all textures loaded correctly
            console.log('Available textures:', Object.keys(scene.textures.list));
            
            // Verify specific textures we need
            const requiredTextures = ['coin', 'bottlecap', 'key', 'paperclip', 'spoon', 'ruler', 'lego', 'pebble', 'button', 'eraser', 'rubberband', 'popsiclestick', 'straw'];
            requiredTextures.forEach(textureKey => {
                if (scene.textures.exists(textureKey)) {
                    console.log('âœ“ Texture loaded:', textureKey);
                } else {
                    console.error('âœ— Texture missing:', textureKey);
                }
            });
            
            // Initialize the grid
            initializeGrid();
            
            // Draw grid lines
            drawGrid();
            
            // Load the first circuit layout
            loadCircuitLayout('first');
            
            // Create item bank
            createItemBank();
            
            // Set up input handling
            setupInputHandling();
            
            // Start position updater for HTML elements
            startPositionUpdater();
        }

        function update() {
            // Game loop - will be used for animations and updates
        }

        function initializeGrid() {
            // Initialize 2D grid array
            gameState.grid = [];
            for (let y = 0; y < gameState.gridHeight; y++) {
                gameState.grid[y] = [];
                for (let x = 0; x < gameState.gridWidth; x++) {
                    gameState.grid[y][x] = null;
                }
            }
        }

        function drawGrid() {
            const graphics = scene.add.graphics();
            graphics.lineStyle(1, 0xcccccc, 0.3);
            
            // Draw vertical lines
            for (let x = 0; x <= gameState.gridWidth; x++) {
                const worldX = x * gameState.cellSize;
                graphics.moveTo(worldX, 0);
                graphics.lineTo(worldX, gameState.gridHeight * gameState.cellSize);
            }
            
            // Draw horizontal lines
            for (let y = 0; y <= gameState.gridHeight; y++) {
                const worldY = y * gameState.cellSize;
                graphics.moveTo(0, worldY);
                graphics.lineTo(gameState.gridWidth * gameState.cellSize, worldY);
            }
            
            graphics.strokePath();
            
            // Highlight the circuit rows (top and bottom wires)
            graphics.lineStyle(2, 0x4CAF50, 0.3);
            graphics.fillStyle(0x4CAF50, 0.1);
            
            // Top wire (row 4)
            graphics.fillRect(0, 4 * gameState.cellSize, gameState.gridWidth * gameState.cellSize, gameState.cellSize);
            graphics.strokeRect(0, 4 * gameState.cellSize, gameState.gridWidth * gameState.cellSize, gameState.cellSize);
            
            // Bottom wire (row 10)  
            graphics.fillRect(0, 10 * gameState.cellSize, gameState.gridWidth * gameState.cellSize, gameState.cellSize);
            graphics.strokeRect(0, 10 * gameState.cellSize, gameState.gridWidth * gameState.cellSize, gameState.cellSize);
        }

        function createCircuitComponents() {
            // Create battery
            createBattery();
            
            // Create light bulb
            createLightBulb();
            
            // Create pre-placed wires
            createPreplacedWires();
            
            // Mark gaps in the grid
            markGaps();
        }

        function createBattery() {
            // Battery now spans 1x3 cells (width=1, height=3) at position (2, 4-6)
            const centerX = gameState.battery.x;
            const centerY = gameState.battery.y + 1; // Center of the three cells
            const pos = gridToWorld(centerX, centerY);
            
            // Create battery using image asset - sized to fill 1x3 cells completely
            let batteryImage;
            if (scene.textures.exists('battery')) {
                batteryImage = scene.add.image(pos.x, pos.y, 'battery');
                batteryImage.setDisplaySize(gameState.cellSize, gameState.cellSize * 3); // Full 1x3 cells
                console.log('Battery image created successfully');
            } else {
                console.error('Battery texture not found, creating fallback');
                // Create fallback colored rectangle for full 1x3 cells
                batteryImage = scene.add.rectangle(pos.x, pos.y, gameState.cellSize, gameState.cellSize * 3, 0x333333);
                batteryImage.setStrokeStyle(2, 0x000000);
            }
            
            // Set depth to appear above wires
            batteryImage.setDepth(10);
            
            // Group all battery components
            gameState.battery.sprite = scene.add.group([
                batteryImage
            ]);
            
            // Mark battery positions in grid (all three cells: y=4,5,6)
            for (let dy = 0; dy < gameState.battery.height; dy++) {
                setGridPosition(gameState.battery.x, gameState.battery.y + dy, 'battery');
            }
        }

        function createLightBulb() {
            // Light bulb now spans 3x3 cells (width=3, height=3)
            const centerX = gameState.bulb.x + 1; // Center of 3x3 grid
            const centerY = gameState.bulb.y + 1; // Center of 3x3 grid
            const pos = gridToWorld(centerX, centerY);
            
            // Create light bulb using spritesheet (frame 0 = off, frame 1 = on) - sized to fill 3x3 cells completely
            let bulbSprite;
            if (scene.textures.exists('lightbulb')) {
                bulbSprite = scene.add.sprite(pos.x, pos.y, 'lightbulb', 0);
                bulbSprite.setDisplaySize(gameState.cellSize * 3, gameState.cellSize * 3); // Full 3x3 cells
                console.log('Light bulb sprite created successfully');
            } else {
                console.error('Light bulb texture not found, creating fallback');
                // Create fallback colored circle for full 3x3 cells
                bulbSprite = scene.add.circle(pos.x, pos.y, gameState.cellSize * 1.5, 0xFFFFFF);
                bulbSprite.setStrokeStyle(2, 0x000000);
                bulbSprite.setAlpha(0.8);
            }
            
            // Set depth to appear above wires
            bulbSprite.setDepth(10);
            
            // Store references for later use
            gameState.bulb.sprite = scene.add.group([
                bulbSprite
            ]);
            gameState.bulb.bulbSprite = bulbSprite;
            
            // Mark bulb positions in grid (all 9 cells)
            for (let dx = 0; dx < gameState.bulb.width; dx++) {
                for (let dy = 0; dy < gameState.bulb.height; dy++) {
                    setGridPosition(gameState.bulb.x + dx, gameState.bulb.y + dy, 'bulb');
                }
            }
        }

        function createPreplacedWires() {
            gameState.preplacedWires.forEach(wire => {
                const pos = gridToWorld(wire.x, wire.y);
                
                // Determine wire type based on position and connections
                const wireType = determineWireType(wire.x, wire.y);
                
                // Create wire segment based on type
                if (wireType === 'L-shaped') {
                    wire.sprite = createLShapedWire(pos, wire.x, wire.y);
                } else if (wireType === 'T-shaped') {
                    wire.sprite = createTShapedWire(pos, wire.x, wire.y);
                } else {
                    // Create straight wire - determine orientation based on position
                    wire.sprite = createStraightWire(pos, wire.x, wire.y);
                }
                
                // Mark wire position in grid
                setGridPosition(wire.x, wire.y, 'wire');
            });
        }

        function determineWireType(x, y) {
            // Only apply T-junction logic for the second circuit layout
            if (gameState.currentLayout === 'second') {
                // Specific T-junction positions in the second layout
                if ((x === 6 && y === 4) || (x === 6 && y === 10)) {
                    return 'T-shaped';
                }
            }
            
            // Check for L-shaped junctions (corner connections)
            const adjacentWires = getAdjacentWireCount(x, y);
            if (adjacentWires === 2) {
                // Check if it's a corner (not straight line)
                const directions = getAdjacentWireDirections(x, y);
                if (directions.length === 2) {
                    const [dir1, dir2] = directions;
                    // If directions are perpendicular, it's an L-shape
                    if ((dir1.dx === 0) !== (dir2.dx === 0)) {
                        return 'L-shaped';
                    }
                }
            }
            
            // Check for T-shaped junctions (where three or more wires meet)
            if (adjacentWires >= 3) {
                return 'T-shaped';
            }
            
            return 'straight';
        }

        function getAdjacentWireCount(x, y) {
            let count = 0;
            const directions = [
                { dx: -1, dy: 0 }, // left
                { dx: 1, dy: 0 },  // right
                { dx: 0, dy: -1 }, // up
                { dx: 0, dy: 1 }   // down
            ];
            
            directions.forEach(dir => {
                const checkX = x + dir.dx;
                const checkY = y + dir.dy;
                if (isWirePosition(checkX, checkY)) {
                    count++;
                }
            });
            
            return count;
        }

        function getAdjacentWireDirections(x, y) {
            const directions = [];
            const checkDirections = [
                { dx: -1, dy: 0 }, // left
                { dx: 1, dy: 0 },  // right
                { dx: 0, dy: -1 }, // up
                { dx: 0, dy: 1 }   // down
            ];
            
            checkDirections.forEach(dir => {
                const checkX = x + dir.dx;
                const checkY = y + dir.dy;
                if (isWirePosition(checkX, checkY)) {
                    directions.push(dir);
                }
            });
            
            return directions;
        }

        function isWirePosition(x, y) {
            return gameState.preplacedWires.some(wire => wire.x === x && wire.y === y) ||
                   getGridPosition(x, y) === 'wire';
        }

        function createStraightWire(pos, x, y) {
            const group = scene.add.group();
            const wireThickness = 12; // Thicker wires for better connection
            const wireLength = gameState.cellSize; // Full cell size for proper connection
            
            // Determine if this should be a vertical or horizontal wire
            const isVerticalWire = isVerticalWirePosition(x, y);
            
            let wireSprite;
            if (isVerticalWire) {
                // Create vertical wire - full height
                wireSprite = scene.add.rectangle(pos.x, pos.y, wireThickness, wireLength, 0xCD7F32);
            } else {
                // Create horizontal wire - full width
                wireSprite = scene.add.rectangle(pos.x, pos.y, wireLength, wireThickness, 0xCD7F32);
            }
            
            wireSprite.setStrokeStyle(1, 0x8B4513);
            wireSprite.setDepth(5);
            group.add(wireSprite);
            
            return group;
        }

        function isVerticalWirePosition(x, y) {
            if (gameState.currentLayout === 'first') {
                // First circuit: Vertical wires at (2,5), (2,9), (12,5), (12,9)
                return (x === 2 && (y === 5 || y === 9)) || (x === 12 && (y === 5 || y === 9));
            } else if (gameState.currentLayout === 'second') {
                // Second circuit: Vertical wires at (1,5), (1,9), (6,5), (6,9), (12,5), (12,9)
                return (x === 1 && (y === 5 || y === 9)) || 
                       (x === 6 && (y === 5 || y === 9)) || 
                       (x === 12 && (y === 5 || y === 9));
            }
            return false;
        }

        function createLShapedWire(pos, x, y) {
            const group = scene.add.group();
            const wireThickness = 12; // Match straight wire thickness
            const halfCell = gameState.cellSize / 2;
            
            // Create L-shaped wires based on current layout
            if (gameState.currentLayout === 'first') {
                // First circuit L-wire positions
                if (x === 2 && y === 4) {
                    // Battery top L-wire: connects right and down
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 2 && y === 10) {
                    // Battery bottom L-wire: connects right and up
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 4) {
                    // Bulb top L-wire: connects left and down
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 10) {
                    // Bulb bottom L-wire: connects left and up
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                }
            } else if (gameState.currentLayout === 'second') {
                // Second circuit L-wire positions
                if (x === 1 && y === 4) {
                    // Battery top L-wire: connects right and down
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 1 && y === 10) {
                    // Battery bottom L-wire: connects right and up
                    const horizontalWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 4) {
                    // Bulb top L-wire: connects left and down
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                } else if (x === 12 && y === 10) {
                    // Bulb bottom L-wire: connects left and up
                    const horizontalWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    const verticalWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    horizontalWire.setStrokeStyle(1, 0x8B4513);
                    verticalWire.setStrokeStyle(1, 0x8B4513);
                    horizontalWire.setDepth(5);
                    verticalWire.setDepth(5);
                    group.add(horizontalWire);
                    group.add(verticalWire);
                }
            }
            
            // Add center junction piece for proper connection
            const centerPiece = scene.add.rectangle(pos.x, pos.y, wireThickness, wireThickness, 0xCD7F32);
            centerPiece.setStrokeStyle(1, 0x8B4513);
            centerPiece.setDepth(5);
            group.add(centerPiece);
            
            return group;
        }

        function createTShapedWire(pos, x, y) {
            const group = scene.add.group();
            const wireThickness = 12; // Match L-shaped wire thickness
            const halfCell = gameState.cellSize / 2;
            
            // Create T-shaped wires with segments extending to cell edges, similar to L-shaped wires
            if (x === 6 && y === 4) {
                // T-junction at (6,4) - connects left, right, and down
                // Left horizontal segment
                const leftWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                leftWire.setStrokeStyle(1, 0x8B4513);
                leftWire.setDepth(5);
                group.add(leftWire);
                
                // Right horizontal segment
                const rightWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                rightWire.setStrokeStyle(1, 0x8B4513);
                rightWire.setDepth(5);
                group.add(rightWire);
                
                // Downward vertical segment
                const downWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                downWire.setStrokeStyle(1, 0x8B4513);
                downWire.setDepth(5);
                group.add(downWire);
                
            } else if (x === 6 && y === 10) {
                // T-junction at (6,10) - connects left, right, and up
                // Left horizontal segment
                const leftWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                leftWire.setStrokeStyle(1, 0x8B4513);
                leftWire.setDepth(5);
                group.add(leftWire);
                
                // Right horizontal segment
                const rightWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                rightWire.setStrokeStyle(1, 0x8B4513);
                rightWire.setDepth(5);
                group.add(rightWire);
                
                // Upward vertical segment
                const upWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                upWire.setStrokeStyle(1, 0x8B4513);
                upWire.setDepth(5);
                group.add(upWire);
                
            } else {
                // Generic T-junction logic for other positions
                const hasWireLeft = isWirePosition(x - 1, y);
                const hasWireRight = isWirePosition(x + 1, y);
                const hasWireAbove = isWirePosition(x, y - 1);
                const hasWireBelow = isWirePosition(x, y + 1);
                
                // Create horizontal segments
                if (hasWireLeft) {
                    const leftWire = scene.add.rectangle(pos.x - halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    leftWire.setStrokeStyle(1, 0x8B4513);
                    leftWire.setDepth(5);
                    group.add(leftWire);
                }
                if (hasWireRight) {
                    const rightWire = scene.add.rectangle(pos.x + halfCell/2, pos.y, halfCell, wireThickness, 0xCD7F32);
                    rightWire.setStrokeStyle(1, 0x8B4513);
                    rightWire.setDepth(5);
                    group.add(rightWire);
                }
                
                // Create vertical segments
                if (hasWireAbove) {
                    const upWire = scene.add.rectangle(pos.x, pos.y - halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    upWire.setStrokeStyle(1, 0x8B4513);
                    upWire.setDepth(5);
                    group.add(upWire);
                }
                if (hasWireBelow) {
                    const downWire = scene.add.rectangle(pos.x, pos.y + halfCell/2, wireThickness, halfCell, 0xCD7F32);
                    downWire.setStrokeStyle(1, 0x8B4513);
                    downWire.setDepth(5);
                    group.add(downWire);
                }
            }
            
            // Add center junction piece for proper connection (like L-shaped wires)
            const centerPiece = scene.add.rectangle(pos.x, pos.y, wireThickness, wireThickness, 0xCD7F32);
            centerPiece.setStrokeStyle(1, 0x8B4513);
            centerPiece.setDepth(5);
            group.add(centerPiece);
            
            return group;
        }

        function markGaps() {
            gameState.gaps.forEach(gap => {
                // Calculate gap size based on the gap's size property
                const gapSize = gap.size || { width: 1, height: 1 };
                const cellSize = gameState.cellSize;
                
                // Create gap indicator (dashed outline using multiple small lines)
                const graphics = scene.add.graphics();
                graphics.lineStyle(2, 0xFF6B6B, 0.8);
                
                // Calculate position - use top-left corner of grid cell, not center
                const x = gap.x * cellSize;
                const y = gap.y * cellSize;
                const width = cellSize * gapSize.width;
                const height = cellSize * gapSize.height;
                const dashLength = 5;
                const gapLength = 5;
                
                // Top line
                for (let i = 0; i < width; i += dashLength + gapLength) {
                    const lineWidth = Math.min(dashLength, width - i);
                    graphics.moveTo(x + i, y);
                    graphics.lineTo(x + i + lineWidth, y);
                }
                
                // Bottom line
                for (let i = 0; i < width; i += dashLength + gapLength) {
                    const lineWidth = Math.min(dashLength, width - i);
                    graphics.moveTo(x + i, y + height);
                    graphics.lineTo(x + i + lineWidth, y + height);
                }
                
                // Left line
                for (let i = 0; i < height; i += dashLength + gapLength) {
                    const lineHeight = Math.min(dashLength, height - i);
                    graphics.moveTo(x, y + i);
                    graphics.lineTo(x, y + i + lineHeight);
                }
                
                // Right line
                for (let i = 0; i < height; i += dashLength + gapLength) {
                    const lineHeight = Math.min(dashLength, height - i);
                    graphics.moveTo(x + width, y + i);
                    graphics.lineTo(x + width, y + i + lineHeight);
                }
                
                graphics.strokePath();
                
                // Store only the graphics (no text label for cleaner appearance)
                gap.sprite = scene.add.group([graphics]);
                
                // Mark all cells occupied by this gap
                for (let dy = 0; dy < gapSize.height; dy++) {
                    for (let dx = 0; dx < gapSize.width; dx++) {
                        setGridPosition(gap.x + dx, gap.y + dy, 'gap');
                    }
                }
            });
        }

        function updateLightBulb(isLit) {
            if (gameState.bulb.bulbSprite) {
                if (isLit) {
                    // Try to use frame 1 for lit state if it's a sprite, otherwise change tint
                    if (gameState.bulb.bulbSprite.setFrame && typeof gameState.bulb.bulbSprite.setFrame === 'function') {
                        gameState.bulb.bulbSprite.setFrame(1);
                    } else {
                        // Fallback: change tint to yellow for lit state
                        gameState.bulb.bulbSprite.setTint(0xFFFF88);
                    }
                    
                    // Add glow effect
                    if (!gameState.bulb.glowEffect) {
                        gameState.bulb.glowEffect = scene.add.circle(
                            gameState.bulb.bulbSprite.x, 
                            gameState.bulb.bulbSprite.y, 
                            35, 0xFFFF00
                        );
                        gameState.bulb.glowEffect.setAlpha(0.3);
                        gameState.bulb.glowEffect.setDepth(-1);
                    }
                    gameState.bulb.glowEffect.setVisible(true);
                } else {
                    // Try to use frame 0 for off state if it's a sprite, otherwise clear tint
                    if (gameState.bulb.bulbSprite.setFrame && typeof gameState.bulb.bulbSprite.setFrame === 'function') {
                        gameState.bulb.bulbSprite.setFrame(0);
                    } else {
                        // Fallback: clear tint for off state
                        gameState.bulb.bulbSprite.clearTint();
                    }
                    
                    if (gameState.bulb.glowEffect) {
                        gameState.bulb.glowEffect.setVisible(false);
                    }
                }
                gameState.bulb.isLit = isLit;
            }
        }

        function createItemBank() {
            const itemBankContainer = document.getElementById('item-bank-grid');
            
            // Define available items - real-world materials with sizes
            const itemDefinitions = [
                // Conductors
                {
                    id: 'coin',
                    name: 'Copper Coin',
                    type: 'conductor',
                    conductive: true,
                    imageKey: 'coin',
                    size: { width: 1, height: 1 },
                    quantity: 1
                },
                {
                    id: 'bottlecap',
                    name: 'Bottle Cap',
                    type: 'conductor',
                    conductive: true,
                    imageKey: 'bottlecap',
                    size: { width: 1, height: 1 },
                    quantity: 1
                },
                {
                    id: 'key',
                    name: 'Metal Key',
                    type: 'conductor',
                    conductive: true,
                    imageKey: 'key',
                    size: { width: 2, height: 1 },
                    quantity: 1
                },
                {
                    id: 'paperclip',
                    name: 'Paper Clip',
                    type: 'conductor',
                    conductive: true,
                    imageKey: 'paperclip',
                    size: { width: 2, height: 1 },
                    quantity: 1
                },
                {
                    id: 'spoon',
                    name: 'Spoon',
                    type: 'conductor',
                    conductive: true,
                    imageKey: 'spoon',
                    size: { width: 3, height: 1 },
                    quantity: 1
                },
                {
                    id: 'ruler',
                    name: 'Metal Ruler',
                    type: 'conductor',
                    conductive: true,
                    imageKey: 'ruler',
                    size: { width: 3, height: 1 },
                    quantity: 1
                },
                // Insulators
                {
                    id: 'lego',
                    name: 'Lego Brick',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'lego',
                    size: { width: 1, height: 1 },
                    quantity: 1
                },
                {
                    id: 'pebble',
                    name: 'Pebble',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'pebble',
                    size: { width: 1, height: 1 },
                    quantity: 1
                },
                {
                    id: 'button',
                    name: 'Button',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'button',
                    size: { width: 1, height: 1 },
                    quantity: 1
                },
                {
                    id: 'eraser',
                    name: 'Eraser',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'eraser',
                    size: { width: 2, height: 1 },
                    quantity: 1
                },
                {
                    id: 'rubberband',
                    name: 'Rubber Band',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'rubberband',
                    size: { width: 2, height: 1 },
                    quantity: 1
                },
                {
                    id: 'popsiclestick',
                    name: 'Popsicle Stick',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'popsiclestick',
                    size: { width: 3, height: 1 },
                    quantity: 1
                },
                {
                    id: 'straw',
                    name: 'Straw',
                    type: 'insulator',
                    conductive: false,
                    imageKey: 'straw',
                    size: { width: 3, height: 1 },
                    quantity: 1
                }
            ];
            
            // Create item bank items
            itemDefinitions.forEach(itemDef => {
                for (let i = 0; i < itemDef.quantity; i++) {
                    const item = createBankItem(itemDef, i);
                    gameState.itemBank.push(item);
                    
                    // Create HTML element for the item
                    const itemElement = createItemBankElement(item);
                    itemBankContainer.appendChild(itemElement);
                }
            });
        }

        function createBankItem(definition, index) {
            return {
                id: `${definition.id}_${index}`,
                name: definition.name,
                type: definition.type,
                conductive: definition.conductive,
                imageKey: definition.imageKey,
                size: definition.size || { width: 1, height: 1 },
                inBank: true,
                placed: false,
                sprite: null,
                htmlElement: null,
                gridX: -1,
                gridY: -1
            };
        }

        function createItemBankElement(item) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'bank-item';
            
            // Calculate size based on item dimensions - make width differences more pronounced
            const baseWidth = 60;
            const baseHeight = 40;
            const width = baseWidth + (item.size.width - 1) * 30; // More width difference
            const height = baseHeight + (item.size.height - 1) * 10; // Less height difference
            
            itemDiv.style.cssText = `
                width: ${width}px;
                height: ${height}px;
                cursor: grab;
                user-select: none;
                transition: transform 0.2s, box-shadow 0.2s;
                margin: 2px;
                position: relative;
                background-size: contain;
                background-repeat: no-repeat;
                background-position: center;
                background-image: url('assets/items/${item.imageKey}.png');
            `;
            
            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.style.cssText = `
                position: absolute;
                background-color: rgba(186, 85, 211, 0.95);
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 12px;
                font-weight: bold;
                white-space: nowrap;
                z-index: 1000;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.2s;
                min-height: 20px;
                display: flex;
                align-items: center;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            `;
            
            // Calculate size information for tooltip content
            const itemSize = item.size || { width: 1, height: 1 };
            const totalCells = itemSize.width * itemSize.height;
            const cellText = totalCells === 1 ? 'cell' : 'cells';
            tooltip.innerHTML = `${item.name} (${totalCells} ${cellText})`;
            
            // Add arrow to tooltip
            const arrow = document.createElement('div');
            arrow.style.cssText = `
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                width: 0;
                height: 0;
                border-left: 6px solid transparent;
                border-right: 6px solid transparent;
                border-top: 6px solid rgba(186, 85, 211, 0.95);
            `;
            tooltip.appendChild(arrow);
            
            // Add tooltip to body
            document.body.appendChild(tooltip);
            
            // Add hover effects with tooltip
            itemDiv.addEventListener('mouseenter', function(e) {
                if (item.inBank) {
                    this.style.transform = 'scale(1.05)';
                    this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
                    
                    // Position tooltip using element-relative coordinates with scroll offset
                    const rect = this.getBoundingClientRect();
                    const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                    const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                    
                    // Calculate tooltip position relative to the item element
                    const tooltipWidth = tooltip.offsetWidth;
                    const tooltipHeight = tooltip.offsetHeight;
                    const itemCenterX = rect.left + scrollX + (rect.width / 2);
                    const itemTopY = rect.top + scrollY;
                    
                    // Center tooltip horizontally above the item
                    let tooltipLeft = itemCenterX - (tooltipWidth / 2);
                    let tooltipTop = itemTopY - tooltipHeight - 8;
                    
                    // Ensure tooltip doesn't go off-screen horizontally
                    const minLeft = 10;
                    const maxLeft = window.innerWidth - tooltipWidth - 10;
                    tooltipLeft = Math.max(minLeft, Math.min(tooltipLeft, maxLeft));
                    
                    // Ensure tooltip doesn't go off-screen vertically
                    if (tooltipTop < 10) {
                        tooltipTop = itemTopY + rect.height + 8; // Position below item if no space above
                    }
                    
                    tooltip.style.left = tooltipLeft + 'px';
                    tooltip.style.top = tooltipTop + 'px';
                    tooltip.style.opacity = '1';
                }
            });
            
            itemDiv.addEventListener('mouseleave', function() {
                if (item.inBank) {
                    this.style.transform = 'scale(1)';
                    this.style.boxShadow = 'none';
                    tooltip.style.opacity = '0';
                }
            });
            
            // Store references
            item.htmlElement = itemDiv;
            item.tooltip = tooltip;
            itemDiv.itemData = item;
            
            return itemDiv;
        }

        function createGameSprite(item, x, y, needsRotation = false) {
            // Calculate sprite size based on the actual grid space it occupies
            const cellSize = gameState.cellSize;
            
            // For rotated items, the container should match the gap size (1x3), not the item's original size
            let spriteWidth, spriteHeight;
            if (needsRotation) {
                // Item is rotated to fit in a 1x3 vertical gap
                spriteWidth = cellSize * 1;  // 1 cell wide
                spriteHeight = cellSize * 3; // 3 cells tall
            } else {
                // Normal orientation - use item's original size
                spriteWidth = cellSize * item.size.width;
                spriteHeight = cellSize * item.size.height;
            }
            
            // Position items to align with grid cells - use top-left corner like gap indicators
            const adjustedX = x * cellSize;
            const adjustedY = y * cellSize;
            
            // Create HTML element for the circuit item positioned relative to canvas
            const canvas = document.querySelector('canvas');
            const canvasContainer = canvas.parentElement;
            
            // Ensure canvas container has relative positioning
            if (canvasContainer && canvasContainer.style.position !== 'relative') {
                canvasContainer.style.position = 'relative';
            }
            
            const itemElement = document.createElement('div');
            
            if (needsRotation) {
                // For rotated items, create a container that fills the gap (1x3)
                itemElement.style.cssText = `
                    position: absolute;
                    left: ${adjustedX}px;
                    top: ${adjustedY}px;
                    width: ${spriteWidth}px;
                    height: ${spriteHeight}px;
                    pointer-events: none;
                    z-index: 10;
                    cursor: pointer;
                `;
                
                // Create the rotated image that fills the container
                // The key insight: we want the image to fill the 1x3 container when rotated
                // So we need to size it as 3x1 initially, then rotate it
                const imageDiv = document.createElement('div');
                imageDiv.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: ${spriteHeight}px;
                    height: ${spriteWidth}px;
                    background-image: url('assets/items/${item.imageKey}.png');
                    background-size: contain;
                    background-repeat: no-repeat;
                    background-position: center;
                    transform: translate(-50%, -50%) rotate(90deg);
                    transform-origin: center;
                `;
                itemElement.appendChild(imageDiv);
            } else {
                // Normal orientation
                itemElement.style.cssText = `
                    position: absolute;
                    left: ${adjustedX}px;
                    top: ${adjustedY}px;
                    width: ${spriteWidth}px;
                    height: ${spriteHeight}px;
                    background-image: url('assets/items/${item.imageKey}.png');
                    background-size: contain;
                    background-repeat: no-repeat;
                    background-position: center;
                    pointer-events: none;
                    z-index: 10;
                    cursor: pointer;
                `;
            }
            
            // Append to canvas container instead of body
            if (canvasContainer) {
                canvasContainer.appendChild(itemElement);
            } else {
                // Fallback to canvas parent or body
                canvas.parentNode.appendChild(itemElement);
            }
            
            // Create an invisible Phaser sprite for interaction handling (centered for Phaser)
            const phaserCenterX = adjustedX + spriteWidth/2;
            const phaserCenterY = adjustedY + spriteHeight/2;
            const itemSprite = scene.add.rectangle(phaserCenterX, phaserCenterY, spriteWidth, spriteHeight, 0x000000, 0.01);
            itemSprite.htmlElement = itemElement;
            
            // Store positioning function for updates
            itemSprite.updateHtmlPosition = function() {
                if (this.htmlElement) {
                    // Convert Phaser center position to HTML top-left position relative to canvas
                    this.htmlElement.style.left = (this.x - spriteWidth/2) + 'px';
                    this.htmlElement.style.top = (this.y - spriteHeight/2) + 'px';
                }
            };
            
            // Set initial position correctly
            setTimeout(() => {
                itemSprite.updateHtmlPosition();
            }, 10);
            
            // Size indicator and text removed for cleaner visual design
            
            // Store original position and dimensions for drag distance calculation
            item.originalX = phaserCenterX;
            item.originalY = phaserCenterY;
            item.originalGridX = x;
            item.originalGridY = y;
            item.spriteHeight = spriteHeight;
            
            // Only make draggable if it's not a pre-placed component
            if (!isPreplacedComponent(x, y)) {
                itemSprite.setInteractive({ 
                    draggable: true,
                    useHandCursor: true
                });
                
                // Add removal hint on hover
                itemSprite.on('pointerover', function() {
                    if (this.htmlElement) {
                        this.htmlElement.style.filter = 'brightness(0.7) sepia(1) hue-rotate(0deg) saturate(2)';
                        this.htmlElement.style.cursor = 'grab';
                    }
                    // Show tooltip hint
                    if (!item.isDragging) {
                        showFeedback('ðŸ’¡ Tip: Drag this item away to remove it from the circuit!', 'info');
                    }
                });
                
                itemSprite.on('pointerout', function() {
                    if (!item.isDragging && this.htmlElement) {
                        this.htmlElement.style.filter = 'none';
                        this.htmlElement.style.cursor = 'pointer';
                    }
                });
                
                // Enhanced drag functionality for removal with distance threshold detection
                itemSprite.on('dragstart', function(pointer, dragX, dragY) {
                    console.log('Started dragging placed item for potential removal');
                    item.isDragging = true;
                    
                    // Temporarily remove from placed items list
                    const itemIndex = gameState.placedItems.indexOf(item);
                    if (itemIndex > -1) {
                        gameState.placedItems.splice(itemIndex, 1);
                    }
                    
                    // Immediately show the gap indicator and clear grid positions when dragging starts
                    const effectiveWidth = item.isRotated ? item.size.height : item.size.width;
                    const effectiveHeight = item.isRotated ? item.size.width : item.size.height;
                    
                    // Clear grid positions occupied by this item
                    for (let dy = 0; dy < effectiveHeight; dy++) {
                        for (let dx = 0; dx < effectiveWidth; dx++) {
                            setGridPosition(item.gridX + dx, item.gridY + dy, null);
                        }
                    }
                    
                    const gap = gameState.gaps.find(g => {
                        if (item.isRotated) {
                            return g.x === item.gridX && g.y === item.gridY &&
                                   g.size.width === effectiveWidth && g.size.height === effectiveHeight;
                        } else {
                            return g.x === item.gridX && g.y === item.gridY &&
                                   g.size.width === effectiveWidth && g.size.height === effectiveHeight;
                        }
                    });
                    
                    if (gap) {
                        // Temporarily mark gap as unfilled and show indicator
                        gap.filled = false;
                        gap.filledWith = null;
                        if (gap.sprite) {
                            gap.sprite.setVisible(true);
                        }
                        console.log('Gap indicator shown for dragging item');
                    }
                    
                    // Visual feedback - make semi-transparent and bring to front
                    if (this.htmlElement) {
                        this.htmlElement.style.opacity = '0.8';
                        this.htmlElement.style.zIndex = '1000';
                        this.htmlElement.style.filter = 'brightness(0.7) sepia(1) hue-rotate(0deg) saturate(2)';
                    }
                    
                    // Show initial drag feedback
                    showFeedback('Drag away from circuit to remove item, or drop back to replace', 'info');
                });
                
                itemSprite.on('drag', function(pointer, dragX, dragY) {
                    // Update positions
                    this.x = dragX;
                    this.y = dragY;
                    
                    // Update HTML element position (relative to canvas)
                    if (this.htmlElement) {
                        this.htmlElement.style.left = (dragX - spriteWidth/2) + 'px';
                        this.htmlElement.style.top = (dragY - spriteHeight/2) + 'px';
                    }
                    
                    // Enhanced distance threshold detection
                    const distance = Phaser.Math.Distance.Between(
                        item.originalX, item.originalY, dragX, dragY
                    );
                    
                    // Remove item when dragged outside its occupied cells
                    const REMOVAL_THRESHOLD = gameState.cellSize * 0.75; // 75% of a cell size
                    
                    if (distance > REMOVAL_THRESHOLD) {
                        // Visual feedback for removal zone
                        if (this.htmlElement) {
                            this.htmlElement.style.filter = 'brightness(0.5) sepia(1) hue-rotate(0deg) saturate(3)';
                            this.htmlElement.style.opacity = '0.6';
                        }
                        
                        // Show removal hint with icon
                        if (!item.removalHint) {
                            item.removalHint = scene.add.text(dragX, dragY - 40, 'ðŸ—‘ï¸ Release to remove', {
                                fontSize: '12px',
                                fill: '#FF0000',
                                backgroundColor: '#ffffff',
                                padding: { x: 6, y: 3 }
                            }).setOrigin(0.5).setDepth(1001);
                        } else {
                            item.removalHint.x = dragX;
                            item.removalHint.y = dragY - 40;
                        }
                        
                        // Update feedback message
                        showFeedback('Release to remove item from circuit', 'error');
                    } else {
                        // Normal drag visual feedback
                        if (this.htmlElement) {
                            this.htmlElement.style.filter = 'brightness(0.7) sepia(1) hue-rotate(0deg) saturate(2)';
                            this.htmlElement.style.opacity = '0.8';
                        }
                        
                        // Hide removal hint
                        if (item.removalHint) {
                            item.removalHint.destroy();
                            item.removalHint = null;
                        }
                        
                        // Update feedback message
                        showFeedback('Drag outside the cell to remove item', 'info');
                    }
                });
                
                itemSprite.on('dragend', function(pointer, dragX, dragY) {
                    console.log('Ended dragging placed item');
                    item.isDragging = false;
                    
                    // Clean up removal hint
                    if (item.removalHint) {
                        item.removalHint.destroy();
                        item.removalHint = null;
                    }
                    
                    // Use the sprite's current position instead of dragX/dragY which might be unreliable
                    const currentX = this.x;
                    const currentY = this.y;
                    
                    console.log('Sprite current position:', currentX, currentY);
                    console.log('Drag event coords:', dragX, dragY);
                    
                    // Check distance from original position using sprite position
                    const distance = Phaser.Math.Distance.Between(
                        item.originalX, item.originalY, currentX, currentY
                    );
                    
                    // Remove item when dragged outside its occupied cells  
                    const REMOVAL_THRESHOLD = gameState.cellSize * 0.75; // 75% of a cell size
                    
                    // Create a temporary drag state for checking
                    gameState.draggedItem = item;
                    gameState.isDragging = true;
                    
                    // Check if the canvas coordinates are within bounds and find matching gap
                    const gridPos = worldToGrid(currentX, currentY);
                    console.log('Grid position from sprite coords:', gridPos);
                    
                    // Always check if the item is being dropped back in its original position first
                    let directGapCheck = null;
                    
                    // Check if the current sprite position is close to the original position
                    const originalPos = gridToWorld(item.originalGridX, item.originalGridY);
                    const distanceFromOriginal = Phaser.Math.Distance.Between(
                        originalPos.x, originalPos.y, currentX, currentY
                    );
                    
                    console.log('Distance from original grid position:', distanceFromOriginal);
                    
                    // If close to original position, prioritize placing back in original gap
                    if (distanceFromOriginal < gameState.cellSize * 1.5) { // Within 1.5 cells of original
                        console.log('Close to original position, checking original gap');
                        directGapCheck = gameState.gaps.find(gap => {
                            const effectiveWidth = item.isRotated ? item.size.height : item.size.width;
                            const effectiveHeight = item.isRotated ? item.size.width : item.size.height;
                            
                            return gap.x === item.originalGridX && 
                                   gap.y === item.originalGridY &&
                                   gap.size.width === effectiveWidth && 
                                   gap.size.height === effectiveHeight &&
                                   !gap.filled; // Should be unfilled since we cleared it on drag start
                        });
                    }
                    
                    // If not found at original position, try to find gap at the current drag position
                    if (!directGapCheck) {
                        console.log('Not at original position, checking current drag position');
                        directGapCheck = gameState.gaps.find(gap => {
                            if (gap.filled) return false;
                            
                            // Check if grid position is within gap bounds
                            const withinGap = gridPos.x >= gap.x && 
                                             gridPos.x < gap.x + gap.size.width &&
                                             gridPos.y >= gap.y && 
                                             gridPos.y < gap.y + gap.size.height;
                            
                            // Check size compatibility (including rotation)
                            const normalMatch = (item.size.width === gap.size.width && 
                                               item.size.height === gap.size.height);
                            const rotatedMatch = (item.size.width === 3 && item.size.height === 1 &&
                                                gap.size.width === 1 && gap.size.height === 3);
                            
                            return withinGap && (normalMatch || rotatedMatch);
                        });
                    }
                    
                    console.log('Direct gap check result:', directGapCheck);
                    
                    // Use direct gap check if available, otherwise fall back to screen coordinate method
                    let dropResult;
                    if (directGapCheck) {
                        const needsRotation = (item.size.width === 3 && item.size.height === 1 &&
                                             directGapCheck.size.width === 1 && directGapCheck.size.height === 3);
                        dropResult = {
                            valid: true,
                            gridX: directGapCheck.x,
                            gridY: directGapCheck.y,
                            gap: directGapCheck,
                            needsRotation: needsRotation
                        };
                    } else {
                        dropResult = checkDropLocationFromCanvas(currentX, currentY);
                    }
                    
                    console.log('Final drop result:', dropResult);
                    

                    
                    // Set up temporary drag state for drop checking
                    gameState.draggedItem = item;
                    gameState.isDragging = true;
                    
                    console.log('Item original position:', item.originalGridX, item.originalGridY);
                    console.log('Item current position:', item.gridX, item.gridY);
                    console.log('Distance from original:', distance);
                    
                    // Clean up temporary drag state
                    gameState.draggedItem = null;
                    gameState.isDragging = false;
                    
                    if (dropResult.valid) {
                        // Item is being dropped in a valid gap - place it there
                        console.log('Item dropped in valid gap at:', dropResult.gridX, dropResult.gridY);
                        
                        // If it's not the original position, we need to clear the original gap first
                        if (dropResult.gridX !== item.originalGridX || dropResult.gridY !== item.originalGridY) {
                            // Clear original position
                            const originalGap = gameState.gaps.find(g => {
                                const effectiveWidth = item.isRotated ? item.size.height : item.size.width;
                                const effectiveHeight = item.isRotated ? item.size.width : item.size.height;
                                
                                return g.x === item.originalGridX && g.y === item.originalGridY &&
                                       g.size.width === effectiveWidth && g.size.height === effectiveHeight;
                            });
                            
                            if (originalGap) {
                                originalGap.filled = false;
                                originalGap.filledWith = null;
                                if (originalGap.sprite) {
                                    originalGap.sprite.setVisible(true);
                                }
                            }
                        }
                        
                        // Remove current sprite
                        this.disableInteractive();
                        if (this.htmlElement) {
                            this.htmlElement.remove();
                            this.htmlElement = null;
                        }
                        
                        // Place item in new position
                        placeItemOnGrid(item, dropResult.gridX, dropResult.gridY, dropResult.needsRotation);
                        
                        showFeedback('âœ… Item placed successfully!', 'success');
                        
                    } else if (distanceFromOriginal > REMOVAL_THRESHOLD) {
                        // Item dragged far away from original position - remove it
                        console.log('Item dragged beyond removal threshold - removing');
                        
                        // Disable dragging to prevent further interaction
                        this.disableInteractive();
                        
                        // Immediately clean up HTML element at current drag position
                        if (this.htmlElement) {
                            console.log('Removing HTML element at drag end position');
                            this.htmlElement.remove();
                            this.htmlElement = null;
                        }
                        
                        // Enhanced return to bank with animation (handles gap state internally)
                        returnItemToBank(item);
                        
                        // Show success feedback with animation
                        showFeedback('âœ… Item returned to bank! You can place it again.', 'success');
                        
                    } else {
                        // Return to original position - restore gap state
                        const gap = gameState.gaps.find(g => {
                            const effectiveWidth = item.isRotated ? item.size.height : item.size.width;
                            const effectiveHeight = item.isRotated ? item.size.width : item.size.height;
                            
                            return g.x === item.originalGridX && g.y === item.originalGridY &&
                                   g.size.width === effectiveWidth && g.size.height === effectiveHeight;
                        });
                        
                        if (gap) {
                            gap.filled = true;
                            gap.filledWith = item;
                            if (gap.sprite) {
                                gap.sprite.setVisible(false);
                            }
                        }
                        
                        // Re-add to placed items list
                        if (!gameState.placedItems.includes(item)) {
                            gameState.placedItems.push(item);
                        }
                        
                        // Restore grid positions
                        const effectiveWidth = item.isRotated ? item.size.height : item.size.width;
                        const effectiveHeight = item.isRotated ? item.size.width : item.size.height;
                        for (let dy = 0; dy < effectiveHeight; dy++) {
                            for (let dx = 0; dx < effectiveWidth; dx++) {
                                setGridPosition(item.originalGridX + dx, item.originalGridY + dy, item);
                            }
                        }
                        
                        // Return to original position with smooth animation
                        scene.tweens.add({
                            targets: this,
                            x: item.originalX,
                            y: item.originalY,
                            duration: 300,
                            ease: 'Back.easeOut',
                            onUpdate: () => {
                                // Update HTML element position during animation (relative to canvas)
                                if (this.htmlElement) {
                                    this.htmlElement.style.left = (this.x - spriteWidth/2) + 'px';
                                    this.htmlElement.style.top = (this.y - spriteHeight/2) + 'px';
                                }
                            }
                        });
                        
                        // Reset visual state
                        if (this.htmlElement) {
                            this.htmlElement.style.filter = 'none';
                            this.htmlElement.style.opacity = '1.0';
                            this.htmlElement.style.zIndex = '10';
                        }
                        
                        // Show feedback
                        showFeedback('Item returned to original position. Drag further to remove.', 'info');
                    }
                });
            } else {
                // For pre-placed components, show feedback that they can't be removed
                itemSprite.setInteractive();
                itemSprite.on('pointerdown', function() {
                    showFeedback('âŒ Pre-placed components (battery, bulb, wires) cannot be removed', 'error');
                });
                
                itemSprite.on('pointerover', function() {
                    if (this.htmlElement) {
                        this.htmlElement.style.filter = 'brightness(1.2) sepia(0.3) hue-rotate(30deg)';
                    }
                    showFeedback('This is a pre-placed component and cannot be removed', 'info');
                });
                
                itemSprite.on('pointerout', function() {
                    if (this.htmlElement) {
                        this.htmlElement.style.filter = 'none';
                    }
                });
            }
            
            // Group all components
            const spriteGroup = scene.add.group([itemSprite]);
            
            // Store references
            item.sprite = spriteGroup;
            item.mainSprite = itemSprite;
            
            return spriteGroup;
        }

        function returnItemToBank(item) {
            console.log('Returning item to bank:', item.name);
            
            // Store the original grid position before clearing item state
            const originalGridX = item.gridX >= 0 ? item.gridX : item.originalGridX;
            const originalGridY = item.gridY >= 0 ? item.gridY : item.originalGridY;
            
            // Clean up HTML element if it exists - multiple approaches for robustness
            let htmlElementRemoved = false;
            
            if (item.sprite && item.sprite.htmlElement) {
                console.log('Removing HTML element for item:', item.name);
                item.sprite.htmlElement.remove();
                item.sprite.htmlElement = null;
                htmlElementRemoved = true;
            }
            
            // Fallback: search for and remove any HTML elements at the original position
            if (!htmlElementRemoved) {
                const canvas = document.querySelector('canvas');
                const canvasContainer = canvas.parentElement;
                if (canvasContainer) {
                    const itemElements = canvasContainer.querySelectorAll('div[style*="background-image"][style*="assets/items"]');
                    itemElements.forEach(element => {
                        // Check if this element is positioned at the item's location
                        const elementLeft = parseInt(element.style.left);
                        const elementTop = parseInt(element.style.top);
                        const expectedLeft = originalGridX * gameState.cellSize;
                        const expectedTop = originalGridY * gameState.cellSize;
                        
                        if (Math.abs(elementLeft - expectedLeft) < 10 && Math.abs(elementTop - expectedTop) < 10) {
                            console.log('Removing HTML element by position match');
                            element.remove();
                            htmlElementRemoved = true;
                        }
                    });
                }
            }
            
            if (!htmlElementRemoved) {
                console.warn('No HTML element found to remove for item:', item.name);
            }
            
            // Immediately destroy the sprite to prevent visual duplication
            if (item.sprite && item.mainSprite) {
                // Create a temporary sprite for the return animation from the original position
                const originalPos = gridToWorld(originalGridX, originalGridY);
                const tempSprite = scene.add.rectangle(
                    originalPos.x, 
                    originalPos.y, 
                    40, 20, 
                    item.color
                );
                tempSprite.setStrokeStyle(2, 0x4CAF50);
                tempSprite.setDepth(2000);
                
                // Immediately hide and destroy all sprite components
                try {
                    // First, make all sprites invisible immediately
                    if (item.sprite.children && item.sprite.children.entries) {
                        item.sprite.children.entries.forEach(child => {
                            if (child) {
                                child.setVisible(false);
                                child.setActive(false);
                            }
                        });
                    }
                    
                    // Also hide the main sprite directly if accessible
                    if (item.mainSprite) {
                        item.mainSprite.setVisible(false);
                        item.mainSprite.setActive(false);
                    }
                    
                    // Clear the group
                    item.sprite.clear(true, true); // Remove and destroy all children
                    
                    // Destroy the group itself
                    item.sprite.destroy();
                    
                } catch (error) {
                    console.warn('Error destroying sprite:', error);
                    // Fallback: try to destroy the group directly
                    if (item.sprite && item.sprite.destroy) {
                        item.sprite.destroy();
                    }
                }
                
                // Clear references
                item.sprite = null;
                item.mainSprite = null;
                
                // Animate the temporary sprite moving to item bank area
                const itemBankElement = item.htmlElement;
                const itemBankRect = itemBankElement ? itemBankElement.getBoundingClientRect() : null;
                const canvas = document.querySelector('canvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                let targetX = 50; // Default fallback position
                let targetY = 50;
                
                if (itemBankRect && canvasRect) {
                    // Calculate relative position within canvas
                    targetX = itemBankRect.left - canvasRect.left + itemBankRect.width / 2;
                    targetY = itemBankRect.top - canvasRect.top + itemBankRect.height / 2;
                }
                
                // Animate return to bank
                scene.tweens.add({
                    targets: tempSprite,
                    x: targetX,
                    y: targetY,
                    scaleX: 0.5,
                    scaleY: 0.5,
                    alpha: 0.8,
                    duration: 500,
                    ease: 'Power2',
                    onComplete: () => {
                        tempSprite.destroy();
                        
                        // Flash the HTML element to show it's back
                        if (itemBankElement) {
                            itemBankElement.style.animation = 'pulse 0.5s ease-in-out';
                            setTimeout(() => {
                                itemBankElement.style.animation = '';
                            }, 500);
                        }
                    }
                });
            }
            
            // Clear grid position
            if (originalGridX >= 0 && originalGridY >= 0) {
                setGridPosition(originalGridX, originalGridY, null);
            }
            
            // Handle gap state - find gap that contains this position (for multi-cell items)
            const gap = gameState.gaps.find(g => {
                const gapSize = g.size || { width: 1, height: 1 };
                return originalGridX >= g.x && 
                       originalGridX < g.x + gapSize.width &&
                       originalGridY >= g.y && 
                       originalGridY < g.y + gapSize.height;
            });
            
            if (gap) {
                gap.filled = false;
                gap.filledWith = null;
                if (gap.sprite) {
                    gap.sprite.setVisible(true);
                }
                
                // Clear all grid positions for this gap
                const gapSize = gap.size || { width: 1, height: 1 };
                for (let dy = 0; dy < gapSize.height; dy++) {
                    for (let dx = 0; dx < gapSize.width; dx++) {
                        setGridPosition(gap.x + dx, gap.y + dy, 'gap');
                    }
                }
                
                console.log('Gap indicator restored for gap at:', gap.x, gap.y, 'size:', gapSize);
            } else {
                console.log('No gap found containing position:', originalGridX, originalGridY);
            }
            
            // Ensure all drop zone highlights are cleared (removes green highlighting)
            highlightDropZones(false);
            
            // Reset item state
            item.inBank = true;
            item.placed = false;
            item.gridX = -1;
            item.gridY = -1;
            item.isDragging = false;
            item.isRotated = false; // Reset rotation state
            
            // Clear any stored positions
            item.originalX = undefined;
            item.originalY = undefined;
            item.originalGridX = undefined;
            item.originalGridY = undefined;
            
            // Clean up any removal hints
            if (item.removalHint) {
                item.removalHint.destroy();
                item.removalHint = null;
            }
            
            // Show HTML element again with enhanced visual feedback
            if (item.htmlElement) {
                item.htmlElement.style.display = 'flex';
                item.htmlElement.style.cursor = 'grab';
                item.htmlElement.style.opacity = '1';
                item.htmlElement.style.transform = 'scale(1)';
                
                // Add a brief highlight effect
                item.htmlElement.style.boxShadow = '0 0 10px #4CAF50';
                setTimeout(() => {
                    item.htmlElement.style.boxShadow = '';
                }, 1000);
            }
            
            // Remove from placed items array
            const itemIndex = gameState.placedItems.indexOf(item);
            if (itemIndex > -1) {
                gameState.placedItems.splice(itemIndex, 1);
                console.log('Removed item from placedItems array');
            }
            
            // Update wire connections when item is removed
            updateWireConnections();
            
            // Stop current flow animation since circuit is now incomplete
            visualizeCurrentFlow(false);
            
            // Re-evaluate circuit to turn off bulb if circuit is now broken
            evaluateCircuit();
            
            console.log('Item successfully returned to bank');
        }

        function placeItemOnGrid(item, gridX, gridY, needsRotation = false) {
            
            // Hide HTML element
            if (item.htmlElement) {
                item.htmlElement.style.display = 'none';
            }
            
            // Store rotation state
            item.isRotated = needsRotation;
            
            // Create game sprite with rotation
            createGameSprite(item, gridX, gridY, needsRotation);
            
            // Update item state
            item.inBank = false;
            item.placed = true;
            item.gridX = gridX;
            item.gridY = gridY;
            
            // Update grid - mark all cells occupied by this item (considering rotation)
            const effectiveWidth = needsRotation ? item.size.height : item.size.width;
            const effectiveHeight = needsRotation ? item.size.width : item.size.height;
            
            for (let dy = 0; dy < effectiveHeight; dy++) {
                for (let dx = 0; dx < effectiveWidth; dx++) {
                    setGridPosition(gridX + dx, gridY + dy, item);
                }
            }
            
            // Check if this fills a gap (considering rotation)
            const gap = gameState.gaps.find(g => {
                if (needsRotation) {
                    return g.x === gridX && g.y === gridY &&
                           g.size.width === item.size.height &&
                           g.size.height === item.size.width;
                } else {
                    return g.x === gridX && g.y === gridY &&
                           g.size.width === item.size.width &&
                           g.size.height === item.size.height;
                }
            });
            
            if (gap) {
                gap.filled = true;
                gap.filledWith = item;
                if (gap.sprite) {
                    gap.sprite.setVisible(false);
                }
                
                // Show success feedback for correct placement
                const rotationText = needsRotation ? ' (rotated)' : '';
                showFeedback(`âœ… ${item.name} placed${rotationText}!`, 'success');
            }
            
            // Add to placed items
            gameState.placedItems.push(item);
            
            // Update wire connections when item is placed
            updateWireConnections();
        }

        function setupInputHandling() {
            // Set up drag and drop for item bank items
            setupItemBankDragDrop();
            
            // Set up canvas drop zone
            setupCanvasDropZone();
            
            // Set up placed item interaction
            setupPlacedItemInteraction();
            
            // Set up window resize handler to keep HTML elements positioned correctly
            window.addEventListener('resize', updateAllHtmlPositions);
        }
        
        function updateAllHtmlPositions() {
            // Update positions of all placed items
            gameState.placedItems.forEach(item => {
                if (item.sprite && item.sprite.updateHtmlPosition) {
                    item.sprite.updateHtmlPosition();
                }
            });
        }
        

        
        // Add a more frequent position update to handle any timing issues
        function startPositionUpdater() {
            setInterval(() => {
                updateAllHtmlPositions();
            }, 100); // Update every 100ms to catch any positioning issues
        }

        function setupItemBankDragDrop() {
            gameState.itemBank.forEach(item => {
                if (item.htmlElement) {
                    item.htmlElement.addEventListener('mousedown', function(e) {
                        if (item.inBank) {
                            startDragging(item, e);
                        }
                    });
                }
            });
        }

        function startDragging(item, e) {
            e.preventDefault();
            
            gameState.draggedItem = item;
            gameState.isDragging = true;
            
            // Create drag preview
            createDragPreview(item, e.clientX, e.clientY);
            
            // Change cursor
            document.body.style.cursor = 'grabbing';
            
            // Add global mouse move and up listeners
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
            
            // Highlight valid drop zones
            highlightDropZones(true);
        }

        function createDragPreview(item, x, y) {
            // Calculate preview size based on item's actual grid size - maintain original size
            const cellSize = gameState.cellSize;
            const previewWidth = cellSize * item.size.width; // Full size to match original item
            const previewHeight = cellSize * item.size.height;
            
            const preview = document.createElement('div');
            preview.id = 'drag-preview';
            preview.style.cssText = `
                position: fixed;
                left: ${x - previewWidth/2}px;
                top: ${y - previewHeight/2}px;
                width: ${previewWidth}px;
                height: ${previewHeight}px;
                background-image: url('assets/items/${item.imageKey}.png');
                background-size: contain;
                background-repeat: no-repeat;
                background-position: center;
                border: 2px solid #333;
                border-radius: 5px;
                opacity: 0.8;
                pointer-events: none;
                z-index: 1000;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            `;
            
            // No labels needed - just the image background
            
            document.body.appendChild(preview);
        }

        function handleDragMove(e) {
            if (!gameState.isDragging || !gameState.draggedItem) return;
            
            // Check if over valid drop zone and if rotation is needed
            const dropResult = checkDropLocation(e.clientX, e.clientY);
            
            // Update drag preview position and rotation
            const preview = document.getElementById('drag-preview');
            if (preview) {
                const previewWidth = parseFloat(preview.style.width);
                const previewHeight = parseFloat(preview.style.height);
                preview.style.left = (e.clientX - previewWidth/2) + 'px';
                preview.style.top = (e.clientY - previewHeight/2) + 'px';
                
                // Apply rotation if needed for vertical gaps
                if (dropResult.valid && dropResult.needsRotation) {
                    preview.style.transform = 'rotate(90deg)';
                    preview.style.opacity = '0.8';
                } else {
                    preview.style.transform = 'rotate(0deg)';
                    preview.style.opacity = '0.7';
                }
            }
            
            // Update drop zone highlighting
            updateDropZoneHighlight(e.clientX, e.clientY);
        }

        function handleDragEnd(e) {
            if (!gameState.isDragging || !gameState.draggedItem) return;
            
            // Remove drag preview
            const preview = document.getElementById('drag-preview');
            if (preview) {
                preview.remove();
            }
            
            // Check if dropped on valid location
            const dropResult = checkDropLocation(e.clientX, e.clientY);
            
            if (dropResult.valid) {
                // Place item on grid with rotation if needed
                placeItemOnGrid(gameState.draggedItem, dropResult.gridX, dropResult.gridY, dropResult.needsRotation);
            } else {
                // Return to bank (item stays in bank)
                console.log('Invalid drop location - item stays in bank');
            }
            
            // Clean up
            cleanupDrag();
        }

        function cleanupDrag() {
            // Remove event listeners
            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
            
            // Reset cursor
            document.body.style.cursor = 'default';
            
            // Hide drop zone highlights
            highlightDropZones(false);
            
            // Reset drag state
            gameState.draggedItem = null;
            gameState.isDragging = false;
        }

        function checkDropLocationFromCanvas(canvasX, canvasY) {
            console.log('checkDropLocationFromCanvas called with:', canvasX, canvasY);
            
            // Check if coordinates are within canvas bounds
            if (canvasX < 0 || canvasX > canvasSize || canvasY < 0 || canvasY > canvasSize) {
                console.log('Outside canvas bounds');
                return { valid: false };
            }
            
            // Convert to grid coordinates
            const gridPos = worldToGrid(canvasX, canvasY);
            console.log('Grid position:', gridPos);
            
            return checkDropAtGridPosition(gridPos);
        }

        function checkDropLocation(clientX, clientY) {
            // Get canvas bounds
            const canvas = document.querySelector('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            
            console.log('checkDropLocation called with:', clientX, clientY);
            console.log('Canvas rect:', canvasRect);
            
            // Check if over canvas
            if (clientX < canvasRect.left || clientX > canvasRect.right ||
                clientY < canvasRect.top || clientY > canvasRect.bottom) {
                console.log('Outside canvas bounds');
                return { valid: false };
            }
            
            // Convert to canvas coordinates
            const canvasX = clientX - canvasRect.left;
            const canvasY = clientY - canvasRect.top;
            console.log('Canvas coordinates:', canvasX, canvasY);
            
            // Convert to grid coordinates
            const gridPos = worldToGrid(canvasX, canvasY);
            console.log('Grid position:', gridPos);
            
            return checkDropAtGridPosition(gridPos);
        }

        function checkDropAtGridPosition(gridPos) {
            
            // Get the dragged item's size
            const draggedItem = gameState.draggedItem;
            if (!draggedItem || !draggedItem.size) {
                console.log('No dragged item or size');
                return { valid: false };
            }
            console.log('Dragged item:', draggedItem.name, 'size:', draggedItem.size);
            
            console.log('Available gaps:', gameState.gaps.map(g => ({
                x: g.x, y: g.y, 
                size: g.size, 
                filled: g.filled,
                filledWith: g.filledWith ? g.filledWith.name : null
            })));
            
            // Check if there's a gap that matches the item size (normal orientation)
            let matchingGap = gameState.gaps.find(gap => {
                console.log('Checking gap:', gap.x, gap.y, 'filled:', gap.filled, 'size:', gap.size);
                if (gap.filled || 
                    gap.size.width !== draggedItem.size.width ||
                    gap.size.height !== draggedItem.size.height) {
                    console.log('Gap rejected - filled or size mismatch');
                    return false;
                }
                
                // Check if the drop position is anywhere within the gap area
                const withinGap = gridPos.x >= gap.x && 
                                 gridPos.x < gap.x + gap.size.width &&
                                 gridPos.y >= gap.y && 
                                 gridPos.y < gap.y + gap.size.height;
                
                console.log('Within gap check:', withinGap);
                return withinGap;
            });
            
            let needsRotation = false;
            
            // If no normal match, check for rotated match (for 3-cell items in vertical gaps)
            if (!matchingGap && draggedItem.size.width === 3 && draggedItem.size.height === 1) {
                matchingGap = gameState.gaps.find(gap => {
                    if (gap.filled || 
                        gap.size.width !== 1 || gap.size.height !== 3) {
                        return false;
                    }
                    
                    // Check if the drop position is anywhere within the gap area
                    const withinGap = gridPos.x >= gap.x && 
                                     gridPos.x < gap.x + gap.size.width &&
                                     gridPos.y >= gap.y && 
                                     gridPos.y < gap.y + gap.size.height;
                    
                    return withinGap;
                });
                
                if (matchingGap) {
                    needsRotation = true;
                }
            }
            
            if (matchingGap) {
                // Check if all cells that the item would occupy are empty
                let allCellsEmpty = true;
                const checkWidth = needsRotation ? draggedItem.size.height : draggedItem.size.width;
                const checkHeight = needsRotation ? draggedItem.size.width : draggedItem.size.height;
                
                for (let dy = 0; dy < checkHeight; dy++) {
                    for (let dx = 0; dx < checkWidth; dx++) {
                        if (!isGridPositionEmpty(matchingGap.x + dx, matchingGap.y + dy)) {
                            allCellsEmpty = false;
                            break;
                        }
                    }
                    if (!allCellsEmpty) break;
                }
                
                if (allCellsEmpty) {
                    return { 
                        valid: true, 
                        gridX: matchingGap.x, 
                        gridY: matchingGap.y, 
                        gap: matchingGap,
                        needsRotation: needsRotation
                    };
                }
            }
            
            return { valid: false };
        }

        function highlightDropZones(show) {
            const draggedItem = gameState.draggedItem;
            
            gameState.gaps.forEach(gap => {
                if (!gap.filled && gap.sprite) {
                    const graphics = gap.sprite.getChildren()[0]; // Get the graphics object
                    const pos = gridToWorld(gap.x, gap.y);
                    
                    // Calculate gap size based on the gap's size property
                    const gapSize = gap.size || { width: 1, height: 1 };
                    const cellSize = gameState.cellSize;
                    
                    // Calculate proper center position for multi-cell gaps (same as markGaps)
                    const centerX = pos.x + (cellSize * (gapSize.width - 1)) / 2;
                    const centerY = pos.y + (cellSize * (gapSize.height - 1)) / 2;
                    
                    const width = (cellSize * gapSize.width) - 10;
                    const height = (cellSize * gapSize.height) - 10;
                    const x = centerX - width / 2;
                    const y = centerY - height / 2;
                    
                    graphics.clear();
                    
                    // Check if this gap is compatible with the dragged item (including rotation)
                    let isCompatible = false;
                    if (!draggedItem) {
                        isCompatible = false;
                    } else {
                        // Check normal orientation
                        const normalMatch = (draggedItem.size.width === gapSize.width && 
                                           draggedItem.size.height === gapSize.height);
                        
                        // Check rotated orientation (for 3-cell items in vertical gaps)
                        const rotatedMatch = (draggedItem.size.width === 3 && draggedItem.size.height === 1 &&
                                            gapSize.width === 1 && gapSize.height === 3);
                        
                        isCompatible = normalMatch || rotatedMatch;
                    }
                    
                    if (show && isCompatible) {
                        // Show solid green highlight for compatible gaps
                        graphics.lineStyle(3, 0x4CAF50, 1.0);
                        graphics.strokeRect(x, y, width, height);
                    } else if (show && !isCompatible) {
                        // Show orange highlight for incompatible gaps
                        graphics.lineStyle(2, 0xFF9800, 0.6);
                        graphics.strokeRect(x, y, width, height);
                    } else {
                        // Show dashed red outline (default state)
                        graphics.lineStyle(2, 0xFF6B6B, 0.8);
                        
                        const dashLength = 5;
                        const gapLength = 5;
                        
                        // Top line
                        for (let i = 0; i < width; i += dashLength + gapLength) {
                            const lineWidth = Math.min(dashLength, width - i);
                            graphics.moveTo(x + i, y);
                            graphics.lineTo(x + i + lineWidth, y);
                        }
                        
                        // Bottom line
                        for (let i = 0; i < width; i += dashLength + gapLength) {
                            const lineWidth = Math.min(dashLength, width - i);
                            graphics.moveTo(x + i, y + height);
                            graphics.lineTo(x + i + lineWidth, y + height);
                        }
                        
                        // Left line
                        for (let i = 0; i < height; i += dashLength + gapLength) {
                            const lineHeight = Math.min(dashLength, height - i);
                            graphics.moveTo(x, y + i);
                            graphics.lineTo(x, y + i + lineHeight);
                        }
                        
                        // Right line
                        for (let i = 0; i < height; i += dashLength + gapLength) {
                            const lineHeight = Math.min(dashLength, height - i);
                            graphics.moveTo(x + width, y + i);
                            graphics.lineTo(x + width, y + i + lineHeight);
                        }
                        
                        graphics.strokePath();
                    }
                }
            });
        }

        function updateDropZoneHighlight(clientX, clientY) {
            const dropResult = checkDropLocation(clientX, clientY);
            
            // Update cursor based on drop validity
            if (dropResult.valid) {
                document.body.style.cursor = 'copy';
            } else {
                document.body.style.cursor = 'not-allowed';
            }
        }

        function setupCanvasDropZone() {
            const canvas = document.querySelector('canvas');
            
            canvas.addEventListener('dragover', function(e) {
                e.preventDefault();
            });
            
            canvas.addEventListener('drop', function(e) {
                e.preventDefault();
                // Drag and drop is handled by mouse events
            });
        }

        function setupPlacedItemInteraction() {
            // Set up click handling for placed items (for removal)
            scene.input.on('gameobjectdown', function(pointer, gameObject) {
                // Find the item that was clicked
                const clickedItem = gameState.itemBank.find(item => 
                    item.mainSprite === gameObject
                );
                
                if (clickedItem && clickedItem.placed && !clickedItem.isDragging) {
                    // Check if it's a pre-placed component
                    if (isPreplacedComponent(clickedItem.gridX, clickedItem.gridY)) {
                        showFeedback('âŒ Pre-placed components cannot be removed', 'error');
                        return;
                    }
                    
                    // Only handle click removal if not dragging and not pre-placed
                    // Return item to bank (handles gap state internally)
                    returnItemToBank(clickedItem);
                    
                    // Show enhanced feedback
                    showFeedback('âœ… Item returned to bank! You can place it again or try different materials.', 'success');
                }
            });
        }

        // Utility functions
        function gridToWorld(gridX, gridY) {
            return {
                x: gridX * gameState.cellSize + gameState.cellSize / 2,
                y: gridY * gameState.cellSize + gameState.cellSize / 2
            };
        }

        function isPreplacedComponent(gridX, gridY) {
            // Check if position contains battery, bulb, or pre-placed wire
            const gridContent = getGridPosition(gridX, gridY);
            return gridContent === 'battery' || gridContent === 'bulb' || gridContent === 'wire';
        }

        function worldToGrid(worldX, worldY) {
            return {
                x: Math.floor(worldX / gameState.cellSize),
                y: Math.floor(worldY / gameState.cellSize)
            };
        }

        function isValidGridPosition(gridX, gridY) {
            return gridX >= 0 && gridX < gameState.gridWidth && 
                   gridY >= 0 && gridY < gameState.gridHeight;
        }

        function isGridPositionEmpty(gridX, gridY) {
            if (!isValidGridPosition(gridX, gridY)) return false;
            const gridContent = gameState.grid[gridY][gridX];
            // Allow placement on empty positions or gap positions
            return gridContent === null || gridContent === 'gap';
        }

        function setGridPosition(gridX, gridY, item) {
            if (isValidGridPosition(gridX, gridY)) {
                gameState.grid[gridY][gridX] = item;
            }
        }

        function getGridPosition(gridX, gridY) {
            if (isValidGridPosition(gridX, gridY)) {
                return gameState.grid[gridY][gridX];
            }
            return null;
        }

        // Circuit evaluation functions
        function evaluateCircuit() {
            console.log('=== EVALUATING CIRCUIT ===');
            
            // Check if all gaps are filled before testing
            const unfilledGaps = gameState.gaps.filter(gap => !gap.filled);
            if (unfilledGaps.length > 0) {
                console.log('Not all gaps are filled:', unfilledGaps.length, 'remaining');
                showFeedback(`Please fill all ${unfilledGaps.length} missing part${unfilledGaps.length > 1 ? 's' : ''} before testing the circuit!`, 'error');
                updateLightBulb(false);
                return false;
            }
            
            // Debug: Show current state of gaps
            console.log('Gap states:');
            gameState.gaps.forEach((gap, index) => {
                const item = getGridPosition(gap.x, gap.y);
                console.log(`Gap ${index} at (${gap.x},${gap.y}): filled=${gap.filled}, item=`, item);
            });
            
            // Find path from battery positive to battery negative through the bulb
            const hasCompletePath = findCircuitPath();
            
            console.log('Circuit evaluation result:', hasCompletePath);
            updateLightBulb(hasCompletePath);
            
            // Update wire connections to show the complete circuit path
            updateWireConnections();
            
            return hasCompletePath;
        }

        function findCircuitPath() {
            console.log('Checking circuit path...');
            console.log('Current layout:', gameState.currentLayout);
            console.log('Battery at:', gameState.battery.x, gameState.battery.y, 'size:', gameState.battery.width + 'x' + gameState.battery.height);
            console.log('Bulb at:', gameState.bulb.x, gameState.bulb.y, 'size:', gameState.bulb.width + 'x' + gameState.bulb.height);
            
            if (gameState.currentLayout === 'second') {
                // Second circuit layout with T-junctions
                return findSecondCircuitPath();
            } else {
                // First circuit layout (original)
                return findFirstCircuitPath();
            }
        }
        
        function findFirstCircuitPath() {
            // Original two-wire circuit: positive terminal -> top wire -> bulb -> bottom wire -> negative terminal
            const topWireY = 4;        // Top wire row
            const bottomWireY = 10;    // Bottom wire row
            
            // Check path from battery L-wire to bulb L-wire via top wire (row 4)
            const topPathComplete = checkPathSegment(3, topWireY, 11, topWireY);
            console.log('Top path (battery to bulb via top wire):', topPathComplete);
            
            // Check path from bulb L-wire to battery L-wire via bottom wire (row 10)
            const bottomPathComplete = checkPathSegment(11, bottomWireY, 3, bottomWireY);
            console.log('Bottom path (bulb to battery via bottom wire):', bottomPathComplete);
            
            // Check if vertical wire connections are conductive
            const batteryVWiresConnected = isConductive(2, 5) && isConductive(2, 9);
            const bulbVWiresConnected = isConductive(12, 5) && isConductive(12, 9);
            // Check if L-shaped wire connections are conductive
            const batteryLWiresConnected = isConductive(2, 4) && isConductive(2, 10);
            const bulbLWiresConnected = isConductive(12, 4) && isConductive(12, 10);
            console.log('Battery vertical wires connected:', batteryVWiresConnected);
            console.log('Battery L-wires connected:', batteryLWiresConnected);
            console.log('Bulb vertical wires connected:', bulbVWiresConnected);
            console.log('Bulb L-wires connected:', bulbLWiresConnected);
            
            const circuitComplete = topPathComplete && bottomPathComplete && batteryVWiresConnected && batteryLWiresConnected && bulbVWiresConnected && bulbLWiresConnected;
            console.log('First circuit complete:', circuitComplete);
            
            return circuitComplete;
        }
        
        function findSecondCircuitPath() {
            // Second circuit layout with T-junctions and multiple paths
            // Battery position: (1, 6-8), Bulb position: (11-13, 6-8)
            
            // Check if battery connections are conductive
            const batteryConnected = isConductive(1, 4) && isConductive(1, 5) && isConductive(1, 9) && isConductive(1, 10);
            console.log('Battery connections:', batteryConnected);
            
            // Check if bulb connections are conductive  
            const bulbConnected = isConductive(12, 4) && isConductive(12, 5) && isConductive(12, 9) && isConductive(12, 10);
            console.log('Bulb connections:', bulbConnected);
            
            if (!batteryConnected || !bulbConnected) {
                console.log('Battery or bulb not properly connected');
                return false;
            }
            
            // Check multiple possible paths using breadth-first search
            const hasPath = findPathBFS();
            console.log('Second circuit complete:', hasPath);
            
            return hasPath;
        }
        
        function findPathBFS() {
            // Use breadth-first search to find any complete path from battery to bulb
            const startPositions = [
                { x: 1, y: 4 }, // Battery top connection
                { x: 1, y: 10 } // Battery bottom connection
            ];
            
            const endPositions = [
                { x: 12, y: 4 }, // Bulb top connection
                { x: 12, y: 5 }, // Bulb side connections
                { x: 12, y: 9 },
                { x: 12, y: 10 } // Bulb bottom connection
            ];
            
            for (const start of startPositions) {
                for (const end of endPositions) {
                    if (findPathBetweenPoints(start, end)) {
                        console.log(`Found path from (${start.x},${start.y}) to (${end.x},${end.y})`);
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        function findPathBetweenPoints(start, end) {
            const queue = [start];
            const visited = new Set();
            visited.add(`${start.x},${start.y}`);
            
            const directions = [
                { dx: -1, dy: 0 }, // left
                { dx: 1, dy: 0 },  // right  
                { dx: 0, dy: -1 }, // up
                { dx: 0, dy: 1 }   // down
            ];
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Check if we reached the end
                if (current.x === end.x && current.y === end.y) {
                    return true;
                }
                
                // Explore adjacent positions
                for (const dir of directions) {
                    const nextX = current.x + dir.dx;
                    const nextY = current.y + dir.dy;
                    const key = `${nextX},${nextY}`;
                    
                    // Check bounds
                    if (nextX < 0 || nextX >= gameState.gridWidth || 
                        nextY < 0 || nextY >= gameState.gridHeight) {
                        continue;
                    }
                    
                    // Skip if already visited
                    if (visited.has(key)) {
                        continue;
                    }
                    
                    // Check if position is conductive
                    if (isConductive(nextX, nextY)) {
                        visited.add(key);
                        queue.push({ x: nextX, y: nextY });
                    }
                }
            }
            
            return false;
        }
        
        function checkPathSegment(startX, startY, endX, endY) {
            // Check if there's a continuous conductive path between two points
            console.log(`Checking path from (${startX},${startY}) to (${endX},${endY})`);
            
            // For horizontal wire segments, check each position along the path
            if (startY === endY) {
                // Horizontal path - check each position from start to end
                const minX = Math.min(startX, endX);
                const maxX = Math.max(startX, endX);
                
                for (let x = minX; x <= maxX; x++) {
                    if (!isConductive(x, startY)) {
                        console.log(`Path blocked at (${x},${startY})`);
                        return false;
                    }
                }
                console.log(`Complete horizontal path found from (${startX},${startY}) to (${endX},${endY})`);
                return true;
            }
            
            // For other paths, use breadth-first search
            const queue = [{x: startX, y: startY}];
            const visited = new Set();
            
            while (queue.length > 0) {
                const current = queue.shift();
                const key = `${current.x},${current.y}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                
                // Check if we reached the destination
                if (current.x === endX && current.y === endY) {
                    console.log(`Path found from (${startX},${startY}) to (${endX},${endY})`);
                    return true;
                }
                
                // Check adjacent positions
                const adjacent = [
                    {x: current.x + 1, y: current.y},
                    {x: current.x - 1, y: current.y},
                    {x: current.x, y: current.y + 1},
                    {x: current.x, y: current.y - 1}
                ];
                
                adjacent.forEach(pos => {
                    const adjKey = `${pos.x},${pos.y}`;
                    if (!visited.has(adjKey) && isConductive(pos.x, pos.y)) {
                        queue.push(pos);
                    }
                });
            }
            
            console.log(`No path found from (${startX},${startY}) to (${endX},${endY})`);
            return false;
        }

        function isConductive(x, y) {
            // Check bounds
            if (!isValidGridPosition(x, y)) {
                return false;
            }
            
            const gridItem = getGridPosition(x, y);
            
            // Empty positions are not conductive
            if (gridItem === null) {
                return false;
            }
            
            // Check different component types
            if (gridItem === 'battery' || gridItem === 'bulb' || gridItem === 'wire') {
                return true;
            }
            
            // Check placed items
            if (typeof gridItem === 'object' && gridItem.conductive !== undefined) {
                return gridItem.conductive;
            }
            
            // Default to non-conductive
            return false;
        }

        // Visual Connection System Functions
        function updateWireConnections() {
            console.log('Updating wire connections...');
            
            // Clear existing connection graphics
            clearConnectionGraphics();
            
            // Draw connections from battery terminals
            drawBatteryConnections();
            
            // Draw connections to bulb terminals
            drawBulbConnections();
            
            // For each placed conductive item, draw connections to adjacent components
            gameState.itemBank.forEach(item => {
                if (item.placed && item.conductive) {
                    drawConnectionsForItem(item);
                }
            });
            
            // Draw connections between pre-placed wires and adjacent components
            gameState.preplacedWires.forEach(wire => {
                drawConnectionsForWire(wire);
            });
            
            // If circuit is complete, draw the continuous path (without animation - handled by visualizeCurrentFlow)
            if (gameState.bulb.isLit) {
                drawContinuousPathOnly();
            }
            
            console.log('Wire connections updated');
        }

        function clearConnectionGraphics() {
            // Destroy all existing connection graphics
            gameState.connectionGraphics.forEach(graphic => {
                if (graphic && graphic.destroy) {
                    graphic.destroy();
                }
            });
            gameState.connectionGraphics = [];
        }

        function drawBatteryConnections() {
            // No extra connections needed - vertical wires at (2,3) and (2,7) are sufficient
            // The vertical wires show that the battery is hooked up to the circuit
        }

        function drawBulbConnections() {
            // No extra connections needed - vertical wires at (12,3) and (12,7) are sufficient
            // The vertical wires show that the light bulb is hooked up to the circuit
        }

        function drawConnectionsForItem(item) {
            // Removed wire drawing for placed items to keep gap indicators clean
            return;
        }

        function drawConnectionsForWire(wire) {
            // Removed wire drawing to adjacent items to keep circuit clean
            return;
        }

        function drawWireConnection(fromPos, toPos, color, lineWidth) {
            const graphics = scene.add.graphics();
            graphics.lineStyle(lineWidth, color, 0.8);
            
            // Draw connecting wire with proper endpoints
            graphics.moveTo(fromPos.x, fromPos.y);
            graphics.lineTo(toPos.x, toPos.y);
            graphics.strokePath();
            
            // Add subtle glow effect for active connections
            if (gameState.bulb.isLit) {
                const glowGraphics = scene.add.graphics();
                glowGraphics.lineStyle(lineWidth + 2, color, 0.3);
                glowGraphics.moveTo(fromPos.x, fromPos.y);
                glowGraphics.lineTo(toPos.x, toPos.y);
                glowGraphics.strokePath();
                glowGraphics.setDepth(-1);
                gameState.connectionGraphics.push(glowGraphics);
            }
            
            // Store reference for cleanup
            gameState.connectionGraphics.push(graphics);
        }

        function getAdjacentPositions(gridX, gridY) {
            const positions = [];
            
            // Check all 4 adjacent positions (up, down, left, right)
            const directions = [
                { x: 0, y: -1 }, // Up
                { x: 0, y: 1 },  // Down
                { x: -1, y: 0 }, // Left
                { x: 1, y: 0 }   // Right
            ];
            
            directions.forEach(dir => {
                const newX = gridX + dir.x;
                const newY = gridY + dir.y;
                
                if (isValidGridPosition(newX, newY)) {
                    positions.push({ x: newX, y: newY });
                }
            });
            
            return positions;
        }

        function drawContinuousPathOnly() {
            // Draw the complete electrical path when circuit is active (without animation)
            if (!gameState.bulb.isLit) return;
            
            console.log('Drawing continuous electrical path for layout:', gameState.currentLayout);
            
            // Create a special graphics object for the complete path
            const pathGraphics = scene.add.graphics();
            pathGraphics.lineStyle(6, 0xFFD700, 0.6); // Golden color for active path
            pathGraphics.setDepth(8); // Behind battery and bulb (depth 10) but above wires (depth 5)
            
            if (gameState.currentLayout === 'first') {
                drawFirstCircuitPath(pathGraphics);
            } else if (gameState.currentLayout === 'second') {
                drawSecondCircuitPath(pathGraphics);
            }
            
            pathGraphics.strokePath();
            
            // Store for cleanup
            gameState.connectionGraphics.push(pathGraphics);
        }
        
        function drawFirstCircuitPath(pathGraphics) {
            // First circuit path (original logic)
            // Start from battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            pathGraphics.moveTo(batteryTopPos.x, batteryTopPos.y - gameState.cellSize * 0.5);
            
            // Connect vertically to vertical wire at (2,5), then to L-shaped wire at (2,4), then horizontally to top wire at (3,4)
            const batteryVWirePos = gridToWorld(2, 5);
            pathGraphics.lineTo(batteryVWirePos.x, batteryVWirePos.y);
            const batteryLWirePos = gridToWorld(2, 4);
            pathGraphics.lineTo(batteryLWirePos.x, batteryLWirePos.y);
            const batteryTopWirePos = gridToWorld(3, 4);
            pathGraphics.lineTo(batteryTopWirePos.x, batteryTopWirePos.y);
            
            // Trace through top wire to bulb
            for (let x = 3; x <= 11; x++) {
                if (isConductive(x, 4)) { // Row 4 is top wire
                    const pos = gridToWorld(x, 4);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect horizontally from top wire to bulb L-shaped wire at (12,4)
            const bulbTopLWirePos = gridToWorld(12, 4);
            pathGraphics.lineTo(bulbTopLWirePos.x, bulbTopLWirePos.y);
            
            // Connect vertically to vertical wire at (12,5)
            const bulbTopVWirePos = gridToWorld(12, 5);
            pathGraphics.lineTo(bulbTopVWirePos.x, bulbTopVWirePos.y);
            
            // Connect to bulb (through the bulb component)
            const bulbCenterPos = gridToWorld(gameState.bulb.x + 1, gameState.bulb.y + 1);
            pathGraphics.lineTo(bulbCenterPos.x, bulbCenterPos.y);
            
            // Connect to vertical wire at (12,9)
            const bulbBottomVWirePos = gridToWorld(12, 9);
            pathGraphics.lineTo(bulbBottomVWirePos.x, bulbBottomVWirePos.y);
            
            // Connect vertically to bulb L-shaped wire at (12,10)
            const bulbBottomLWirePos = gridToWorld(12, 10);
            pathGraphics.lineTo(bulbBottomLWirePos.x, bulbBottomLWirePos.y);
            
            // Connect horizontally to bottom wire at (11,10)
            const bulbBottomWirePos = gridToWorld(11, 10);
            pathGraphics.lineTo(bulbBottomWirePos.x, bulbBottomWirePos.y);
            
            // Trace through bottom wire back to battery
            for (let x = 11; x >= 3; x--) {
                if (isConductive(x, 10)) { // Row 10 is bottom wire
                    const pos = gridToWorld(x, 10);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect horizontally from bottom wire to battery L-shaped wire at (2,10)
            const batteryBottomLWirePos = gridToWorld(2, 10);
            pathGraphics.lineTo(batteryBottomLWirePos.x, batteryBottomLWirePos.y);
            
            // Connect vertically to vertical wire at (2,9)
            const batteryBottomVWirePos = gridToWorld(2, 9);
            pathGraphics.lineTo(batteryBottomVWirePos.x, batteryBottomVWirePos.y);
            
            // End vertically at battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            pathGraphics.lineTo(batteryBottomPos.x, batteryBottomPos.y + gameState.cellSize * 0.5);
        }
        
        function drawSecondCircuitPath(pathGraphics) {
            // Second circuit path with T-junctions
            // Start from battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            pathGraphics.moveTo(batteryTopPos.x, batteryTopPos.y - gameState.cellSize * 0.5);
            
            // Connect vertically to vertical wire at (1,5), then to L-shaped wire at (1,4), then horizontally to top wire at (2,4)
            const batteryVWirePos = gridToWorld(1, 5);
            pathGraphics.lineTo(batteryVWirePos.x, batteryVWirePos.y);
            const batteryLWirePos = gridToWorld(1, 4);
            pathGraphics.lineTo(batteryLWirePos.x, batteryLWirePos.y);
            const batteryTopWirePos = gridToWorld(2, 4);
            pathGraphics.lineTo(batteryTopWirePos.x, batteryTopWirePos.y);
            
            // Trace through top wire to bulb
            for (let x = 2; x <= 12; x++) {
                if (isConductive(x, 4)) { // Row 4 is top wire
                    const pos = gridToWorld(x, 4);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect vertically to vertical wire at (12,5)
            const bulbTopVWirePos = gridToWorld(12, 5);
            pathGraphics.lineTo(bulbTopVWirePos.x, bulbTopVWirePos.y);
            
            // Connect to bulb (through the bulb component)
            const bulbCenterPos = gridToWorld(gameState.bulb.x + 1, gameState.bulb.y + 1);
            pathGraphics.lineTo(bulbCenterPos.x, bulbCenterPos.y);
            
            // Connect to vertical wire at (12,9)
            const bulbBottomVWirePos = gridToWorld(12, 9);
            pathGraphics.lineTo(bulbBottomVWirePos.x, bulbBottomVWirePos.y);
            
            // Connect vertically to bulb L-shaped wire at (12,10)
            const bulbBottomLWirePos = gridToWorld(12, 10);
            pathGraphics.lineTo(bulbBottomLWirePos.x, bulbBottomLWirePos.y);
            
            // Trace through bottom wire back to battery
            for (let x = 12; x >= 2; x--) {
                if (isConductive(x, 10)) { // Row 10 is bottom wire
                    const pos = gridToWorld(x, 10);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect horizontally from bottom wire to battery L-shaped wire at (1,10)
            const batteryBottomLWirePos = gridToWorld(1, 10);
            pathGraphics.lineTo(batteryBottomLWirePos.x, batteryBottomLWirePos.y);
            
            // Connect vertically to vertical wire at (1,9)
            const batteryBottomVWirePos = gridToWorld(1, 9);
            pathGraphics.lineTo(batteryBottomVWirePos.x, batteryBottomVWirePos.y);
            
            // End vertically at battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            pathGraphics.lineTo(batteryBottomPos.x, batteryBottomPos.y + gameState.cellSize * 0.5);
        }



        function visualizeCurrentFlow(hasFlow) {
            console.log('visualizeCurrentFlow called with hasFlow:', hasFlow);
            console.log('gameState.bulb.isLit:', gameState.bulb.isLit);
            console.log('scene available:', !!scene);
            
            // Remove existing flow visualization
            if (gameState.flowVisualization) {
                console.log('Cleaning up existing flow visualization, count:', gameState.flowVisualization.length);
                gameState.flowVisualization.forEach(particle => {
                    // Clean up animation timers
                    if (particle.animationTimer) {
                        particle.animationTimer.destroy();
                    }
                    if (particle.destroy) particle.destroy();
                });
                gameState.flowVisualization = [];
            }
            
            if (!hasFlow) {
                console.log('hasFlow is false, stopping animation');
                return;
            }
            
            if (!gameState.bulb.isLit) {
                console.log('Bulb is not lit, not starting animation');
                return;
            }
            
            // Create a chain of synchronized pulsating particles
            gameState.flowVisualization = [];
            
            console.log('Starting synchronized chain of pulsating particles...');
            
            // Build the complete circuit path
            const circuitPath = buildCompleteCircuitPath();
            console.log('Circuit path:', circuitPath);
            
            if (circuitPath.length === 0) {
                console.log('No valid circuit path found');
                return;
            }
            
            // Calculate particle count based on circuit path length
            const pathLength = circuitPath.length;
            const particleCount = Math.max(3, Math.floor(pathLength / 3)); // One particle every 3 path points, minimum 3
            
            console.log(`Circuit path length: ${pathLength}, Particle count: ${particleCount}`);
            
            const particles = [];
            
            // Create particles at evenly spaced positions along the path
            for (let i = 0; i < particleCount; i++) {
                // Calculate evenly spaced starting positions to maintain consistent distance
                const startIndex = Math.floor((i / particleCount) * pathLength);
                const startPosition = circuitPath[startIndex];
                
                console.log(`Creating particle ${i} at path index ${startIndex}, position:`, startPosition);
                
                // Create yellow particle
                const particle = scene.add.circle(startPosition.x, startPosition.y, 6, 0xFFFF00);
                particle.setAlpha(1.0);
                particle.setDepth(8); // Behind battery and bulb (depth 10) but above wires (depth 5)
                
                // Create yellow glow effect
                const glow = scene.add.circle(startPosition.x, startPosition.y, 12, 0xFFFF00);
                glow.setAlpha(0.4);
                glow.setDepth(7); // Behind particle
                
                particles.push({ 
                    particle, 
                    glow, 
                    startIndex: startIndex,
                    particleIndex: i 
                });
                gameState.flowVisualization.push(particle, glow);
                
                console.log(`Particle ${i} created successfully at evenly spaced position`);
            }
            
            console.log(`Created ${particles.length} particles in chain`);
            
            // Start synchronized pulsating animation
            startPulsatingChainAnimation(particles, circuitPath);
        }

        function buildCompleteCircuitPath() {
            console.log('Building circuit path for layout:', gameState.currentLayout);
            
            if (gameState.currentLayout === 'second') {
                return buildSecondCircuitPath();
            } else {
                return buildFirstCircuitPath();
            }
        }

        function buildFirstCircuitPath() {
            const path = [];
            const batteryPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            const bulbPos = gridToWorld(gameState.bulb.x, gameState.bulb.y);
            
            console.log('Building first circuit path...');
            console.log('Battery position:', batteryPos);
            console.log('Bulb position:', bulbPos);
            
            // Start at battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            path.push({ x: batteryTopPos.x, y: batteryTopPos.y - gameState.cellSize * 0.5, isTerminal: true });
            
            // Connection vertically to vertical wire at (2,5)
            const batteryVWirePos = gridToWorld(2, 5);
            path.push({ x: batteryVWirePos.x, y: batteryVWirePos.y, isWire: true });
            
            // Connection to L-shaped wire at (2,4)
            const batteryLWirePos = gridToWorld(2, 4);
            path.push({ x: batteryLWirePos.x, y: batteryLWirePos.y, isWire: true });
            
            // Connection horizontally to top wire at (3,4)
            const batteryTopWirePos = gridToWorld(3, 4);
            path.push({ x: batteryTopWirePos.x, y: batteryTopWirePos.y, isWire: true });
            
            // Top wire (positive path) from battery to bulb
            for (let x = 3; x <= 11; x++) {
                if (isConductive(x, 4)) { // Row 4 is top wire
                    const pos = gridToWorld(x, 4);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added top wire position: (${pos.x}, ${pos.y})`);
                }
            }
            
            // Connection horizontally from top wire to bulb L-shaped wire at (12,4)
            const bulbTopLWirePos = gridToWorld(12, 4);
            path.push({ x: bulbTopLWirePos.x, y: bulbTopLWirePos.y, isWire: true });
            
            // Connection vertically to vertical wire at (12,5)
            const bulbTopVWirePos = gridToWorld(12, 5);
            path.push({ x: bulbTopVWirePos.x, y: bulbTopVWirePos.y, isWire: true });
            
            // Connection to bulb (through the bulb component)
            const bulbCenterPos = gridToWorld(gameState.bulb.x + 1, gameState.bulb.y + 1);
            path.push({ x: bulbCenterPos.x, y: bulbCenterPos.y, isBulb: true });
            
            // Connection to vertical wire at (12,9)
            const bulbBottomVWirePos = gridToWorld(12, 9);
            path.push({ x: bulbBottomVWirePos.x, y: bulbBottomVWirePos.y, isWire: true });
            
            // Connection vertically to bulb L-shaped wire at (12,10)
            const bulbBottomLWirePos = gridToWorld(12, 10);
            path.push({ x: bulbBottomLWirePos.x, y: bulbBottomLWirePos.y, isWire: true });
            
            // Connection horizontally to bottom wire at (11,10)
            const bulbBottomWirePos = gridToWorld(11, 10);
            path.push({ x: bulbBottomWirePos.x, y: bulbBottomWirePos.y, isWire: true });
            
            // Bottom wire (negative path) from bulb back to battery
            for (let x = 11; x >= 3; x--) {
                if (isConductive(x, 10)) { // Row 10 is bottom wire
                    const pos = gridToWorld(x, 10);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added bottom wire position: (${pos.x}, ${pos.y})`);
                }
            }
            
            // Connection horizontally from bottom wire to battery L-shaped wire at (2,10)
            const batteryBottomLWirePos = gridToWorld(2, 10);
            path.push({ x: batteryBottomLWirePos.x, y: batteryBottomLWirePos.y, isWire: true });
            
            // Connection vertically to vertical wire at (2,9)
            const batteryBottomVWirePos = gridToWorld(2, 9);
            path.push({ x: batteryBottomVWirePos.x, y: batteryBottomVWirePos.y, isWire: true });
            
            // Battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            path.push({ x: batteryBottomPos.x, y: batteryBottomPos.y + gameState.cellSize * 0.5, isTerminal: true });
            
            console.log(`First circuit path built with ${path.length} points`);
            return path;
        }

        function buildSecondCircuitPath() {
            const path = [];
            
            console.log('Building second circuit path...');
            
            // Start at battery positive terminal (top cell)
            const batteryTopPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            path.push({ x: batteryTopPos.x, y: batteryTopPos.y - gameState.cellSize * 0.5, isTerminal: true });
            
            // Connection vertically to vertical wire at (1,5)
            const batteryVWirePos = gridToWorld(1, 5);
            path.push({ x: batteryVWirePos.x, y: batteryVWirePos.y, isWire: true });
            
            // Connection to L-shaped wire at (1,4)
            const batteryLWirePos = gridToWorld(1, 4);
            path.push({ x: batteryLWirePos.x, y: batteryLWirePos.y, isWire: true });
            
            // Connection horizontally to top wire at (2,4)
            const batteryTopWirePos = gridToWorld(2, 4);
            path.push({ x: batteryTopWirePos.x, y: batteryTopWirePos.y, isWire: true });
            
            // Top wire (positive path) from battery to T-junction
            for (let x = 2; x <= 6; x++) {
                if (isConductive(x, 4)) { // Row 4 is top wire
                    const pos = gridToWorld(x, 4);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added top wire position: (${pos.x}, ${pos.y})`);
                }
            }
            
            // At T-junction (6,4), continue horizontally to bulb
            for (let x = 6; x <= 12; x++) {
                if (isConductive(x, 4)) { // Continue on row 4
                    const pos = gridToWorld(x, 4);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added top wire position after T-junction: (${pos.x}, ${pos.y})`);
                }
            }
            
            // Connection vertically to vertical wire at (12,5)
            const bulbTopVWirePos = gridToWorld(12, 5);
            path.push({ x: bulbTopVWirePos.x, y: bulbTopVWirePos.y, isWire: true });
            
            // Connection to bulb (through the bulb component)
            const bulbCenterPos = gridToWorld(gameState.bulb.x + 1, gameState.bulb.y + 1);
            path.push({ x: bulbCenterPos.x, y: bulbCenterPos.y, isBulb: true });
            
            // Connection to vertical wire at (12,9)
            const bulbBottomVWirePos = gridToWorld(12, 9);
            path.push({ x: bulbBottomVWirePos.x, y: bulbBottomVWirePos.y, isWire: true });
            
            // Connection vertically to bulb L-shaped wire at (12,10)
            const bulbBottomLWirePos = gridToWorld(12, 10);
            path.push({ x: bulbBottomLWirePos.x, y: bulbBottomLWirePos.y, isWire: true });
            
            // Bottom wire (negative path) from bulb back to T-junction
            for (let x = 12; x >= 6; x--) {
                if (isConductive(x, 10)) { // Row 10 is bottom wire
                    const pos = gridToWorld(x, 10);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added bottom wire position: (${pos.x}, ${pos.y})`);
                }
            }
            
            // At T-junction (6,10), continue horizontally to battery
            for (let x = 6; x >= 1; x--) {
                if (isConductive(x, 10)) { // Continue on row 10
                    const pos = gridToWorld(x, 10);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added bottom wire position after T-junction: (${pos.x}, ${pos.y})`);
                }
            }
            
            // Connection vertically to vertical wire at (1,9)
            const batteryBottomVWirePos = gridToWorld(1, 9);
            path.push({ x: batteryBottomVWirePos.x, y: batteryBottomVWirePos.y, isWire: true });
            
            // Battery negative terminal (bottom cell)
            const batteryBottomPos = gridToWorld(gameState.battery.x, gameState.battery.y + 2);
            path.push({ x: batteryBottomPos.x, y: batteryBottomPos.y + gameState.cellSize * 0.5, isTerminal: true });
            
            console.log(`Second circuit path built with ${path.length} points`);
            return path;
        }

        function calculatePathDistance(path) {
            let totalDistance = 0;
            
            for (let i = 1; i < path.length; i++) {
                const prev = path[i - 1];
                const curr = path[i];
                const distance = Math.sqrt(
                    Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)
                );
                totalDistance += distance;
            }
            
            return totalDistance;
        }

        function getPositionAtDistance(path, targetDistance) {
            let currentDistance = 0;
            
            for (let i = 1; i < path.length; i++) {
                const prev = path[i - 1];
                const curr = path[i];
                const segmentDistance = Math.sqrt(
                    Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)
                );
                
                if (currentDistance + segmentDistance >= targetDistance) {
                    // The target distance is within this segment
                    const remainingDistance = targetDistance - currentDistance;
                    const ratio = remainingDistance / segmentDistance;
                    
                    return {
                        x: prev.x + (curr.x - prev.x) * ratio,
                        y: prev.y + (curr.y - prev.y) * ratio
                    };
                }
                
                currentDistance += segmentDistance;
            }
            
            // If we've gone past the end, return the last position
            return path[path.length - 1];
        }

        function startPulsatingChainAnimation(particles, circuitPath) {
            console.log(`Starting pulsating animation for ${particles.length} particles`);
            
            // Create synchronized pulsating effect for all particles
            particles.forEach(({ particle, glow }, index) => {
                console.log(`Setting up pulsing for particle ${index}`);
                
                // Pulsating scale animation
                scene.tweens.add({
                    targets: [particle, glow],
                    scaleX: 1.5,
                    scaleY: 1.5,
                    duration: 600,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
                
                // Pulsating alpha animation for extra effect
                scene.tweens.add({
                    targets: particle,
                    alpha: 0.6,
                    duration: 800,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            });
            
            // Start movement animation after a brief delay to see pulsing first
            setTimeout(() => {
                console.log('Starting movement animation...');
                animateLinearMovement(particles, circuitPath);
            }, 1000);
        }

        function animateLinearMovement(particles, circuitPath) {
            if (!gameState.bulb.isLit) return;
            
            console.log('Starting circuit flow animation');
            console.log('Circuit path length:', circuitPath.length);
            console.log('First few path points:', circuitPath.slice(0, 5));
            
            // Now implement proper circuit flow since basic movement works
            particles.forEach(({ particle, glow }, index) => {
                console.log(`Starting circuit flow for particle ${index}`);
                animateParticleAroundCircuit(particle, glow, circuitPath, index);
            });
        }

        function animateParticleAroundCircuit(particle, glow, circuitPath, particleIndex) {
            if (!gameState.bulb.isLit || !particle.active || circuitPath.length === 0) {
                console.log('Cannot animate - conditions not met');
                return;
            }
            
            console.log(`Animating particle ${particleIndex} around circuit`);
            
            // Find the closest path point to the particle's current position to maintain spacing
            let currentPathIndex = 0;
            let minDistance = Infinity;
            
            for (let i = 0; i < circuitPath.length; i++) {
                const pathPoint = circuitPath[i];
                const distance = Math.sqrt(
                    Math.pow(particle.x - pathPoint.x, 2) + 
                    Math.pow(particle.y - pathPoint.y, 2)
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    currentPathIndex = i;
                }
            }
            
            console.log(`Particle ${particleIndex} starting from path index ${currentPathIndex}`);
            
            const animationSpeed = 300; // milliseconds per path segment
            
            const moveToNextPoint = () => {
                if (!gameState.bulb.isLit || !particle.active) {
                    console.log('Stopping animation - circuit incomplete');
                    return;
                }
                
                // Move to next point in circuit (maintaining the circular flow)
                currentPathIndex = (currentPathIndex + 1) % circuitPath.length;
                const nextPoint = circuitPath[currentPathIndex];
                
                console.log(`Moving particle ${particleIndex} to point ${currentPathIndex}:`, nextPoint);
                
                // Animate to next point
                scene.tweens.add({
                    targets: [particle, glow],
                    x: nextPoint.x,
                    y: nextPoint.y,
                    duration: animationSpeed,
                    ease: 'Linear',
                    onComplete: () => {
                        // Continue to next point after a small delay
                        setTimeout(() => {
                            moveToNextPoint();
                        }, 50); // Small delay between segments
                    }
                });
            };
            
            // Start the animation
            moveToNextPoint();
        }



        function getActualCircuitPath() {
            // Return the path from positive terminal through both wires to negative terminal
            const path = [];
            
            // Top wire (positive path) - from battery to bulb
            const topY = 4; // Row 4 is top wire
            for (let x = 3; x <= 11; x++) {
                if (isConductive(x, topY)) {
                    path.push({x: x, y: topY});
                }
            }
            
            // Through the bulb (if both vertical wire connections are conductive)
            if (isConductive(12, 5) && isConductive(12, 9)) {
                path.push({x: gameState.bulb.x + 1, y: gameState.bulb.y + 1}); // Bulb center (3x3)
            }
            
            // Bottom wire (negative path) - from bulb back to battery
            const bottomY = 10; // Row 10 is bottom wire
            for (let x = 11; x >= 3; x--) {
                if (isConductive(x, bottomY)) {
                    path.push({x: x, y: bottomY});
                }
            }
            
            return path;
        }

        function getCircuitAnalysis() {
            const analysis = {
                gapsFilled: 0,
                totalGaps: gameState.gaps.length,
                conductorsPlaced: 0,
                insulatorsPlaced: 0,
                placedItems: []
            };
            
            gameState.gaps.forEach(gap => {
                if (gap.filled) {
                    analysis.gapsFilled++;
                    const item = getGridPosition(gap.x, gap.y);
                    if (item && typeof item === 'object') {
                        analysis.placedItems.push({
                            name: item.name,
                            type: item.type,
                            conductive: item.conductive,
                            position: {x: gap.x, y: gap.y}
                        });
                        
                        if (item.conductive) {
                            analysis.conductorsPlaced++;
                        } else {
                            analysis.insulatorsPlaced++;
                        }
                    }
                }
            });
            
            return analysis;
        }

        function showFeedback(message, type = 'info') {
            const feedbackArea = document.getElementById('feedback-area');
            feedbackArea.textContent = message;
            feedbackArea.className = `feedback-${type}`;
            
            // Add pulse animation for important feedback
            if (type === 'success' || type === 'error') {
                feedbackArea.style.animation = 'pulse 0.5s ease-in-out';
                setTimeout(() => {
                    feedbackArea.style.animation = '';
                }, 500);
            }
        }

        // Button event handlers
        document.getElementById('test-circuit-btn').addEventListener('click', function() {
            console.log('Testing circuit...');
            
            // Disable button during testing
            this.disabled = true;
            this.textContent = 'âš¡ Testing...';
            
            const analysis = getCircuitAnalysis();
            console.log('Circuit analysis:', analysis);
            
            setTimeout(() => {
                const isComplete = evaluateCircuit();
                
                if (isComplete) {
                    showFeedback('ðŸŽ‰ Circuit Complete! Electricity is flowing!', 'success');
                    
                    // Show current flow animation
                    visualizeCurrentFlow(true);
                    
                    // Show success modal after animation
                    setTimeout(() => {
                        showSuccessModal();
                    }, 1500);
                } else {
                    // Stop any current flow animation
                    visualizeCurrentFlow(false);
                    
                    // Provide specific feedback about why circuit failed
                    let message = '';
                    if (analysis.gapsFilled === 0) {
                        message = 'âŒ No materials placed. Drag materials to the gaps!';
                    } else if (analysis.gapsFilled < analysis.totalGaps) {
                        message = `âŒ Try filling more gaps to complete the circuit.`;
                    } else {
                        message = 'âŒ Some materials are blocking electricity. Try different materials.';
                    }
                    showFeedback(message, 'error');
                }
                
                // Re-enable button
                this.disabled = false;
                this.textContent = 'âš¡ Test Circuit';
            }, 500); // Small delay for better UX
        });

        document.getElementById('reset-btn').addEventListener('click', function() {
            console.log('Reset button clicked - functionality will be added later');
        });

        function showSuccessModal() {
            // Get analysis of what materials were used
            const analysis = getCircuitAnalysis();
            
            // Populate materials used section with enhanced educational content
            const materialsDiv = document.getElementById('materials-used');
            let materialsHTML = '<h4>ðŸ”§ Materials You Used:</h4>';
            
            if (analysis.placedItems.length > 0) {
                materialsHTML += '<ul>';
                analysis.placedItems.forEach(item => {
                    const conductorClass = item.conductive ? 'conductor-text' : 'insulator-text';
                    const conductorType = item.conductive ? 'CONDUCTOR' : 'INSULATOR';
                    const explanation = item.conductive ? 
                        'allows electricity to flow through it easily!' : 
                        'blocks electricity from flowing through it.';
                    
                    materialsHTML += `<li><strong>${item.name}</strong> - <span class="${conductorClass}">${conductorType}</span> that ${explanation}</li>`;
                });
                materialsHTML += '</ul>';
                
                if (analysis.conductorsPlaced > 0) {
                    materialsHTML += `<p><strong>ðŸŽ¯ Perfect!</strong> You used <span class="conductor-text">${analysis.conductorsPlaced} conductor(s)</span> to complete the electrical circuit!</p>`;
                }
                
                // Add educational explanation
                materialsHTML += `<p><strong>ðŸ’¡ What you learned:</strong> Conductors like metals allow electricity to flow, while insulators like rubber and wood block it. That's why the light bulb glows when you use conductive materials!</p>`;
            } else {
                materialsHTML += '<p>No materials were needed - the circuit was already complete!</p>';
            }
            
            materialsDiv.innerHTML = materialsHTML;
            
            // Add celebration visual effects
            addCelebrationEffects();
            
            // Show modal with animation
            const modal = document.getElementById('success-modal');
            const modalContent = document.getElementById('success-content');
            
            // Ensure modal content starts invisible and centered
            modalContent.style.opacity = '0';
            modalContent.style.transform = 'translate(-50%, -60%) scale(0.8)';
            
            modal.style.display = 'block';
            
            // Trigger animation after a brief delay to ensure proper positioning
            requestAnimationFrame(() => {
                modalContent.style.animation = 'slideIn 0.4s ease-out forwards';
            });
            
            // Add confetti effect to the page background
            setTimeout(() => {
                createConfettiEffect();
            }, 200);
            
            // Play success sound effect (if available)
            playSuccessSound();
        }

        function addCelebrationEffects() {
            // Create sparkle particles around the light bulb
            if (gameState.bulb.sprite && gameState.bulb.isLit) {
                const bulbPos = gridToWorld(gameState.bulb.x, gameState.bulb.y);
                
                // Create multiple sparkle particles
                for (let i = 0; i < 12; i++) {
                    setTimeout(() => {
                        const angle = (i / 12) * Math.PI * 2;
                        const distance = 40 + Math.random() * 20;
                        const sparkleX = bulbPos.x + Math.cos(angle) * distance;
                        const sparkleY = bulbPos.y + Math.sin(angle) * distance;
                        
                        const sparkle = scene.add.star(sparkleX, sparkleY, 5, 4, 8, 0xFFD700);
                        sparkle.setAlpha(1);
                        
                        // Animate sparkle
                        scene.tweens.add({
                            targets: sparkle,
                            scaleX: 0,
                            scaleY: 0,
                            alpha: 0,
                            rotation: Math.PI * 2,
                            duration: 1000,
                            ease: 'Power2',
                            onComplete: () => sparkle.destroy()
                        });
                    }, i * 100);
                }
            }
            
            // Add screen flash effect
            const flash = scene.add.rectangle(
                gameState.gridWidth * gameState.cellSize / 2,
                gameState.gridHeight * gameState.cellSize / 2,
                gameState.gridWidth * gameState.cellSize,
                gameState.gridHeight * gameState.cellSize,
                0xFFFFFF
            );
            flash.setAlpha(0.6);
            
            scene.tweens.add({
                targets: flash,
                alpha: 0,
                duration: 300,
                ease: 'Power2',
                onComplete: () => flash.destroy()
            });
        }
        
        function playSuccessSound() {
            // Create a simple success sound using Web Audio API
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create a simple success melody
                const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5
                
                frequencies.forEach((freq, index) => {
                    setTimeout(() => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                    }, index * 150);
                });
            } catch (error) {
                console.log('Audio not available:', error);
            }
        }

        document.getElementById('play-again-btn').addEventListener('click', function() {
            hideSuccessModal();
            resetGame();
        });

        // Add event listener for new challenge button
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('new-challenge-btn').addEventListener('click', function() {
                hideSuccessModal();
                createNewChallenge();
            });
            
            // Add click outside modal to close
            document.getElementById('success-modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideSuccessModal();
                }
            });
            
            // Add escape key to close modal
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('success-modal').style.display === 'block') {
                    hideSuccessModal();
                }
            });
        });
        
        function createConfettiEffect() {
            // Create colorful confetti particles that fall from the top
            const colors = [0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0xFFA07A, 0x98D8C8, 0xF7DC6F];
            
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const x = Math.random() * (gameState.gridWidth * gameState.cellSize);
                    const y = -20;
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    const confetti = scene.add.rectangle(x, y, 8, 8, color);
                    confetti.setRotation(Math.random() * Math.PI * 2);
                    
                    // Animate falling confetti
                    scene.tweens.add({
                        targets: confetti,
                        y: gameState.gridHeight * gameState.cellSize + 50,
                        rotation: confetti.rotation + Math.PI * 4,
                        duration: 2000 + Math.random() * 1000,
                        ease: 'Power2',
                        onComplete: () => confetti.destroy()
                    });
                    
                    // Add side-to-side motion
                    scene.tweens.add({
                        targets: confetti,
                        x: x + (Math.random() - 0.5) * 100,
                        duration: 2000 + Math.random() * 1000,
                        ease: 'Sine.easeInOut',
                        yoyo: true,
                        repeat: 1
                    });
                }, i * 100);
            }
        }
        
        function hideSuccessModal() {
            const modal = document.getElementById('success-modal');
            const modalContent = document.getElementById('success-content');
            
            // Add fade out animation
            modalContent.style.animation = 'slideOut 0.3s ease-in';
            
            setTimeout(() => {
                modal.style.display = 'none';
                modalContent.style.animation = ''; // Reset animation
            }, 300);
        }

        function createNewChallenge() {
            // Reset the current game first
            resetGame();
            
            // Cycle through available circuit layouts
            const availableLayouts = Object.keys(gameState.circuitLayouts);
            const currentIndex = availableLayouts.indexOf(gameState.currentLayout);
            const nextIndex = (currentIndex + 1) % availableLayouts.length;
            const nextLayout = availableLayouts[nextIndex];
            
            // Load the next circuit layout
            loadCircuitLayout(nextLayout);
            
            // Show appropriate challenge message
            const challengeMessages = {
                first: [
                    'ðŸ”„ Back to the basics! Simple two-wire circuit.',
                    'âš¡ Classic Circuit! Fill the gaps to complete the path.',
                    'ðŸŽ¯ Original Challenge! Connect battery to bulb.'
                ],
                second: [
                    'ðŸ†• New Challenge! Complex circuit with T-junctions and multiple paths!',
                    'âš¡ Fresh Circuit! Can you solve this advanced layout?',
                    'ðŸŽ¯ Challenge Mode! Navigate the T-shaped connectors!'
                ]
            };
            
            const messages = challengeMessages[nextLayout] || ['ðŸ†• New Challenge! Try this circuit layout!'];
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            showFeedback(randomMessage, 'info');
            
            console.log('New challenge created with layout:', nextLayout);
        }



        function clearExistingComponents() {
            console.log('Clearing existing components...');
            
            // Clear all sprites from the scene more aggressively
            if (scene && scene.children) {
                const children = scene.children.list.slice(); // Create a copy to avoid modification during iteration
                children.forEach(child => {
                    // Skip the grid graphics (they should persist)
                    if (child && child.type !== 'Graphics' || (child.type === 'Graphics' && child.lineStyle)) {
                        try {
                            child.destroy();
                        } catch (error) {
                            console.warn('Error destroying child:', error);
                        }
                    }
                });
            }
            
            // Clear battery sprite
            if (gameState.battery && gameState.battery.sprite) {
                try {
                    gameState.battery.sprite.destroy();
                } catch (error) {
                    console.warn('Error destroying battery sprite:', error);
                }
                gameState.battery.sprite = null;
            }
            
            // Clear bulb sprite and glow effect
            if (gameState.bulb && gameState.bulb.sprite) {
                try {
                    gameState.bulb.sprite.destroy();
                } catch (error) {
                    console.warn('Error destroying bulb sprite:', error);
                }
                gameState.bulb.sprite = null;
            }
            if (gameState.bulb && gameState.bulb.glowEffect) {
                try {
                    gameState.bulb.glowEffect.destroy();
                } catch (error) {
                    console.warn('Error destroying glow effect:', error);
                }
                gameState.bulb.glowEffect = null;
            }
            if (gameState.bulb && gameState.bulb.bulbSprite) {
                gameState.bulb.bulbSprite = null;
            }
            if (gameState.bulb) {
                gameState.bulb.isLit = false;
            }
            
            // Clear existing gaps
            if (gameState.gaps) {
                gameState.gaps.forEach(gap => {
                    if (gap.sprite) {
                        try {
                            gap.sprite.destroy();
                        } catch (error) {
                            console.warn('Error destroying gap sprite:', error);
                        }
                        gap.sprite = null;
                    }
                });
            }
            
            // Clear existing preplaced wires
            if (gameState.preplacedWires) {
                gameState.preplacedWires.forEach(wire => {
                    if (wire.sprite) {
                        try {
                            wire.sprite.destroy();
                        } catch (error) {
                            console.warn('Error destroying wire sprite:', error);
                        }
                        wire.sprite = null;
                    }
                });
            }
            
            // Clear connection graphics
            if (gameState.connectionGraphics) {
                gameState.connectionGraphics.forEach(graphic => {
                    if (graphic) {
                        try {
                            graphic.destroy();
                        } catch (error) {
                            console.warn('Error destroying connection graphic:', error);
                        }
                    }
                });
                gameState.connectionGraphics = [];
            }
            
            // Completely clear and reinitialize the grid
            clearGridCompletely();
            
            // Redraw the grid lines
            drawGrid();
            
            console.log('All components cleared');
        }
        
        function clearGridCompletely() {
            // Clear all grid positions
            for (let y = 0; y < gameState.gridHeight; y++) {
                for (let x = 0; x < gameState.gridWidth; x++) {
                    gameState.grid[y][x] = null;
                }
            }
            console.log('Grid completely cleared');
        }
        
        function loadCircuitLayout(layoutName) {
            console.log('Loading circuit layout:', layoutName);
            
            if (!gameState.circuitLayouts[layoutName]) {
                console.error('Circuit layout not found:', layoutName);
                return;
            }
            
            const layout = gameState.circuitLayouts[layoutName];
            
            // Clear everything first
            clearExistingComponents();
            
            // Set current layout
            gameState.currentLayout = layoutName;
            
            // Load layout configuration
            gameState.battery = { ...layout.battery, sprite: null };
            gameState.bulb = { ...layout.bulb, sprite: null, isLit: false };
            gameState.gaps = layout.gaps.map(gap => ({ ...gap, sprite: null }));
            gameState.preplacedWires = layout.preplacedWires.map(wire => ({ ...wire, sprite: null }));
            
            // Recreate all components
            createCircuitComponents();
            
            // Update wire connections
            updateWireConnections();
            
            console.log('Circuit layout loaded:', layoutName);
        }

        function resetGame() {
            console.log('Starting complete game reset...');
            
            // 1. Remove all placed items from circuit by scanning the entire grid
            for (let y = 0; y < gameState.gridHeight; y++) {
                for (let x = 0; x < gameState.gridWidth; x++) {
                    const gridItem = gameState.grid[y][x];
                    // Only remove items that are actual placed items (not pre-placed components)
                    if (gridItem && typeof gridItem === 'object' && 
                        gridItem.inBank !== undefined && gridItem.placed === true) {
                        console.log('Removing placed item from grid:', gridItem.name, 'at', x, y);
                        
                        // Clear the grid position first
                        gameState.grid[y][x] = null;
                        
                        // Clean up HTML element if it exists
                        if (gridItem.sprite && gridItem.sprite.htmlElement) {
                            gridItem.sprite.htmlElement.remove();
                        }
                        
                        // Destroy the sprite if it exists
                        if (gridItem.sprite) {
                            try {
                                if (gridItem.sprite.children && gridItem.sprite.children.entries) {
                                    gridItem.sprite.children.entries.forEach(child => {
                                        if (child) {
                                            child.setVisible(false);
                                            child.destroy();
                                        }
                                    });
                                }
                                gridItem.sprite.clear(true, true);
                                gridItem.sprite.destroy();
                            } catch (error) {
                                console.warn('Error destroying sprite during reset:', error);
                            }
                            gridItem.sprite = null;
                            gridItem.mainSprite = null;
                        }
                        
                        // Reset item state completely
                        gridItem.inBank = true;
                        gridItem.placed = false;
                        gridItem.gridX = -1;
                        gridItem.gridY = -1;
                        gridItem.isDragging = false;
                        
                        // Clear any stored positions
                        gridItem.originalX = undefined;
                        gridItem.originalY = undefined;
                        gridItem.originalGridX = undefined;
                        gridItem.originalGridY = undefined;
                        
                        // Clean up any removal hints
                        if (gridItem.removalHint) {
                            gridItem.removalHint.destroy();
                            gridItem.removalHint = null;
                        }
                    }
                }
            }
            
            // 2. Clear placed items array
            gameState.placedItems = [];
            console.log('Cleared placedItems array');
            
            // 3. Restore all items to original quantities in item bank
            gameState.itemBank.forEach(item => {
                // Reset item state to be in bank
                item.inBank = true;
                item.placed = false;
                item.gridX = -1;
                item.gridY = -1;
                item.isDragging = false;
                
                // Clear any stored positions
                item.originalX = undefined;
                item.originalY = undefined;
                item.originalGridX = undefined;
                item.originalGridY = undefined;
                
                // Show HTML element again with proper styling
                if (item.htmlElement) {
                    item.htmlElement.style.display = 'flex';
                    item.htmlElement.style.cursor = 'grab';
                    item.htmlElement.style.opacity = '1';
                    item.htmlElement.style.transform = 'scale(1)';
                    item.htmlElement.style.boxShadow = '';
                    item.htmlElement.style.animation = '';
                }
                
                console.log('Restored item to bank:', item.name);
            });
            
            // 4. Clear all gap positions back to empty state
            gameState.gaps.forEach(gap => {
                gap.filled = false;
                gap.filledWith = null;
                if (gap.sprite) {
                    gap.sprite.setVisible(true);
                }
                
                // Ensure all gap cells are marked as 'gap' in the grid
                const gapSize = gap.size || { width: 1, height: 1 };
                for (let dy = 0; dy < gapSize.height; dy++) {
                    for (let dx = 0; dx < gapSize.width; dx++) {
                        setGridPosition(gap.x + dx, gap.y + dy, 'gap');
                    }
                }
                
                console.log('Reset gap at position:', gap.x, gap.y, 'size:', gapSize);
            });
            
            // 5. Turn off light bulb and clear any success states
            updateLightBulb(false);
            
            // Clear flow visualization
            if (gameState.flowVisualization) {
                gameState.flowVisualization.forEach(particle => {
                    if (particle.destroy) particle.destroy();
                });
                gameState.flowVisualization = [];
            }
            
            // Hide success modal if it's showing
            const successModal = document.getElementById('success-modal');
            if (successModal && successModal.style.display !== 'none') {
                successModal.style.display = 'none';
            }
            
            // Clear any drag state
            gameState.draggedItem = null;
            gameState.isDragging = false;
            document.body.style.cursor = 'default';
            
            // Clear any drop zone highlights
            highlightDropZones(false);
            
            // Clean up any remaining HTML elements from placed items in canvas container
            const canvas = document.querySelector('canvas');
            const canvasContainer = canvas.parentElement;
            if (canvasContainer) {
                const itemElements = canvasContainer.querySelectorAll('div[style*="background-image"][style*="assets/items"]');
                itemElements.forEach(element => {
                    element.remove();
                });
            }
            
            // 6. Redraw base circuit with only pre-placed components
            // Clear connection graphics first
            clearConnectionGraphics();
            
            // Update wire connections to show base circuit only
            updateWireConnections();
            
            // Reset to first circuit layout if we're not already there
            if (gameState.currentLayout !== 'first') {
                resetToFirstCircuitLayout();
            }
            
            // Reset feedback to initial state
            showFeedback('Try different materials in the gaps to see which ones allow electricity to flow! Drag placed items away to remove them.', 'info');
            
            console.log('Complete game reset finished - all items returned to bank, gaps cleared, bulb off');
        }

        function resetToFirstCircuitLayout() {
            // Load the first circuit layout using the new system
            loadCircuitLayout('first');
            console.log('Reset to first circuit layout');
        }

        document.getElementById('reset-btn').addEventListener('click', function() {
            resetGame();
        });

        // Start the game
        game = new Phaser.Game(config);
    </script>
</body>
</html>