<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conductor & Insulator Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: white;
            margin-bottom: 30px;
            text-align: center;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-weight: 300;
        }
        
        .game-subtitle {
            color: rgba(255,255,255,0.9);
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.1em;
            font-weight: 300;
        }
        
        #game-container {
            display: flex;
            gap: 25px;
            align-items: flex-start;
            background: rgba(255,255,255,0.1);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        #right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #game-canvas {
            border: 3px solid rgba(255,255,255,0.3);
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        
        #item-bank {
            width: 220px;
            padding: 20px;
            background: rgba(255,255,255,0.95);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            backdrop-filter: blur(5px);
        }
        
        #item-bank h3 {
            margin-top: 0;
            margin-bottom: 18px;
            color: #333;
            text-align: center;
            font-size: 1.2em;
            font-weight: 600;
        }
        
        .item-bank-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: start;
            justify-content: center;
        }
        
        .item-tooltip {
            position: absolute;
            background-color: rgba(186, 85, 211, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            min-height: 20px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .item-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(186, 85, 211, 0.95);
        }
        
        .bank-item {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 8px !important;
            position: relative;
            overflow: hidden;
        }
        
        .bank-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }
        
        .bank-item:hover::before {
            left: 100%;
        }
        
        #controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: stretch;
        }
        
        .controls-row {
            display: flex;
            gap: 15px;
        }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        button:hover {
            background-color: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        #test-circuit-btn {
            background-color: #FF9800;
            font-weight: bold;
        }
        
        #test-circuit-btn:hover {
            background-color: #F57C00;
        }
        
        #feedback-area {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .feedback-success {
            background-color: #E8F5E8;
            color: #2E7D32;
            border: 2px solid #4CAF50;
        }
        
        .feedback-error {
            background-color: #FFEBEE;
            color: #C62828;
            border: 2px solid #F44336;
        }
        
        .feedback-info {
            background-color: #E3F2FD;
            color: #1565C0;
            border: 2px solid #2196F3;
        }
        
        #success-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        #success-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            padding: 40px;
            border-radius: 15px;
            text-align: left;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideIn 0.4s ease-out;
        }
        
        #success-content h2 {
            color: #4CAF50;
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
        }
        
        #success-details p {
            margin-bottom: 15px;
            color: #333;
            line-height: 1.5;
        }
        
        #success-explanation {
            background-color: #E8F5E8;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
            margin: 15px 0;
        }
        
        #success-explanation li {
            margin-bottom: 8px;
            color: #2E7D32;
            font-weight: 500;
        }
        
        .conductor-text {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .insulator-text {
            color: #F44336;
            font-weight: bold;
        }
        
        #materials-used {
            background-color: #F3E5F5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #9C27B0;
        }
        
        #materials-used h4 {
            color: #7B1FA2;
            margin-bottom: 10px;
        }
        
        #success-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }
        
        #success-actions button {
            flex: 1;
            max-width: 150px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { 
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to { 
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        @keyframes slideOut {
            from { 
                opacity: 1;
                transform: translate(-50%, -50%);
            }
            to { 
                opacity: 0;
                transform: translate(-50%, -60%);
            }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Responsive design for larger 15x15 grid */
        @media (max-width: 1200px) {
            #game-container {
                flex-direction: column;
                align-items: center;
            }
            
            #right-panel {
                width: 100%;
                max-width: 500px;
                align-items: center;
            }
            
            #item-bank {
                width: 100%;
            }
            
            .item-bank-grid {
                gap: 6px;
            }
        }
        
        @media (max-width: 1024px) {
            #game-canvas {
                max-width: 90vw;
                max-height: 90vw;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            #game-container {
                padding: 15px;
            }
            
            #game-canvas {
                max-width: 95vw;
                max-height: 95vw;
            }
            
            .controls-row {
                flex-direction: column;
                width: 100%;
            }
            
            .controls-row button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>⚡ Conductor & Insulator Circuit Game</h1>
    <p class="game-subtitle">Learn about electricity by building circuits with different materials!</p>
    
    <div id="game-container">
        <div id="game-canvas"></div>
        <div id="right-panel">
            <div id="item-bank">
                <h3>Item Bank</h3>
                <div class="item-bank-grid" id="item-bank-grid">
                    <!-- Items will be added here by JavaScript -->
                </div>
            </div>
            
            <div id="controls">
                <div class="controls-row">
                    <button id="test-circuit-btn">⚡ Test Circuit</button>
                    <button id="reset-btn">🔄 Reset Game</button>
                </div>
                <div id="feedback-area">
                    Try different materials in the gaps to see which ones allow electricity to flow! Drag placed items away to remove them.
                </div>
            </div>
        </div>
    </div>
    
    <!-- Success Modal -->
    <div id="success-modal">
        <div id="success-content">
            <h2>🎉 Excellent Work!</h2>
            <div id="success-details">
                <p><strong>You completed the electrical circuit!</strong></p>
                <p>The light bulb is glowing because:</p>
                <ul id="success-explanation">
                    <li>✅ Electricity flows from the battery's positive (+) terminal</li>
                    <li>✅ Through the <span class="conductor-text">conductors</span> you placed</li>
                    <li>✅ Through the light bulb (making it glow)</li>
                    <li>✅ Back to the battery's negative (-) terminal</li>
                </ul>
                <div id="materials-used">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>
            <div id="success-actions">
                <button id="play-again-btn">🔄 Try Again</button>
                <button id="new-challenge-btn">⚡ New Challenge</button>
            </div>
        </div>
    </div>

    <!-- Phaser.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    
    <script>
        // Responsive canvas sizing
        function getOptimalCanvasSize() {
            const maxWidth = Math.min(window.innerWidth * 0.6, 900);
            const maxHeight = Math.min(window.innerHeight * 0.7, 900);
            const size = Math.min(maxWidth, maxHeight);
            return Math.max(size, 600); // Minimum size of 600px
        }

        // Game configuration
        const canvasSize = getOptimalCanvasSize();
        const config = {
            type: Phaser.AUTO,
            width: canvasSize, // Responsive size, max 900px (15 cells * 60px)
            height: canvasSize, // Responsive size, max 900px (15 cells * 60px)
            parent: 'game-canvas',
            backgroundColor: '#ffffff',
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false
                }
            }
        };

        // Game variables
        let game;
        let scene;
        let gameState = {
            grid: [],
            gridWidth: 15,
            gridHeight: 15,
            cellSize: canvasSize / 15, // Dynamic cell size based on canvas
            itemBank: [],
            placedItems: [],
            battery: { x: 2, y: 7, sprite: null },
            bulb: { x: 13, y: 7, sprite: null, isLit: false },
            // Two-wire circuit: top wire (positive) and bottom wire (negative)
            gaps: [
                // Two missing parts on top wire with equal spacing, one centered on bottom wire
                { x: 4, y: 6, filled: false, size: { width: 1, height: 1 } },
                { x: 8, y: 6, filled: false, size: { width: 2, height: 1 } },
                { x: 6, y: 8, filled: false, size: { width: 3, height: 1 } }
            ],
            preplacedWires: [
                // Top wire connections (with gaps: 1x1 at x:4, 2x1 at x:8-9)
                { x: 3, y: 6 }, // From battery positive
                // Gap for 1x1 at x:4
                { x: 5, y: 6 }, // After first gap
                { x: 6, y: 6 },
                { x: 7, y: 6 }, // Before second gap
                // Gap for 2x1 at x:8-9
                { x: 10, y: 6 }, // After second gap
                { x: 11, y: 6 },
                { x: 12, y: 6 },
                { x: 13, y: 6 }, // To bulb
                // Bottom wire connections (with gap for 3x1 at x:6-8)
                { x: 13, y: 8 }, // From bulb
                { x: 12, y: 8 },
                { x: 11, y: 8 },
                { x: 10, y: 8 },
                { x: 9, y: 8 }, // Before 3x1 gap
                // Gap for 3x1 at x:6-8
                { x: 5, y: 8 }, // After 3x1 gap
                { x: 4, y: 8 },
                { x: 3, y: 8 }  // To battery negative
            ],
            draggedItem: null,
            isDragging: false,
            connectionGraphics: [] // Store connection graphics for cleanup
        };

        function preload() {
            // We'll create simple colored rectangles instead of loading images
            scene = this;
        }

        function create() {
            console.log('Game scene created');
            
            // Initialize the grid
            initializeGrid();
            
            // Draw grid lines
            drawGrid();
            
            // Create circuit components
            createCircuitComponents();
            
            // Create item bank
            createItemBank();
            
            // Set up input handling
            setupInputHandling();
            
            // Initialize wire connections
            updateWireConnections();
        }

        function update() {
            // Game loop - will be used for animations and updates
        }

        function initializeGrid() {
            // Initialize 2D grid array
            gameState.grid = [];
            for (let y = 0; y < gameState.gridHeight; y++) {
                gameState.grid[y] = [];
                for (let x = 0; x < gameState.gridWidth; x++) {
                    gameState.grid[y][x] = null;
                }
            }
        }

        function drawGrid() {
            const graphics = scene.add.graphics();
            graphics.lineStyle(1, 0xcccccc, 0.3);
            
            // Draw vertical lines
            for (let x = 0; x <= gameState.gridWidth; x++) {
                const worldX = x * gameState.cellSize;
                graphics.moveTo(worldX, 0);
                graphics.lineTo(worldX, gameState.gridHeight * gameState.cellSize);
            }
            
            // Draw horizontal lines
            for (let y = 0; y <= gameState.gridHeight; y++) {
                const worldY = y * gameState.cellSize;
                graphics.moveTo(0, worldY);
                graphics.lineTo(gameState.gridWidth * gameState.cellSize, worldY);
            }
            
            graphics.strokePath();
            
            // Highlight the circuit rows (top and bottom wires)
            graphics.lineStyle(2, 0x4CAF50, 0.3);
            graphics.fillStyle(0x4CAF50, 0.1);
            
            // Top wire (row 6)
            graphics.fillRect(0, 6 * gameState.cellSize, gameState.gridWidth * gameState.cellSize, gameState.cellSize);
            graphics.strokeRect(0, 6 * gameState.cellSize, gameState.gridWidth * gameState.cellSize, gameState.cellSize);
            
            // Bottom wire (row 8)  
            graphics.fillRect(0, 8 * gameState.cellSize, gameState.gridWidth * gameState.cellSize, gameState.cellSize);
            graphics.strokeRect(0, 8 * gameState.cellSize, gameState.gridWidth * gameState.cellSize, gameState.cellSize);
        }

        function createCircuitComponents() {
            // Create battery
            createBattery();
            
            // Create light bulb
            createLightBulb();
            
            // Create pre-placed wires
            createPreplacedWires();
            
            // Mark gaps in the grid
            markGaps();
        }

        function createBattery() {
            const pos = gridToWorld(gameState.battery.x, gameState.battery.y);
            
            // Create battery body (taller to span both wire levels)
            const batteryBody = scene.add.rectangle(pos.x, pos.y, 50, 50, 0x333333);
            batteryBody.setStrokeStyle(2, 0x000000);
            
            // Add positive terminal (connects to top wire)
            const positiveTerminal = scene.add.rectangle(pos.x + 25, pos.y - 15, 8, 15, 0xFF0000);
            
            // Add negative terminal (connects to bottom wire)
            const negativeTerminal = scene.add.rectangle(pos.x + 25, pos.y + 15, 8, 10, 0x000000);
            
            // Add connection wires from terminals
            const positiveWire = scene.add.rectangle(pos.x + 35, pos.y - 15, 20, 4, 0xCD7F32);
            const negativeWire = scene.add.rectangle(pos.x + 35, pos.y + 15, 20, 4, 0xCD7F32);
            
            // Add labels
            const positiveLabel = scene.add.text(pos.x + 25, pos.y - 35, '+', {
                fontSize: '16px',
                fill: '#FF0000',
                fontStyle: 'bold'
            }).setOrigin(0.5);
            
            const negativeLabel = scene.add.text(pos.x + 25, pos.y + 35, '-', {
                fontSize: '16px',
                fill: '#000000',
                fontStyle: 'bold'
            }).setOrigin(0.5);
            
            const batteryLabel = scene.add.text(pos.x, pos.y + 40, 'BATTERY', {
                fontSize: '10px',
                fill: '#333333'
            }).setOrigin(0.5);
            
            // Group all battery components
            gameState.battery.sprite = scene.add.group([
                batteryBody, positiveTerminal, negativeTerminal, 
                positiveWire, negativeWire,
                positiveLabel, negativeLabel, batteryLabel
            ]);
            
            // Mark battery position in grid
            setGridPosition(gameState.battery.x, gameState.battery.y, 'battery');
            // Also mark the wire connection positions
            setGridPosition(gameState.battery.x, gameState.battery.y - 1, 'battery'); // Top connection
            setGridPosition(gameState.battery.x, gameState.battery.y + 1, 'battery'); // Bottom connection
        }

        function createLightBulb() {
            const pos = gridToWorld(gameState.bulb.x, gameState.bulb.y);
            
            // Create bulb base
            const bulbBase = scene.add.rectangle(pos.x, pos.y, 30, 40, 0x8B4513);
            bulbBase.setStrokeStyle(2, 0x000000);
            
            // Create bulb glass (will change color when lit)
            const bulbGlass = scene.add.circle(pos.x, pos.y - 10, 15, 0xFFFFFF);
            bulbGlass.setStrokeStyle(2, 0x000000);
            bulbGlass.setAlpha(0.8);
            
            // Add connection wires to both top and bottom circuits
            const topConnection = scene.add.rectangle(pos.x - 25, pos.y - 15, 20, 4, 0xCD7F32);
            const bottomConnection = scene.add.rectangle(pos.x - 25, pos.y + 15, 20, 4, 0xCD7F32);
            
            // Add connection points on bulb
            const topTerminal = scene.add.rectangle(pos.x - 15, pos.y - 15, 6, 4, 0x666666);
            const bottomTerminal = scene.add.rectangle(pos.x - 15, pos.y + 15, 6, 4, 0x666666);
            
            const bulbLabel = scene.add.text(pos.x, pos.y + 35, 'LIGHT BULB', {
                fontSize: '10px',
                fill: '#333333'
            }).setOrigin(0.5);
            
            // Store references for later use
            gameState.bulb.sprite = scene.add.group([
                bulbBase, bulbGlass, topConnection, bottomConnection,
                topTerminal, bottomTerminal, bulbLabel
            ]);
            gameState.bulb.glassSprite = bulbGlass;
            
            // Mark bulb position in grid
            setGridPosition(gameState.bulb.x, gameState.bulb.y, 'bulb');
            // Also mark the wire connection positions
            setGridPosition(gameState.bulb.x, gameState.bulb.y - 1, 'bulb'); // Top connection
            setGridPosition(gameState.bulb.x, gameState.bulb.y + 1, 'bulb'); // Bottom connection
        }

        function createPreplacedWires() {
            gameState.preplacedWires.forEach(wire => {
                const pos = gridToWorld(wire.x, wire.y);
                
                // Create wire segment
                const wireSprite = scene.add.rectangle(pos.x, pos.y, 40, 8, 0xCD7F32);
                wireSprite.setStrokeStyle(1, 0x8B4513);
                
                // Add wire label
                const wireLabel = scene.add.text(pos.x, pos.y + 20, 'WIRE', {
                    fontSize: '8px',
                    fill: '#666666'
                }).setOrigin(0.5);
                
                // Store wire data
                wire.sprite = scene.add.group([wireSprite, wireLabel]);
                
                // Mark wire position in grid
                setGridPosition(wire.x, wire.y, 'wire');
            });
        }

        function markGaps() {
            gameState.gaps.forEach(gap => {
                const pos = gridToWorld(gap.x, gap.y);
                
                // Calculate gap size based on the gap's size property
                const gapSize = gap.size || { width: 1, height: 1 };
                const cellSize = gameState.cellSize;
                
                // Create gap indicator (dashed outline using multiple small lines)
                const graphics = scene.add.graphics();
                graphics.lineStyle(2, 0xFF6B6B, 0.8);
                
                // Calculate proper center position for multi-cell gaps
                const centerX = pos.x + (cellSize * (gapSize.width - 1)) / 2;
                const centerY = pos.y + (cellSize * (gapSize.height - 1)) / 2;
                
                // Draw dashed rectangle based on gap size
                const width = (cellSize * gapSize.width) - 10;
                const height = (cellSize * gapSize.height) - 10;
                const x = centerX - width / 2;
                const y = centerY - height / 2;
                const dashLength = 5;
                const gapLength = 5;
                
                // Top line
                for (let i = 0; i < width; i += dashLength + gapLength) {
                    const lineWidth = Math.min(dashLength, width - i);
                    graphics.moveTo(x + i, y);
                    graphics.lineTo(x + i + lineWidth, y);
                }
                
                // Bottom line
                for (let i = 0; i < width; i += dashLength + gapLength) {
                    const lineWidth = Math.min(dashLength, width - i);
                    graphics.moveTo(x + i, y + height);
                    graphics.lineTo(x + i + lineWidth, y + height);
                }
                
                // Left line
                for (let i = 0; i < height; i += dashLength + gapLength) {
                    const lineHeight = Math.min(dashLength, height - i);
                    graphics.moveTo(x, y + i);
                    graphics.lineTo(x, y + i + lineHeight);
                }
                
                // Right line
                for (let i = 0; i < height; i += dashLength + gapLength) {
                    const lineHeight = Math.min(dashLength, height - i);
                    graphics.moveTo(x + width, y + i);
                    graphics.lineTo(x + width, y + i + lineHeight);
                }
                
                graphics.strokePath();
                
                // Store only the graphics (no text label for cleaner appearance)
                gap.sprite = scene.add.group([graphics]);
                
                // Mark all cells occupied by this gap
                for (let dy = 0; dy < gapSize.height; dy++) {
                    for (let dx = 0; dx < gapSize.width; dx++) {
                        setGridPosition(gap.x + dx, gap.y + dy, 'gap');
                    }
                }
            });
        }

        function updateLightBulb(isLit) {
            if (gameState.bulb.glassSprite) {
                if (isLit) {
                    gameState.bulb.glassSprite.setFillStyle(0xFFFF00); // Yellow when lit
                    gameState.bulb.glassSprite.setAlpha(1.0);
                    
                    // Add glow effect
                    if (!gameState.bulb.glowEffect) {
                        gameState.bulb.glowEffect = scene.add.circle(
                            gameState.bulb.glassSprite.x, 
                            gameState.bulb.glassSprite.y, 
                            25, 0xFFFF00
                        );
                        gameState.bulb.glowEffect.setAlpha(0.3);
                        gameState.bulb.glowEffect.setDepth(-1);
                    }
                    gameState.bulb.glowEffect.setVisible(true);
                } else {
                    gameState.bulb.glassSprite.setFillStyle(0xFFFFFF); // White when off
                    gameState.bulb.glassSprite.setAlpha(0.8);
                    
                    if (gameState.bulb.glowEffect) {
                        gameState.bulb.glowEffect.setVisible(false);
                    }
                }
                gameState.bulb.isLit = isLit;
            }
        }

        function createItemBank() {
            const itemBankContainer = document.getElementById('item-bank-grid');
            
            // Define available items - real-world materials with sizes
            const itemDefinitions = [
                // Conductors
                {
                    id: 'soda_bottle_cap',
                    name: 'Soda Bottle Cap',
                    type: 'conductor',
                    conductive: true,
                    color: '#FF6B35',
                    size: { width: 1, height: 1 },
                    quantity: 2
                },
                {
                    id: 'metal_key',
                    name: 'Metal Key',
                    type: 'conductor',
                    conductive: true,
                    color: '#C0C0C0',
                    size: { width: 2, height: 1 },
                    quantity: 2
                },
                {
                    id: 'paper_clip',
                    name: 'Paper Clip',
                    type: 'conductor',
                    conductive: true,
                    color: '#B8B8B8',
                    size: { width: 2, height: 1 },
                    quantity: 2
                },
                {
                    id: 'spoon',
                    name: 'Spoon',
                    type: 'conductor',
                    conductive: true,
                    color: '#E5E5E5',
                    size: { width: 3, height: 1 },
                    quantity: 1
                },
                {
                    id: 'metal_ruler',
                    name: 'Metal Ruler',
                    type: 'conductor',
                    conductive: true,
                    color: '#A8A8A8',
                    size: { width: 3, height: 1 },
                    quantity: 1
                },
                // Insulators
                {
                    id: 'lego_brick',
                    name: 'Lego Brick',
                    type: 'insulator',
                    conductive: false,
                    color: '#FF0000',
                    size: { width: 1, height: 1 },
                    quantity: 2
                },
                {
                    id: 'pebble',
                    name: 'Pebble',
                    type: 'insulator',
                    conductive: false,
                    color: '#8B7355',
                    size: { width: 1, height: 1 },
                    quantity: 2
                },
                {
                    id: 'eraser',
                    name: 'Eraser',
                    type: 'insulator',
                    conductive: false,
                    color: '#FF69B4',
                    size: { width: 2, height: 1 },
                    quantity: 2
                },
                {
                    id: 'rubber_band',
                    name: 'Rubber Band',
                    type: 'insulator',
                    conductive: false,
                    color: '#8B4513',
                    size: { width: 2, height: 1 },
                    quantity: 2
                },
                {
                    id: 'popsicle_stick',
                    name: 'Popsicle Stick',
                    type: 'insulator',
                    conductive: false,
                    color: '#DEB887',
                    size: { width: 3, height: 1 },
                    quantity: 1
                },
                {
                    id: 'drinking_straw',
                    name: 'Drinking Straw',
                    type: 'insulator',
                    conductive: false,
                    color: '#FFD700',
                    size: { width: 3, height: 1 },
                    quantity: 1
                }
            ];
            
            // Create item bank items
            itemDefinitions.forEach(itemDef => {
                for (let i = 0; i < itemDef.quantity; i++) {
                    const item = createBankItem(itemDef, i);
                    gameState.itemBank.push(item);
                    
                    // Create HTML element for the item
                    const itemElement = createItemBankElement(item);
                    itemBankContainer.appendChild(itemElement);
                }
            });
        }

        function createBankItem(definition, index) {
            return {
                id: `${definition.id}_${index}`,
                name: definition.name,
                type: definition.type,
                conductive: definition.conductive,
                color: definition.color,
                size: definition.size || { width: 1, height: 1 },
                inBank: true,
                placed: false,
                sprite: null,
                htmlElement: null,
                gridX: -1,
                gridY: -1
            };
        }

        function createItemBankElement(item) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'bank-item';
            
            // Calculate size based on item dimensions - make width differences more pronounced
            const baseWidth = 60;
            const baseHeight = 40;
            const width = baseWidth + (item.size.width - 1) * 30; // More width difference
            const height = baseHeight + (item.size.height - 1) * 10; // Less height difference
            
            itemDiv.style.cssText = `
                width: ${width}px;
                height: ${height}px;
                background-color: ${item.color};
                border: 2px solid #333;
                border-radius: 5px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                cursor: grab;
                user-select: none;
                transition: transform 0.2s, box-shadow 0.2s;
                margin: 2px;
                position: relative;
            `;
            
            // Add item name (smaller font for longer items)
            const fontSize = item.size.width > 2 ? '8px' : '10px';
            const nameLabel = document.createElement('div');
            nameLabel.style.cssText = `
                color: white;
                font-size: ${fontSize};
                text-align: center;
                font-weight: bold;
                text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
                line-height: 12px;
                padding: 2px;
                word-wrap: break-word;
                max-width: ${width - 10}px;
            `;
            nameLabel.textContent = item.name;
            
            itemDiv.appendChild(nameLabel);
            
            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.style.cssText = `
                position: absolute;
                background-color: rgba(186, 85, 211, 0.95);
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 12px;
                font-weight: bold;
                white-space: nowrap;
                z-index: 1000;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.2s;
                min-height: 20px;
                display: flex;
                align-items: center;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            `;
            
            // Calculate size information for tooltip content
            const itemSize = item.size || { width: 1, height: 1 };
            const totalCells = itemSize.width * itemSize.height;
            const cellText = totalCells === 1 ? 'cell' : 'cells';
            tooltip.innerHTML = `${item.name} (${totalCells} ${cellText})`;
            
            // Add arrow to tooltip
            const arrow = document.createElement('div');
            arrow.style.cssText = `
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                width: 0;
                height: 0;
                border-left: 6px solid transparent;
                border-right: 6px solid transparent;
                border-top: 6px solid rgba(186, 85, 211, 0.95);
            `;
            tooltip.appendChild(arrow);
            
            // Add tooltip to body
            document.body.appendChild(tooltip);
            
            // Add hover effects with tooltip
            itemDiv.addEventListener('mouseenter', function(e) {
                if (item.inBank) {
                    this.style.transform = 'scale(1.05)';
                    this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
                    
                    // Position tooltip using element-relative coordinates with scroll offset
                    const rect = this.getBoundingClientRect();
                    const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                    const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                    
                    // Calculate tooltip position relative to the item element
                    const tooltipWidth = tooltip.offsetWidth;
                    const tooltipHeight = tooltip.offsetHeight;
                    const itemCenterX = rect.left + scrollX + (rect.width / 2);
                    const itemTopY = rect.top + scrollY;
                    
                    // Center tooltip horizontally above the item
                    let tooltipLeft = itemCenterX - (tooltipWidth / 2);
                    let tooltipTop = itemTopY - tooltipHeight - 8;
                    
                    // Ensure tooltip doesn't go off-screen horizontally
                    const minLeft = 10;
                    const maxLeft = window.innerWidth - tooltipWidth - 10;
                    tooltipLeft = Math.max(minLeft, Math.min(tooltipLeft, maxLeft));
                    
                    // Ensure tooltip doesn't go off-screen vertically
                    if (tooltipTop < 10) {
                        tooltipTop = itemTopY + rect.height + 8; // Position below item if no space above
                    }
                    
                    tooltip.style.left = tooltipLeft + 'px';
                    tooltip.style.top = tooltipTop + 'px';
                    tooltip.style.opacity = '1';
                }
            });
            
            itemDiv.addEventListener('mouseleave', function() {
                if (item.inBank) {
                    this.style.transform = 'scale(1)';
                    this.style.boxShadow = 'none';
                    tooltip.style.opacity = '0';
                }
            });
            
            // Store references
            item.htmlElement = itemDiv;
            item.tooltip = tooltip;
            itemDiv.itemData = item;
            
            return itemDiv;
        }

        function createGameSprite(item, x, y) {
            const pos = gridToWorld(x, y);
            
            // Calculate sprite size based on item size
            const cellSize = gameState.cellSize;
            const spriteWidth = (cellSize * item.size.width) - 10;
            const spriteHeight = (cellSize * item.size.height) - 10;
            
            // Adjust position for multi-cell items to center them properly within their grid space
            const adjustedX = pos.x + (cellSize * (item.size.width - 1)) / 2;
            const adjustedY = pos.y + (cellSize * (item.size.height - 1)) / 2;
            
            // Create the main item sprite
            const itemSprite = scene.add.rectangle(adjustedX, adjustedY, spriteWidth, spriteHeight, item.color);
            itemSprite.setStrokeStyle(2, 0x000000);
            
            // Size indicator and text removed for cleaner visual design
            
            // Add text label with better styling and positioning
            const labelBackground = scene.add.rectangle(adjustedX, adjustedY - spriteHeight/2 - 15, item.name.length * 6 + 10, 16, 0xFFFFFF);
            labelBackground.setStrokeStyle(1, 0x333333);
            labelBackground.setAlpha(0.9);
            
            const label = scene.add.text(adjustedX, adjustedY - spriteHeight/2 - 15, item.name.toUpperCase(), {
                fontSize: '8px',
                fill: '#333333',
                fontWeight: 'bold'
            }).setOrigin(0.5);
            
            // Store original position and dimensions for drag distance calculation
            item.originalX = adjustedX;
            item.originalY = adjustedY;
            item.originalGridX = x;
            item.originalGridY = y;
            item.spriteHeight = spriteHeight;
            
            // Only make draggable if it's not a pre-placed component
            if (!isPreplacedComponent(x, y)) {
                itemSprite.setInteractive({ draggable: true });
                
                // Add removal hint on hover
                itemSprite.on('pointerover', function() {
                    this.setStrokeStyle(3, 0xFF6B6B);
                    // Show tooltip hint
                    if (!item.isDragging) {
                        showFeedback('💡 Tip: Drag this item away to remove it from the circuit!', 'info');
                    }
                });
                
                itemSprite.on('pointerout', function() {
                    if (!item.isDragging) {
                        this.setStrokeStyle(2, 0x000000);
                    }
                });
                
                // Enhanced drag functionality for removal with distance threshold detection
                itemSprite.on('dragstart', function(pointer, dragX, dragY) {
                    console.log('Started dragging placed item for potential removal');
                    item.isDragging = true;
                    
                    // Visual feedback - make semi-transparent and bring to front
                    this.setAlpha(0.8);
                    this.setDepth(1000);
                    labelBackground.setDepth(1000);
                    label.setDepth(1000);
                    
                    // Change stroke to indicate dragging
                    this.setStrokeStyle(3, 0xFF6B6B);
                    
                    // Show initial drag feedback
                    showFeedback('Drag away from circuit to remove item', 'info');
                });
                
                itemSprite.on('drag', function(pointer, dragX, dragY) {
                    // Update positions
                    this.x = dragX;
                    this.y = dragY;
                    labelBackground.x = dragX;
                    labelBackground.y = dragY - item.spriteHeight/2 - 15;
                    label.x = dragX;
                    label.y = dragY - item.spriteHeight/2 - 15;
                    
                    // Enhanced distance threshold detection
                    const distance = Phaser.Math.Distance.Between(
                        item.originalX, item.originalY, dragX, dragY
                    );
                    
                    const REMOVAL_THRESHOLD = 80; // pixels - configurable threshold
                    
                    if (distance > REMOVAL_THRESHOLD) {
                        // Visual feedback for removal zone
                        this.setStrokeStyle(4, 0xFF0000);
                        this.setAlpha(0.6);
                        
                        // Show removal hint with icon
                        if (!item.removalHint) {
                            item.removalHint = scene.add.text(dragX, dragY - 40, '🗑️ Release to remove', {
                                fontSize: '12px',
                                fill: '#FF0000',
                                backgroundColor: '#ffffff',
                                padding: { x: 6, y: 3 }
                            }).setOrigin(0.5).setDepth(1001);
                        } else {
                            item.removalHint.x = dragX;
                            item.removalHint.y = dragY - 40;
                        }
                        
                        // Update feedback message
                        showFeedback('Release to remove item from circuit', 'error');
                    } else {
                        // Normal drag visual feedback
                        this.setStrokeStyle(3, 0xFF6B6B);
                        this.setAlpha(0.8);
                        
                        // Hide removal hint
                        if (item.removalHint) {
                            item.removalHint.destroy();
                            item.removalHint = null;
                        }
                        
                        // Update feedback message
                        const remainingDistance = Math.ceil(REMOVAL_THRESHOLD - distance);
                        showFeedback(`Drag ${remainingDistance}px further to remove item`, 'info');
                    }
                });
                
                itemSprite.on('dragend', function(pointer, dragX, dragY) {
                    console.log('Ended dragging placed item');
                    item.isDragging = false;
                    
                    // Clean up removal hint
                    if (item.removalHint) {
                        item.removalHint.destroy();
                        item.removalHint = null;
                    }
                    
                    // Check distance from original position
                    const distance = Phaser.Math.Distance.Between(
                        item.originalX, item.originalY, dragX, dragY
                    );
                    
                    const REMOVAL_THRESHOLD = 80; // pixels
                    
                    if (distance > REMOVAL_THRESHOLD) {
                        console.log('Item dragged beyond removal threshold - removing');
                        console.log('Sprite position before removal:', this.x, this.y);
                        console.log('Original position:', item.originalX, item.originalY);
                        
                        // Disable dragging to prevent further interaction
                        this.disableInteractive();
                        
                        // Enhanced return to bank with animation (handles gap state internally)
                        returnItemToBank(item);
                        
                        // Show success feedback with animation
                        showFeedback('✅ Item returned to bank! You can place it again.', 'success');
                    } else {
                        // Return to original position with smooth animation
                        scene.tweens.add({
                            targets: this,
                            x: item.originalX,
                            y: item.originalY,
                            duration: 300,
                            ease: 'Back.easeOut'
                        });
                        
                        // Animate label background and text back to position
                        scene.tweens.add({
                            targets: labelBackground,
                            x: item.originalX,
                            y: item.originalY - item.spriteHeight/2 - 15,
                            duration: 300,
                            ease: 'Back.easeOut'
                        });
                        
                        scene.tweens.add({
                            targets: label,
                            x: item.originalX,
                            y: item.originalY - item.spriteHeight/2 - 15,
                            duration: 300,
                            ease: 'Back.easeOut'
                        });
                        
                        // Reset visual state
                        this.setStrokeStyle(2, 0x000000);
                        this.setAlpha(1.0);
                        this.setDepth(0);
                        labelBackground.setDepth(0);
                        label.setDepth(0);
                        
                        // Show feedback
                        showFeedback('Item returned to position. Drag further to remove.', 'info');
                    }
                });
            } else {
                // For pre-placed components, show feedback that they can't be removed
                itemSprite.setInteractive();
                itemSprite.on('pointerdown', function() {
                    showFeedback('❌ Pre-placed components (battery, bulb, wires) cannot be removed', 'error');
                });
                
                itemSprite.on('pointerover', function() {
                    this.setStrokeStyle(3, 0xFFAA00);
                    showFeedback('This is a pre-placed component and cannot be removed', 'info');
                });
                
                itemSprite.on('pointerout', function() {
                    this.setStrokeStyle(2, 0x000000);
                });
            }
            
            // Group all components
            const spriteGroup = scene.add.group([itemSprite, labelBackground, label]);
            
            // Store references
            item.sprite = spriteGroup;
            item.mainSprite = itemSprite;
            
            return spriteGroup;
        }

        function returnItemToBank(item) {
            console.log('Returning item to bank:', item.name);
            
            // Store the original grid position before clearing item state
            const originalGridX = item.gridX >= 0 ? item.gridX : item.originalGridX;
            const originalGridY = item.gridY >= 0 ? item.gridY : item.originalGridY;
            
            // Immediately destroy the sprite to prevent visual duplication
            if (item.sprite && item.mainSprite) {
                // Create a temporary sprite for the return animation from the original position
                const originalPos = gridToWorld(originalGridX, originalGridY);
                const tempSprite = scene.add.rectangle(
                    originalPos.x, 
                    originalPos.y, 
                    40, 20, 
                    item.color
                );
                tempSprite.setStrokeStyle(2, 0x4CAF50);
                tempSprite.setDepth(2000);
                
                // Immediately hide and destroy all sprite components
                try {
                    // First, make all sprites invisible immediately
                    if (item.sprite.children && item.sprite.children.entries) {
                        item.sprite.children.entries.forEach(child => {
                            if (child) {
                                child.setVisible(false);
                                child.setActive(false);
                            }
                        });
                    }
                    
                    // Also hide the main sprite directly if accessible
                    if (item.mainSprite) {
                        item.mainSprite.setVisible(false);
                        item.mainSprite.setActive(false);
                    }
                    
                    // Clear the group
                    item.sprite.clear(true, true); // Remove and destroy all children
                    
                    // Destroy the group itself
                    item.sprite.destroy();
                    
                } catch (error) {
                    console.warn('Error destroying sprite:', error);
                    // Fallback: try to destroy the group directly
                    if (item.sprite && item.sprite.destroy) {
                        item.sprite.destroy();
                    }
                }
                
                // Clear references
                item.sprite = null;
                item.mainSprite = null;
                
                // Animate the temporary sprite moving to item bank area
                const itemBankElement = item.htmlElement;
                const itemBankRect = itemBankElement ? itemBankElement.getBoundingClientRect() : null;
                const canvas = document.querySelector('canvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                let targetX = 50; // Default fallback position
                let targetY = 50;
                
                if (itemBankRect && canvasRect) {
                    // Calculate relative position within canvas
                    targetX = itemBankRect.left - canvasRect.left + itemBankRect.width / 2;
                    targetY = itemBankRect.top - canvasRect.top + itemBankRect.height / 2;
                }
                
                // Animate return to bank
                scene.tweens.add({
                    targets: tempSprite,
                    x: targetX,
                    y: targetY,
                    scaleX: 0.5,
                    scaleY: 0.5,
                    alpha: 0.8,
                    duration: 500,
                    ease: 'Power2',
                    onComplete: () => {
                        tempSprite.destroy();
                        
                        // Flash the HTML element to show it's back
                        if (itemBankElement) {
                            itemBankElement.style.animation = 'pulse 0.5s ease-in-out';
                            setTimeout(() => {
                                itemBankElement.style.animation = '';
                            }, 500);
                        }
                    }
                });
            }
            
            // Clear grid position
            if (originalGridX >= 0 && originalGridY >= 0) {
                setGridPosition(originalGridX, originalGridY, null);
            }
            
            // Handle gap state - only show gap indicator if this was actually a gap position
            const gap = gameState.gaps.find(g => 
                g.x === originalGridX && g.y === originalGridY
            );
            if (gap) {
                gap.filled = false;
                if (gap.sprite) {
                    gap.sprite.setVisible(true);
                }
                console.log('Gap indicator restored for position:', originalGridX, originalGridY);
            } else {
                console.log('No gap found at position:', originalGridX, originalGridY, '- this is correct for non-gap positions');
            }
            
            // Ensure all drop zone highlights are cleared (removes green highlighting)
            highlightDropZones(false);
            
            // Reset item state
            item.inBank = true;
            item.placed = false;
            item.gridX = -1;
            item.gridY = -1;
            item.isDragging = false;
            
            // Clear any stored positions
            item.originalX = undefined;
            item.originalY = undefined;
            item.originalGridX = undefined;
            item.originalGridY = undefined;
            
            // Clean up any removal hints
            if (item.removalHint) {
                item.removalHint.destroy();
                item.removalHint = null;
            }
            
            // Show HTML element again with enhanced visual feedback
            if (item.htmlElement) {
                item.htmlElement.style.display = 'flex';
                item.htmlElement.style.cursor = 'grab';
                item.htmlElement.style.opacity = '1';
                item.htmlElement.style.transform = 'scale(1)';
                
                // Add a brief highlight effect
                item.htmlElement.style.boxShadow = '0 0 10px #4CAF50';
                setTimeout(() => {
                    item.htmlElement.style.boxShadow = '';
                }, 1000);
            }
            
            // Update wire connections when item is removed
            updateWireConnections();
            
            // Stop current flow animation since circuit is now incomplete
            visualizeCurrentFlow(false);
            
            console.log('Item successfully returned to bank');
        }

        function placeItemOnGrid(item, gridX, gridY) {
            // Hide HTML element
            if (item.htmlElement) {
                item.htmlElement.style.display = 'none';
            }
            
            // Create game sprite
            createGameSprite(item, gridX, gridY);
            
            // Update item state
            item.inBank = false;
            item.placed = true;
            item.gridX = gridX;
            item.gridY = gridY;
            
            // Update grid - mark all cells occupied by this item
            for (let dy = 0; dy < item.size.height; dy++) {
                for (let dx = 0; dx < item.size.width; dx++) {
                    setGridPosition(gridX + dx, gridY + dy, item);
                }
            }
            
            // Check if this fills a gap (must match size exactly)
            const gap = gameState.gaps.find(g => 
                g.x === gridX && g.y === gridY &&
                g.size.width === item.size.width &&
                g.size.height === item.size.height
            );
            
            if (gap) {
                gap.filled = true;
                gap.filledWith = item;
                if (gap.sprite) {
                    gap.sprite.setVisible(false);
                }
                
                // Show success feedback for correct placement
                showFeedback(`✅ ${item.name} placed in ${gap.label}!`, 'success');
            }
            
            // Add to placed items
            gameState.placedItems.push(item);
            
            // Update wire connections when item is placed
            updateWireConnections();
        }

        function setupInputHandling() {
            // Set up drag and drop for item bank items
            setupItemBankDragDrop();
            
            // Set up canvas drop zone
            setupCanvasDropZone();
            
            // Set up placed item interaction
            setupPlacedItemInteraction();
        }

        function setupItemBankDragDrop() {
            gameState.itemBank.forEach(item => {
                if (item.htmlElement) {
                    item.htmlElement.addEventListener('mousedown', function(e) {
                        if (item.inBank) {
                            startDragging(item, e);
                        }
                    });
                }
            });
        }

        function startDragging(item, e) {
            e.preventDefault();
            
            gameState.draggedItem = item;
            gameState.isDragging = true;
            
            // Create drag preview
            createDragPreview(item, e.clientX, e.clientY);
            
            // Change cursor
            document.body.style.cursor = 'grabbing';
            
            // Add global mouse move and up listeners
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
            
            // Highlight valid drop zones
            highlightDropZones(true);
        }

        function createDragPreview(item, x, y) {
            const preview = document.createElement('div');
            preview.id = 'drag-preview';
            preview.style.cssText = `
                position: fixed;
                left: ${x - 40}px;
                top: ${y - 30}px;
                width: 80px;
                height: 60px;
                background-color: ${item.color};
                border: 2px solid #333;
                border-radius: 5px;
                opacity: 0.8;
                pointer-events: none;
                z-index: 1000;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                transform: scale(0.9);
            `;
            
            // Add type indicator
            const typeIndicator = document.createElement('div');
            typeIndicator.style.cssText = `
                width: 100%;
                height: 15px;
                background-color: ${item.conductive ? '#4CAF50' : '#F44336'};
                color: white;
                font-size: 8px;
                text-align: center;
                line-height: 15px;
                font-weight: bold;
                margin-bottom: 2px;
            `;
            typeIndicator.textContent = item.conductive ? 'CONDUCTOR' : 'INSULATOR';
            
            // Add item name
            const nameLabel = document.createElement('div');
            nameLabel.style.cssText = `
                color: white;
                font-size: 10px;
                text-align: center;
                font-weight: bold;
                text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
                line-height: 12px;
            `;
            nameLabel.textContent = item.name;
            
            preview.appendChild(typeIndicator);
            preview.appendChild(nameLabel);
            
            document.body.appendChild(preview);
        }

        function handleDragMove(e) {
            if (!gameState.isDragging || !gameState.draggedItem) return;
            
            // Update drag preview position
            const preview = document.getElementById('drag-preview');
            if (preview) {
                preview.style.left = (e.clientX - 40) + 'px';
                preview.style.top = (e.clientY - 30) + 'px';
            }
            
            // Check if over valid drop zone
            updateDropZoneHighlight(e.clientX, e.clientY);
        }

        function handleDragEnd(e) {
            if (!gameState.isDragging || !gameState.draggedItem) return;
            
            // Remove drag preview
            const preview = document.getElementById('drag-preview');
            if (preview) {
                preview.remove();
            }
            
            // Check if dropped on valid location
            const dropResult = checkDropLocation(e.clientX, e.clientY);
            
            if (dropResult.valid) {
                // Place item on grid
                placeItemOnGrid(gameState.draggedItem, dropResult.gridX, dropResult.gridY);
            } else {
                // Return to bank (item stays in bank)
                console.log('Invalid drop location - item stays in bank');
            }
            
            // Clean up
            cleanupDrag();
        }

        function cleanupDrag() {
            // Remove event listeners
            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
            
            // Reset cursor
            document.body.style.cursor = 'default';
            
            // Hide drop zone highlights
            highlightDropZones(false);
            
            // Reset drag state
            gameState.draggedItem = null;
            gameState.isDragging = false;
        }

        function checkDropLocation(clientX, clientY) {
            // Get canvas bounds
            const canvas = document.querySelector('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            
            // Check if over canvas
            if (clientX < canvasRect.left || clientX > canvasRect.right ||
                clientY < canvasRect.top || clientY > canvasRect.bottom) {
                return { valid: false };
            }
            
            // Convert to canvas coordinates
            const canvasX = clientX - canvasRect.left;
            const canvasY = clientY - canvasRect.top;
            
            // Convert to grid coordinates
            const gridPos = worldToGrid(canvasX, canvasY);
            
            // Get the dragged item's size
            const draggedItem = gameState.draggedItem;
            if (!draggedItem || !draggedItem.size) {
                return { valid: false };
            }
            
            // Check if there's a gap that matches the item size at this position
            const matchingGap = gameState.gaps.find(gap => 
                gap.x === gridPos.x && gap.y === gridPos.y && 
                !gap.filled &&
                gap.size.width === draggedItem.size.width &&
                gap.size.height === draggedItem.size.height
            );
            
            if (matchingGap && isGridPositionEmpty(gridPos.x, gridPos.y)) {
                return { valid: true, gridX: gridPos.x, gridY: gridPos.y, gap: matchingGap };
            }
            
            return { valid: false };
        }

        function highlightDropZones(show) {
            const draggedItem = gameState.draggedItem;
            
            gameState.gaps.forEach(gap => {
                if (!gap.filled && gap.sprite) {
                    const graphics = gap.sprite.getChildren()[0]; // Get the graphics object
                    const pos = gridToWorld(gap.x, gap.y);
                    
                    // Calculate gap size based on the gap's size property
                    const gapSize = gap.size || { width: 1, height: 1 };
                    const cellSize = gameState.cellSize;
                    
                    // Calculate proper center position for multi-cell gaps (same as markGaps)
                    const centerX = pos.x + (cellSize * (gapSize.width - 1)) / 2;
                    const centerY = pos.y + (cellSize * (gapSize.height - 1)) / 2;
                    
                    const width = (cellSize * gapSize.width) - 10;
                    const height = (cellSize * gapSize.height) - 10;
                    const x = centerX - width / 2;
                    const y = centerY - height / 2;
                    
                    graphics.clear();
                    
                    // Check if this gap is compatible with the dragged item
                    const isCompatible = !draggedItem || 
                        (draggedItem.size.width === gapSize.width && 
                         draggedItem.size.height === gapSize.height);
                    
                    if (show && isCompatible) {
                        // Show solid green highlight for compatible gaps
                        graphics.lineStyle(3, 0x4CAF50, 1.0);
                        graphics.strokeRect(x, y, width, height);
                    } else if (show && !isCompatible) {
                        // Show orange highlight for incompatible gaps
                        graphics.lineStyle(2, 0xFF9800, 0.6);
                        graphics.strokeRect(x, y, width, height);
                    } else {
                        // Show dashed red outline (default state)
                        graphics.lineStyle(2, 0xFF6B6B, 0.8);
                        
                        const dashLength = 5;
                        const gapLength = 5;
                        
                        // Top line
                        for (let i = 0; i < width; i += dashLength + gapLength) {
                            const lineWidth = Math.min(dashLength, width - i);
                            graphics.moveTo(x + i, y);
                            graphics.lineTo(x + i + lineWidth, y);
                        }
                        
                        // Bottom line
                        for (let i = 0; i < width; i += dashLength + gapLength) {
                            const lineWidth = Math.min(dashLength, width - i);
                            graphics.moveTo(x + i, y + height);
                            graphics.lineTo(x + i + lineWidth, y + height);
                        }
                        
                        // Left line
                        for (let i = 0; i < height; i += dashLength + gapLength) {
                            const lineHeight = Math.min(dashLength, height - i);
                            graphics.moveTo(x, y + i);
                            graphics.lineTo(x, y + i + lineHeight);
                        }
                        
                        // Right line
                        for (let i = 0; i < height; i += dashLength + gapLength) {
                            const lineHeight = Math.min(dashLength, height - i);
                            graphics.moveTo(x + width, y + i);
                            graphics.lineTo(x + width, y + i + lineHeight);
                        }
                        
                        graphics.strokePath();
                    }
                }
            });
        }

        function updateDropZoneHighlight(clientX, clientY) {
            const dropResult = checkDropLocation(clientX, clientY);
            
            // Update cursor based on drop validity
            if (dropResult.valid) {
                document.body.style.cursor = 'copy';
            } else {
                document.body.style.cursor = 'not-allowed';
            }
        }

        function setupCanvasDropZone() {
            const canvas = document.querySelector('canvas');
            
            canvas.addEventListener('dragover', function(e) {
                e.preventDefault();
            });
            
            canvas.addEventListener('drop', function(e) {
                e.preventDefault();
                // Drag and drop is handled by mouse events
            });
        }

        function setupPlacedItemInteraction() {
            // Set up click handling for placed items (for removal)
            scene.input.on('gameobjectdown', function(pointer, gameObject) {
                // Find the item that was clicked
                const clickedItem = gameState.itemBank.find(item => 
                    item.mainSprite === gameObject
                );
                
                if (clickedItem && clickedItem.placed && !clickedItem.isDragging) {
                    // Check if it's a pre-placed component
                    if (isPreplacedComponent(clickedItem.gridX, clickedItem.gridY)) {
                        showFeedback('❌ Pre-placed components cannot be removed', 'error');
                        return;
                    }
                    
                    // Only handle click removal if not dragging and not pre-placed
                    // Return item to bank (handles gap state internally)
                    returnItemToBank(clickedItem);
                    
                    // Show enhanced feedback
                    showFeedback('✅ Item returned to bank! You can place it again or try different materials.', 'success');
                }
            });
        }

        // Utility functions
        function gridToWorld(gridX, gridY) {
            return {
                x: gridX * gameState.cellSize + gameState.cellSize / 2,
                y: gridY * gameState.cellSize + gameState.cellSize / 2
            };
        }

        function isPreplacedComponent(gridX, gridY) {
            // Check if position contains battery, bulb, or pre-placed wire
            const gridContent = getGridPosition(gridX, gridY);
            return gridContent === 'battery' || gridContent === 'bulb' || gridContent === 'wire';
        }

        function worldToGrid(worldX, worldY) {
            return {
                x: Math.floor(worldX / gameState.cellSize),
                y: Math.floor(worldY / gameState.cellSize)
            };
        }

        function isValidGridPosition(gridX, gridY) {
            return gridX >= 0 && gridX < gameState.gridWidth && 
                   gridY >= 0 && gridY < gameState.gridHeight;
        }

        function isGridPositionEmpty(gridX, gridY) {
            if (!isValidGridPosition(gridX, gridY)) return false;
            const gridContent = gameState.grid[gridY][gridX];
            // Allow placement on empty positions or gap positions
            return gridContent === null || gridContent === 'gap';
        }

        function setGridPosition(gridX, gridY, item) {
            if (isValidGridPosition(gridX, gridY)) {
                gameState.grid[gridY][gridX] = item;
            }
        }

        function getGridPosition(gridX, gridY) {
            if (isValidGridPosition(gridX, gridY)) {
                return gameState.grid[gridY][gridX];
            }
            return null;
        }

        // Circuit evaluation functions
        function evaluateCircuit() {
            console.log('=== EVALUATING CIRCUIT ===');
            
            // Debug: Show current state of gaps
            console.log('Gap states:');
            gameState.gaps.forEach((gap, index) => {
                const item = getGridPosition(gap.x, gap.y);
                console.log(`Gap ${index} at (${gap.x},${gap.y}): filled=${gap.filled}, item=`, item);
            });
            
            // Find path from battery positive to battery negative through the bulb
            const hasCompletePath = findCircuitPath();
            
            console.log('Circuit evaluation result:', hasCompletePath);
            updateLightBulb(hasCompletePath);
            
            // Update wire connections to show the complete circuit path
            updateWireConnections();
            
            return hasCompletePath;
        }

        function findCircuitPath() {
            // Two-wire circuit: positive terminal -> top wire -> bulb -> bottom wire -> negative terminal
            
            // Check if we can trace a complete path from battery positive to battery negative through the bulb
            // The path must go: battery positive -> top wire -> bulb top -> bulb bottom -> bottom wire -> battery negative
            
            const batteryPosX = gameState.battery.x + 1; // Position right of battery
            const topWireY = gameState.battery.y - 1;    // Top wire (y=3)
            const bottomWireY = gameState.battery.y + 1; // Bottom wire (y=5)
            const bulbTopY = gameState.bulb.y - 1;       // Bulb top connection
            const bulbBottomY = gameState.bulb.y + 1;    // Bulb bottom connection
            
            console.log('Checking circuit path...');
            console.log('Battery at:', gameState.battery.x, gameState.battery.y);
            console.log('Bulb at:', gameState.bulb.x, gameState.bulb.y);
            
            // Check path from battery positive terminal to bulb via top wire
            const topPathComplete = checkPathSegment(batteryPosX, topWireY, gameState.bulb.x, bulbTopY);
            console.log('Top path (battery to bulb):', topPathComplete);
            
            // Check path from bulb to battery negative terminal via bottom wire  
            const bottomPathComplete = checkPathSegment(gameState.bulb.x, bulbBottomY, batteryPosX, bottomWireY);
            console.log('Bottom path (bulb to battery):', bottomPathComplete);
            
            // Check if bulb connections are conductive (bulb acts as a bridge between top and bottom)
            const bulbConnected = isConductive(gameState.bulb.x, bulbTopY) && 
                                 isConductive(gameState.bulb.x, bulbBottomY);
            console.log('Bulb connected:', bulbConnected);
            
            const circuitComplete = topPathComplete && bottomPathComplete && bulbConnected;
            console.log('Circuit complete:', circuitComplete);
            
            return circuitComplete;
        }
        
        function checkPathSegment(startX, startY, endX, endY) {
            // Check if there's a continuous conductive path between two points
            console.log(`Checking path from (${startX},${startY}) to (${endX},${endY})`);
            
            // For horizontal wire segments, check each position along the path
            if (startY === endY) {
                // Horizontal path - check each position from start to end
                const minX = Math.min(startX, endX);
                const maxX = Math.max(startX, endX);
                
                for (let x = minX; x <= maxX; x++) {
                    if (!isConductive(x, startY)) {
                        console.log(`Path blocked at (${x},${startY})`);
                        return false;
                    }
                }
                console.log(`Complete horizontal path found from (${startX},${startY}) to (${endX},${endY})`);
                return true;
            }
            
            // For other paths, use breadth-first search
            const queue = [{x: startX, y: startY}];
            const visited = new Set();
            
            while (queue.length > 0) {
                const current = queue.shift();
                const key = `${current.x},${current.y}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                
                // Check if we reached the destination
                if (current.x === endX && current.y === endY) {
                    console.log(`Path found from (${startX},${startY}) to (${endX},${endY})`);
                    return true;
                }
                
                // Check adjacent positions
                const adjacent = [
                    {x: current.x + 1, y: current.y},
                    {x: current.x - 1, y: current.y},
                    {x: current.x, y: current.y + 1},
                    {x: current.x, y: current.y - 1}
                ];
                
                adjacent.forEach(pos => {
                    const adjKey = `${pos.x},${pos.y}`;
                    if (!visited.has(adjKey) && isConductive(pos.x, pos.y)) {
                        queue.push(pos);
                    }
                });
            }
            
            console.log(`No path found from (${startX},${startY}) to (${endX},${endY})`);
            return false;
        }

        function isConductive(x, y) {
            // Check bounds
            if (!isValidGridPosition(x, y)) {
                return false;
            }
            
            const gridItem = getGridPosition(x, y);
            
            // Empty positions are not conductive
            if (gridItem === null) {
                return false;
            }
            
            // Check different component types
            if (gridItem === 'battery' || gridItem === 'bulb' || gridItem === 'wire') {
                return true;
            }
            
            // Check placed items
            if (typeof gridItem === 'object' && gridItem.conductive !== undefined) {
                return gridItem.conductive;
            }
            
            // Default to non-conductive
            return false;
        }

        // Visual Connection System Functions
        function updateWireConnections() {
            console.log('Updating wire connections...');
            
            // Clear existing connection graphics
            clearConnectionGraphics();
            
            // Draw connections from battery terminals
            drawBatteryConnections();
            
            // Draw connections to bulb terminals
            drawBulbConnections();
            
            // For each placed conductive item, draw connections to adjacent components
            gameState.itemBank.forEach(item => {
                if (item.placed && item.conductive) {
                    drawConnectionsForItem(item);
                }
            });
            
            // Draw connections between pre-placed wires and adjacent components
            gameState.preplacedWires.forEach(wire => {
                drawConnectionsForWire(wire);
            });
            
            // If circuit is complete, draw the continuous path (without animation - handled by visualizeCurrentFlow)
            if (gameState.bulb.isLit) {
                drawContinuousPathOnly();
            }
            
            console.log('Wire connections updated');
        }

        function clearConnectionGraphics() {
            // Destroy all existing connection graphics
            gameState.connectionGraphics.forEach(graphic => {
                if (graphic && graphic.destroy) {
                    graphic.destroy();
                }
            });
            gameState.connectionGraphics = [];
        }

        function drawBatteryConnections() {
            const batteryPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            
            // Draw connection from battery positive terminal to top wire
            const topWirePos = gridToWorld(gameState.battery.x + 1, gameState.battery.y - 1);
            if (isConductive(gameState.battery.x + 1, gameState.battery.y - 1)) {
                drawWireConnection(
                    { x: batteryPos.x + 25, y: batteryPos.y - 15 }, // Battery positive terminal
                    topWirePos,
                    0xCD7F32, // Copper color
                    4
                );
            }
            
            // Draw connection from battery negative terminal to bottom wire
            const bottomWirePos = gridToWorld(gameState.battery.x + 1, gameState.battery.y + 1);
            if (isConductive(gameState.battery.x + 1, gameState.battery.y + 1)) {
                drawWireConnection(
                    { x: batteryPos.x + 25, y: batteryPos.y + 15 }, // Battery negative terminal
                    bottomWirePos,
                    0xCD7F32, // Copper color
                    4
                );
            }
        }

        function drawBulbConnections() {
            const bulbPos = gridToWorld(gameState.bulb.x, gameState.bulb.y);
            
            // Draw connection from top wire to bulb top terminal
            const topWirePos = gridToWorld(gameState.bulb.x - 1, gameState.bulb.y - 1);
            if (isConductive(gameState.bulb.x - 1, gameState.bulb.y - 1)) {
                drawWireConnection(
                    topWirePos,
                    { x: bulbPos.x - 15, y: bulbPos.y - 15 }, // Bulb top terminal
                    0xCD7F32, // Copper color
                    4
                );
            }
            
            // Draw connection from bulb bottom terminal to bottom wire
            const bottomWirePos = gridToWorld(gameState.bulb.x - 1, gameState.bulb.y + 1);
            if (isConductive(gameState.bulb.x - 1, gameState.bulb.y + 1)) {
                drawWireConnection(
                    { x: bulbPos.x - 15, y: bulbPos.y + 15 }, // Bulb bottom terminal
                    bottomWirePos,
                    0xCD7F32, // Copper color
                    4
                );
            }
        }

        function drawConnectionsForItem(item) {
            if (!item.placed || !item.conductive) return;
            
            const itemPos = gridToWorld(item.gridX, item.gridY);
            const adjacentPositions = getAdjacentPositions(item.gridX, item.gridY);
            
            adjacentPositions.forEach(pos => {
                if (isConductive(pos.x, pos.y)) {
                    const adjacentPos = gridToWorld(pos.x, pos.y);
                    drawWireConnection(itemPos, adjacentPos, 0xCD7F32, 3);
                }
            });
        }

        function drawConnectionsForWire(wire) {
            const wirePos = gridToWorld(wire.x, wire.y);
            const adjacentPositions = getAdjacentPositions(wire.x, wire.y);
            
            adjacentPositions.forEach(pos => {
                if (isConductive(pos.x, pos.y)) {
                    const adjacentPos = gridToWorld(pos.x, pos.y);
                    // Only draw if it's not another pre-placed wire (to avoid duplicate lines)
                    const adjacentContent = getGridPosition(pos.x, pos.y);
                    if (adjacentContent !== 'wire') {
                        drawWireConnection(wirePos, adjacentPos, 0xCD7F32, 3);
                    }
                }
            });
        }

        function drawWireConnection(fromPos, toPos, color, lineWidth) {
            const graphics = scene.add.graphics();
            graphics.lineStyle(lineWidth, color, 0.8);
            
            // Draw connecting wire with proper endpoints
            graphics.moveTo(fromPos.x, fromPos.y);
            graphics.lineTo(toPos.x, toPos.y);
            graphics.strokePath();
            
            // Add subtle glow effect for active connections
            if (gameState.bulb.isLit) {
                const glowGraphics = scene.add.graphics();
                glowGraphics.lineStyle(lineWidth + 2, color, 0.3);
                glowGraphics.moveTo(fromPos.x, fromPos.y);
                glowGraphics.lineTo(toPos.x, toPos.y);
                glowGraphics.strokePath();
                glowGraphics.setDepth(-1);
                gameState.connectionGraphics.push(glowGraphics);
            }
            
            // Store reference for cleanup
            gameState.connectionGraphics.push(graphics);
        }

        function getAdjacentPositions(gridX, gridY) {
            const positions = [];
            
            // Check all 4 adjacent positions (up, down, left, right)
            const directions = [
                { x: 0, y: -1 }, // Up
                { x: 0, y: 1 },  // Down
                { x: -1, y: 0 }, // Left
                { x: 1, y: 0 }   // Right
            ];
            
            directions.forEach(dir => {
                const newX = gridX + dir.x;
                const newY = gridY + dir.y;
                
                if (isValidGridPosition(newX, newY)) {
                    positions.push({ x: newX, y: newY });
                }
            });
            
            return positions;
        }

        function drawContinuousPathOnly() {
            // Draw the complete electrical path when circuit is active (without animation)
            if (!gameState.bulb.isLit) return;
            
            console.log('Drawing continuous electrical path...');
            
            // Create a special graphics object for the complete path
            const pathGraphics = scene.add.graphics();
            pathGraphics.lineStyle(6, 0xFFD700, 0.6); // Golden color for active path
            pathGraphics.setDepth(10); // Above other connections
            
            // Draw the complete circuit path
            const batteryPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            const bulbPos = gridToWorld(gameState.bulb.x, gameState.bulb.y);
            
            // Start from battery positive terminal
            pathGraphics.moveTo(batteryPos.x + 25, batteryPos.y - 15);
            
            // Trace through top wire to bulb
            for (let x = gameState.battery.x + 1; x < gameState.bulb.x; x++) {
                if (isConductive(x, gameState.battery.y - 1)) {
                    const pos = gridToWorld(x, gameState.battery.y - 1);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // Connect to bulb top terminal
            pathGraphics.lineTo(bulbPos.x - 15, bulbPos.y - 15);
            
            // Through bulb to bottom terminal
            pathGraphics.lineTo(bulbPos.x - 15, bulbPos.y + 15);
            
            // Trace through bottom wire back to battery
            for (let x = gameState.bulb.x - 1; x > gameState.battery.x; x--) {
                if (isConductive(x, gameState.battery.y + 1)) {
                    const pos = gridToWorld(x, gameState.battery.y + 1);
                    pathGraphics.lineTo(pos.x, pos.y);
                }
            }
            
            // End at battery negative terminal
            pathGraphics.lineTo(batteryPos.x + 25, batteryPos.y + 15);
            
            pathGraphics.strokePath();
            
            // Store for cleanup
            gameState.connectionGraphics.push(pathGraphics);
        }



        function visualizeCurrentFlow(hasFlow) {
            console.log('visualizeCurrentFlow called with hasFlow:', hasFlow);
            console.log('gameState.bulb.isLit:', gameState.bulb.isLit);
            console.log('scene available:', !!scene);
            
            // Remove existing flow visualization
            if (gameState.flowVisualization) {
                console.log('Cleaning up existing flow visualization, count:', gameState.flowVisualization.length);
                gameState.flowVisualization.forEach(particle => {
                    // Clean up animation timers
                    if (particle.animationTimer) {
                        particle.animationTimer.destroy();
                    }
                    if (particle.destroy) particle.destroy();
                });
                gameState.flowVisualization = [];
            }
            
            if (!hasFlow) {
                console.log('hasFlow is false, stopping animation');
                return;
            }
            
            if (!gameState.bulb.isLit) {
                console.log('Bulb is not lit, not starting animation');
                return;
            }
            
            // Create a chain of synchronized pulsating particles
            gameState.flowVisualization = [];
            
            console.log('Starting synchronized chain of pulsating particles...');
            
            // Build the complete circuit path
            const circuitPath = buildCompleteCircuitPath();
            console.log('Circuit path:', circuitPath);
            
            if (circuitPath.length === 0) {
                console.log('No valid circuit path found');
                return;
            }
            
            // Calculate particle count based on circuit path length
            const pathLength = circuitPath.length;
            const particleCount = Math.max(3, Math.floor(pathLength / 3)); // One particle every 3 path points, minimum 3
            
            console.log(`Circuit path length: ${pathLength}, Particle count: ${particleCount}`);
            
            const particles = [];
            
            // Create particles at evenly spaced positions along the path
            for (let i = 0; i < particleCount; i++) {
                // Calculate evenly spaced starting positions to maintain consistent distance
                const startIndex = Math.floor((i / particleCount) * pathLength);
                const startPosition = circuitPath[startIndex];
                
                console.log(`Creating particle ${i} at path index ${startIndex}, position:`, startPosition);
                
                // Create yellow particle
                const particle = scene.add.circle(startPosition.x, startPosition.y, 6, 0xFFFF00);
                particle.setAlpha(1.0);
                particle.setDepth(25);
                
                // Create yellow glow effect
                const glow = scene.add.circle(startPosition.x, startPosition.y, 12, 0xFFFF00);
                glow.setAlpha(0.4);
                glow.setDepth(24);
                
                particles.push({ 
                    particle, 
                    glow, 
                    startIndex: startIndex,
                    particleIndex: i 
                });
                gameState.flowVisualization.push(particle, glow);
                
                console.log(`Particle ${i} created successfully at evenly spaced position`);
            }
            
            console.log(`Created ${particles.length} particles in chain`);
            
            // Start synchronized pulsating animation
            startPulsatingChainAnimation(particles, circuitPath);
        }

        function buildCompleteCircuitPath() {
            const path = [];
            const batteryPos = gridToWorld(gameState.battery.x, gameState.battery.y);
            const bulbPos = gridToWorld(gameState.bulb.x, gameState.bulb.y);
            
            console.log('Building circuit path...');
            console.log('Battery position:', batteryPos);
            console.log('Bulb position:', bulbPos);
            
            // Start at battery positive terminal
            path.push({ x: batteryPos.x + 25, y: batteryPos.y - 15, isTerminal: true });
            
            // Top wire (positive path) from battery to bulb
            for (let x = gameState.battery.x + 1; x < gameState.bulb.x; x++) {
                if (isConductive(x, gameState.battery.y - 1)) {
                    const pos = gridToWorld(x, gameState.battery.y - 1);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added top wire position: (${pos.x}, ${pos.y})`);
                }
            }
            
            // Bulb top terminal
            path.push({ x: bulbPos.x - 15, y: bulbPos.y - 15, isBulb: true });
            
            // Through bulb
            path.push({ x: bulbPos.x - 15, y: bulbPos.y, isBulb: true });
            path.push({ x: bulbPos.x - 15, y: bulbPos.y + 15, isBulb: true });
            
            // Bottom wire (negative path) from bulb back to battery
            for (let x = gameState.bulb.x - 1; x > gameState.battery.x; x--) {
                if (isConductive(x, gameState.battery.y + 1)) {
                    const pos = gridToWorld(x, gameState.battery.y + 1);
                    path.push({ x: pos.x, y: pos.y, isWire: true });
                    console.log(`Added bottom wire position: (${pos.x}, ${pos.y})`);
                }
            }
            
            // Battery negative terminal
            path.push({ x: batteryPos.x + 25, y: batteryPos.y + 15, isTerminal: true });
            
            console.log(`Complete circuit path built with ${path.length} points`);
            return path;
        }

        function calculatePathDistance(path) {
            let totalDistance = 0;
            
            for (let i = 1; i < path.length; i++) {
                const prev = path[i - 1];
                const curr = path[i];
                const distance = Math.sqrt(
                    Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)
                );
                totalDistance += distance;
            }
            
            return totalDistance;
        }

        function getPositionAtDistance(path, targetDistance) {
            let currentDistance = 0;
            
            for (let i = 1; i < path.length; i++) {
                const prev = path[i - 1];
                const curr = path[i];
                const segmentDistance = Math.sqrt(
                    Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)
                );
                
                if (currentDistance + segmentDistance >= targetDistance) {
                    // The target distance is within this segment
                    const remainingDistance = targetDistance - currentDistance;
                    const ratio = remainingDistance / segmentDistance;
                    
                    return {
                        x: prev.x + (curr.x - prev.x) * ratio,
                        y: prev.y + (curr.y - prev.y) * ratio
                    };
                }
                
                currentDistance += segmentDistance;
            }
            
            // If we've gone past the end, return the last position
            return path[path.length - 1];
        }

        function startPulsatingChainAnimation(particles, circuitPath) {
            console.log(`Starting pulsating animation for ${particles.length} particles`);
            
            // Create synchronized pulsating effect for all particles
            particles.forEach(({ particle, glow }, index) => {
                console.log(`Setting up pulsing for particle ${index}`);
                
                // Pulsating scale animation
                scene.tweens.add({
                    targets: [particle, glow],
                    scaleX: 1.5,
                    scaleY: 1.5,
                    duration: 600,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
                
                // Pulsating alpha animation for extra effect
                scene.tweens.add({
                    targets: particle,
                    alpha: 0.6,
                    duration: 800,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            });
            
            // Start movement animation after a brief delay to see pulsing first
            setTimeout(() => {
                console.log('Starting movement animation...');
                animateLinearMovement(particles, circuitPath);
            }, 1000);
        }

        function animateLinearMovement(particles, circuitPath) {
            if (!gameState.bulb.isLit) return;
            
            console.log('Starting circuit flow animation');
            console.log('Circuit path length:', circuitPath.length);
            console.log('First few path points:', circuitPath.slice(0, 5));
            
            // Now implement proper circuit flow since basic movement works
            particles.forEach(({ particle, glow }, index) => {
                console.log(`Starting circuit flow for particle ${index}`);
                animateParticleAroundCircuit(particle, glow, circuitPath, index);
            });
        }

        function animateParticleAroundCircuit(particle, glow, circuitPath, particleIndex) {
            if (!gameState.bulb.isLit || !particle.active || circuitPath.length === 0) {
                console.log('Cannot animate - conditions not met');
                return;
            }
            
            console.log(`Animating particle ${particleIndex} around circuit`);
            
            // Find the closest path point to the particle's current position to maintain spacing
            let currentPathIndex = 0;
            let minDistance = Infinity;
            
            for (let i = 0; i < circuitPath.length; i++) {
                const pathPoint = circuitPath[i];
                const distance = Math.sqrt(
                    Math.pow(particle.x - pathPoint.x, 2) + 
                    Math.pow(particle.y - pathPoint.y, 2)
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    currentPathIndex = i;
                }
            }
            
            console.log(`Particle ${particleIndex} starting from path index ${currentPathIndex}`);
            
            const animationSpeed = 300; // milliseconds per path segment
            
            const moveToNextPoint = () => {
                if (!gameState.bulb.isLit || !particle.active) {
                    console.log('Stopping animation - circuit incomplete');
                    return;
                }
                
                // Move to next point in circuit (maintaining the circular flow)
                currentPathIndex = (currentPathIndex + 1) % circuitPath.length;
                const nextPoint = circuitPath[currentPathIndex];
                
                console.log(`Moving particle ${particleIndex} to point ${currentPathIndex}:`, nextPoint);
                
                // Animate to next point
                scene.tweens.add({
                    targets: [particle, glow],
                    x: nextPoint.x,
                    y: nextPoint.y,
                    duration: animationSpeed,
                    ease: 'Linear',
                    onComplete: () => {
                        // Continue to next point after a small delay
                        setTimeout(() => {
                            moveToNextPoint();
                        }, 50); // Small delay between segments
                    }
                });
            };
            
            // Start the animation
            moveToNextPoint();
        }



        function getActualCircuitPath() {
            // Return the path from positive terminal through both wires to negative terminal
            const path = [];
            
            // Top wire (positive path) - from battery to bulb
            const topY = gameState.battery.y - 1; // Row 3
            for (let x = gameState.battery.x + 1; x <= gameState.bulb.x; x++) {
                if (isConductive(x, topY)) {
                    path.push({x: x, y: topY});
                }
            }
            
            // Through the bulb (if both connections are conductive)
            if (isConductive(gameState.bulb.x, topY) && isConductive(gameState.bulb.x, gameState.battery.y + 1)) {
                path.push({x: gameState.bulb.x, y: gameState.bulb.y}); // Bulb center
            }
            
            // Bottom wire (negative path) - from bulb back to battery
            const bottomY = gameState.battery.y + 1; // Row 5
            for (let x = gameState.bulb.x; x >= gameState.battery.x + 1; x--) {
                if (isConductive(x, bottomY)) {
                    path.push({x: x, y: bottomY});
                }
            }
            
            return path;
        }

        function getCircuitAnalysis() {
            const analysis = {
                gapsFilled: 0,
                totalGaps: gameState.gaps.length,
                conductorsPlaced: 0,
                insulatorsPlaced: 0,
                placedItems: []
            };
            
            gameState.gaps.forEach(gap => {
                if (gap.filled) {
                    analysis.gapsFilled++;
                    const item = getGridPosition(gap.x, gap.y);
                    if (item && typeof item === 'object') {
                        analysis.placedItems.push({
                            name: item.name,
                            type: item.type,
                            conductive: item.conductive,
                            position: {x: gap.x, y: gap.y}
                        });
                        
                        if (item.conductive) {
                            analysis.conductorsPlaced++;
                        } else {
                            analysis.insulatorsPlaced++;
                        }
                    }
                }
            });
            
            return analysis;
        }

        function showFeedback(message, type = 'info') {
            const feedbackArea = document.getElementById('feedback-area');
            feedbackArea.textContent = message;
            feedbackArea.className = `feedback-${type}`;
            
            // Add pulse animation for important feedback
            if (type === 'success' || type === 'error') {
                feedbackArea.style.animation = 'pulse 0.5s ease-in-out';
                setTimeout(() => {
                    feedbackArea.style.animation = '';
                }, 500);
            }
        }

        // Button event handlers
        document.getElementById('test-circuit-btn').addEventListener('click', function() {
            console.log('Testing circuit...');
            
            // Disable button during testing
            this.disabled = true;
            this.textContent = '⚡ Testing...';
            
            const analysis = getCircuitAnalysis();
            console.log('Circuit analysis:', analysis);
            
            setTimeout(() => {
                const isComplete = evaluateCircuit();
                
                if (isComplete) {
                    showFeedback('🎉 Circuit Complete! Electricity is flowing!', 'success');
                    
                    // Show current flow animation
                    visualizeCurrentFlow(true);
                    
                    // Show success modal after animation
                    setTimeout(() => {
                        showSuccessModal();
                    }, 1500);
                } else {
                    // Stop any current flow animation
                    visualizeCurrentFlow(false);
                    
                    // Provide specific feedback about why circuit failed
                    let message = '';
                    if (analysis.gapsFilled === 0) {
                        message = '❌ No materials placed. Drag materials to the gaps!';
                    } else if (analysis.gapsFilled < analysis.totalGaps) {
                        message = `❌ Try filling more gaps to complete the circuit.`;
                    } else {
                        message = '❌ Some materials are blocking electricity. Try different materials.';
                    }
                    showFeedback(message, 'error');
                }
                
                // Re-enable button
                this.disabled = false;
                this.textContent = '⚡ Test Circuit';
            }, 500); // Small delay for better UX
        });

        document.getElementById('reset-btn').addEventListener('click', function() {
            console.log('Reset button clicked - functionality will be added later');
        });

        function showSuccessModal() {
            // Get analysis of what materials were used
            const analysis = getCircuitAnalysis();
            
            // Populate materials used section with enhanced educational content
            const materialsDiv = document.getElementById('materials-used');
            let materialsHTML = '<h4>🔧 Materials You Used:</h4>';
            
            if (analysis.placedItems.length > 0) {
                materialsHTML += '<ul>';
                analysis.placedItems.forEach(item => {
                    const conductorClass = item.conductive ? 'conductor-text' : 'insulator-text';
                    const conductorType = item.conductive ? 'CONDUCTOR' : 'INSULATOR';
                    const explanation = item.conductive ? 
                        'allows electricity to flow through it easily!' : 
                        'blocks electricity from flowing through it.';
                    
                    materialsHTML += `<li><strong>${item.name}</strong> - <span class="${conductorClass}">${conductorType}</span> that ${explanation}</li>`;
                });
                materialsHTML += '</ul>';
                
                if (analysis.conductorsPlaced > 0) {
                    materialsHTML += `<p><strong>🎯 Perfect!</strong> You used <span class="conductor-text">${analysis.conductorsPlaced} conductor(s)</span> to complete the electrical circuit!</p>`;
                }
                
                // Add educational explanation
                materialsHTML += `<p><strong>💡 What you learned:</strong> Conductors like metals allow electricity to flow, while insulators like rubber and wood block it. That's why the light bulb glows when you use conductive materials!</p>`;
            } else {
                materialsHTML += '<p>No materials were needed - the circuit was already complete!</p>';
            }
            
            materialsDiv.innerHTML = materialsHTML;
            
            // Add celebration visual effects
            addCelebrationEffects();
            
            // Show modal with animation
            const modal = document.getElementById('success-modal');
            modal.style.display = 'block';
            
            // Add pulse animation to the modal content
            const modalContent = document.getElementById('success-content');
            modalContent.style.animation = 'pulse 0.6s ease-in-out';
            
            // Add confetti effect to the page background
            setTimeout(() => {
                createConfettiEffect();
            }, 200);
            
            // Play success sound effect (if available)
            playSuccessSound();
        }

        function addCelebrationEffects() {
            // Create sparkle particles around the light bulb
            if (gameState.bulb.sprite && gameState.bulb.isLit) {
                const bulbPos = gridToWorld(gameState.bulb.x, gameState.bulb.y);
                
                // Create multiple sparkle particles
                for (let i = 0; i < 12; i++) {
                    setTimeout(() => {
                        const angle = (i / 12) * Math.PI * 2;
                        const distance = 40 + Math.random() * 20;
                        const sparkleX = bulbPos.x + Math.cos(angle) * distance;
                        const sparkleY = bulbPos.y + Math.sin(angle) * distance;
                        
                        const sparkle = scene.add.star(sparkleX, sparkleY, 5, 4, 8, 0xFFD700);
                        sparkle.setAlpha(1);
                        
                        // Animate sparkle
                        scene.tweens.add({
                            targets: sparkle,
                            scaleX: 0,
                            scaleY: 0,
                            alpha: 0,
                            rotation: Math.PI * 2,
                            duration: 1000,
                            ease: 'Power2',
                            onComplete: () => sparkle.destroy()
                        });
                    }, i * 100);
                }
            }
            
            // Add screen flash effect
            const flash = scene.add.rectangle(
                gameState.gridWidth * gameState.cellSize / 2,
                gameState.gridHeight * gameState.cellSize / 2,
                gameState.gridWidth * gameState.cellSize,
                gameState.gridHeight * gameState.cellSize,
                0xFFFFFF
            );
            flash.setAlpha(0.6);
            
            scene.tweens.add({
                targets: flash,
                alpha: 0,
                duration: 300,
                ease: 'Power2',
                onComplete: () => flash.destroy()
            });
        }
        
        function playSuccessSound() {
            // Create a simple success sound using Web Audio API
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create a simple success melody
                const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5
                
                frequencies.forEach((freq, index) => {
                    setTimeout(() => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                    }, index * 150);
                });
            } catch (error) {
                console.log('Audio not available:', error);
            }
        }

        document.getElementById('play-again-btn').addEventListener('click', function() {
            hideSuccessModal();
            resetGame();
        });

        // Add event listener for new challenge button
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('new-challenge-btn').addEventListener('click', function() {
                hideSuccessModal();
                createNewChallenge();
            });
            
            // Add click outside modal to close
            document.getElementById('success-modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideSuccessModal();
                }
            });
            
            // Add escape key to close modal
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('success-modal').style.display === 'block') {
                    hideSuccessModal();
                }
            });
        });
        
        function createConfettiEffect() {
            // Create colorful confetti particles that fall from the top
            const colors = [0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0xFFA07A, 0x98D8C8, 0xF7DC6F];
            
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const x = Math.random() * (gameState.gridWidth * gameState.cellSize);
                    const y = -20;
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    const confetti = scene.add.rectangle(x, y, 8, 8, color);
                    confetti.setRotation(Math.random() * Math.PI * 2);
                    
                    // Animate falling confetti
                    scene.tweens.add({
                        targets: confetti,
                        y: gameState.gridHeight * gameState.cellSize + 50,
                        rotation: confetti.rotation + Math.PI * 4,
                        duration: 2000 + Math.random() * 1000,
                        ease: 'Power2',
                        onComplete: () => confetti.destroy()
                    });
                    
                    // Add side-to-side motion
                    scene.tweens.add({
                        targets: confetti,
                        x: x + (Math.random() - 0.5) * 100,
                        duration: 2000 + Math.random() * 1000,
                        ease: 'Sine.easeInOut',
                        yoyo: true,
                        repeat: 1
                    });
                }, i * 100);
            }
        }
        
        function hideSuccessModal() {
            const modal = document.getElementById('success-modal');
            const modalContent = document.getElementById('success-content');
            
            // Add fade out animation
            modalContent.style.animation = 'slideOut 0.3s ease-in';
            
            setTimeout(() => {
                modal.style.display = 'none';
                modalContent.style.animation = ''; // Reset animation
            }, 300);
        }

        function createNewChallenge() {
            // Reset the current game first
            resetGame();
            
            // Create a variation by changing gap positions slightly
            const challengeVariations = [
                // Original pattern
                [
                    { x: 3, y: 3 }, { x: 5, y: 3 }, { x: 7, y: 3 },
                    { x: 7, y: 5 }, { x: 5, y: 5 }, { x: 3, y: 5 }
                ],
                // Variation 1: Different gap spacing
                [
                    { x: 2, y: 3 }, { x: 4, y: 3 }, { x: 6, y: 3 }, { x: 8, y: 3 },
                    { x: 8, y: 5 }, { x: 6, y: 5 }, { x: 4, y: 5 }, { x: 2, y: 5 }
                ],
                // Variation 2: Fewer gaps (easier)
                [
                    { x: 4, y: 3 }, { x: 6, y: 3 },
                    { x: 6, y: 5 }, { x: 4, y: 5 }
                ]
            ];
            
            // Select a random variation (excluding current one)
            const currentPattern = JSON.stringify(gameState.gaps.map(g => ({x: g.x, y: g.y})));
            const availableVariations = challengeVariations.filter(v => 
                JSON.stringify(v) !== currentPattern
            );
            
            if (availableVariations.length > 0) {
                const newPattern = availableVariations[Math.floor(Math.random() * availableVariations.length)];
                
                // Clear existing gaps
                gameState.gaps.forEach(gap => {
                    if (gap.sprite) {
                        gap.sprite.destroy();
                    }
                });
                
                // Create new gap pattern
                gameState.gaps = newPattern.map(pos => ({
                    x: pos.x,
                    y: pos.y,
                    filled: false,
                    sprite: null
                }));
                
                // Recreate gap visuals
                markGaps();
                
                // Show challenge message
                const challengeMessages = [
                    '🆕 New Challenge! Different gap pattern - try it out!',
                    '⚡ Fresh Circuit! Can you solve this new layout?',
                    '🎯 Challenge Mode! New gaps to fill with conductors!'
                ];
                
                const randomMessage = challengeMessages[Math.floor(Math.random() * challengeMessages.length)];
                showFeedback(randomMessage, 'info');
                
                console.log('New challenge created with different gap pattern');
            } else {
                // Fallback to original reset with encouraging message
                showFeedback('🔄 Try the same circuit with different materials!', 'info');
                console.log('New challenge created - same pattern, try different materials');
            }
        }

        function resetGame() {
            console.log('Starting complete game reset...');
            
            // 1. Remove all placed items from circuit by scanning the entire grid
            for (let y = 0; y < gameState.gridHeight; y++) {
                for (let x = 0; x < gameState.gridWidth; x++) {
                    const gridItem = gameState.grid[y][x];
                    // Only remove items that are actual placed items (not pre-placed components)
                    if (gridItem && typeof gridItem === 'object' && 
                        gridItem.inBank !== undefined && gridItem.placed === true) {
                        console.log('Removing placed item from grid:', gridItem.name, 'at', x, y);
                        
                        // Clear the grid position first
                        gameState.grid[y][x] = null;
                        
                        // Destroy the sprite if it exists
                        if (gridItem.sprite) {
                            try {
                                if (gridItem.sprite.children && gridItem.sprite.children.entries) {
                                    gridItem.sprite.children.entries.forEach(child => {
                                        if (child) {
                                            child.setVisible(false);
                                            child.destroy();
                                        }
                                    });
                                }
                                gridItem.sprite.clear(true, true);
                                gridItem.sprite.destroy();
                            } catch (error) {
                                console.warn('Error destroying sprite during reset:', error);
                            }
                            gridItem.sprite = null;
                            gridItem.mainSprite = null;
                        }
                        
                        // Reset item state completely
                        gridItem.inBank = true;
                        gridItem.placed = false;
                        gridItem.gridX = -1;
                        gridItem.gridY = -1;
                        gridItem.isDragging = false;
                        
                        // Clear any stored positions
                        gridItem.originalX = undefined;
                        gridItem.originalY = undefined;
                        gridItem.originalGridX = undefined;
                        gridItem.originalGridY = undefined;
                        
                        // Clean up any removal hints
                        if (gridItem.removalHint) {
                            gridItem.removalHint.destroy();
                            gridItem.removalHint = null;
                        }
                    }
                }
            }
            
            // 2. Restore all items to original quantities in item bank
            gameState.itemBank.forEach(item => {
                // Reset item state to be in bank
                item.inBank = true;
                item.placed = false;
                item.gridX = -1;
                item.gridY = -1;
                item.isDragging = false;
                
                // Clear any stored positions
                item.originalX = undefined;
                item.originalY = undefined;
                item.originalGridX = undefined;
                item.originalGridY = undefined;
                
                // Show HTML element again with proper styling
                if (item.htmlElement) {
                    item.htmlElement.style.display = 'flex';
                    item.htmlElement.style.cursor = 'grab';
                    item.htmlElement.style.opacity = '1';
                    item.htmlElement.style.transform = 'scale(1)';
                    item.htmlElement.style.boxShadow = '';
                    item.htmlElement.style.animation = '';
                }
                
                console.log('Restored item to bank:', item.name);
            });
            
            // 3. Clear all gap positions back to empty state
            gameState.gaps.forEach(gap => {
                gap.filled = false;
                if (gap.sprite) {
                    gap.sprite.setVisible(true);
                }
                console.log('Reset gap at position:', gap.x, gap.y);
            });
            
            // 4. Turn off light bulb and clear any success states
            updateLightBulb(false);
            
            // Clear flow visualization
            if (gameState.flowVisualization) {
                gameState.flowVisualization.forEach(particle => {
                    if (particle.destroy) particle.destroy();
                });
                gameState.flowVisualization = [];
            }
            
            // Hide success modal if it's showing
            const successModal = document.getElementById('success-modal');
            if (successModal && successModal.style.display !== 'none') {
                successModal.style.display = 'none';
            }
            
            // Clear any drag state
            gameState.draggedItem = null;
            gameState.isDragging = false;
            document.body.style.cursor = 'default';
            
            // Clear any drop zone highlights
            highlightDropZones(false);
            
            // 5. Redraw base circuit with only pre-placed components
            // Clear connection graphics first
            clearConnectionGraphics();
            
            // Update wire connections to show base circuit only
            updateWireConnections();
            
            // Reset feedback to initial state
            showFeedback('Try different materials in the gaps to see which ones allow electricity to flow! Drag placed items away to remove them.', 'info');
            
            console.log('Complete game reset finished - all items returned to bank, gaps cleared, bulb off');
        }

        document.getElementById('reset-btn').addEventListener('click', function() {
            resetGame();
        });

        // Start the game
        game = new Phaser.Game(config);
    </script>
</body>
</html>